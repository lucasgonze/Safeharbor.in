<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;sendgrid&#x2F;node_modules&#x2F;nodemailer&#x2F;node_modules&#x2F;mailcomposer&#x2F;lib&#x2F;mailcomposer.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Enables filtering in class lists..html">Enables filtering in class lists.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings..html">Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised date and time strings..html">Namespace container for the JsWorld library objects..Class for parsing localised date and time strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised number strings..html">Namespace container for the JsWorld library objects..Class for parsing localised number strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;.html">Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;sendgrid&#x2F;node_modules&#x2F;nodemailer&#x2F;node_modules&#x2F;mailcomposer&#x2F;lib&#x2F;mailcomposer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var Stream = require(&quot;stream&quot;).Stream,
    utillib = require(&quot;util&quot;),
    mimelib = require(&quot;mimelib-noiconv&quot;),
    toPunycode = require(&quot;.&#x2F;punycode&quot;),
    DKIMSign = require(&quot;.&#x2F;dkim&quot;).DKIMSign,
    urlFetch = require(&quot;.&#x2F;urlfetch&quot;),
    fs = require(&quot;fs&quot;);

module.exports.MailComposer = MailComposer;

&#x2F;**
 * &lt;p&gt;Costructs a MailComposer object. This is a Stream instance so you could
 * pipe the output to a file or send it to network.&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Possible options properties are:&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;escapeSMTP&lt;&#x2F;b&gt; - convert dots in the beginning of line to double dots&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;encoding&lt;&#x2F;b&gt; - forced transport encoding (quoted-printable, base64, 7bit or 8bit)&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;keepBcc&lt;&#x2F;b&gt; - include Bcc: field in the message headers (default is false)&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Events&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;envelope&#x27;&lt;&#x2F;b&gt; - emits an envelope object with &lt;code&gt;from&lt;&#x2F;code&gt; and &lt;code&gt;to&lt;&#x2F;code&gt; (array) addresses.&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;data&#x27;&lt;&#x2F;b&gt; - emits a chunk of data&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;end&#x27;&lt;&#x2F;b&gt; - composing the message has ended&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * @constructor
 * @param {Object} [options] Optional options object
 *&#x2F;
function MailComposer(options){
    Stream.call(this);
    
    this.options = options || {};
    
    this._init();
}
utillib.inherits(MailComposer, Stream);

&#x2F;**
 * &lt;p&gt;Resets and initializes MailComposer&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._init = function(){
    &#x2F;**
     * &lt;p&gt;Contains all header values&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._headers = {};
    
    &#x2F;**
     * &lt;p&gt;Contains message related values&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._message = {};
    
    &#x2F;**
     * &lt;p&gt;Contains a list of attachments&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._attachments = [];
    
    &#x2F;**
     * &lt;p&gt;Contains a list of attachments that are related to HTML body&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._relatedAttachments = [];
    
    &#x2F;**
     * &lt;p&gt;Contains e-mail addresses for the SMTP&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._envelope = {};
    
    &#x2F;**
     * &lt;p&gt;If set to true, caches the output for further processing (DKIM signing etc.)&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._cacheOutput = false;
    
    &#x2F;**
     * &lt;p&gt;If _cacheOutput is true, caches the output to _outputBuffer&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._outputBuffer = &quot;&quot;;
    
    &#x2F;**
     * &lt;p&gt;DKIM message signing options, set with useDKIM&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._dkim = false;
    
    &#x2F;**
     * &lt;p&gt;Counter for generating unique mime boundaries etc.&lt;&#x2F;p&gt;
     * @private
     *&#x2F;
    this._gencounter = 0;
    
    this.addHeader(&quot;MIME-Version&quot;, &quot;1.0&quot;);
};

&#x2F;* PUBLIC API *&#x2F;

&#x2F;**
 * &lt;p&gt;Adds a header field to the headers object&lt;&#x2F;p&gt;
 * 
 * @param {String} key Key name
 * @param {String} value Header value
 *&#x2F;
MailComposer.prototype.addHeader = function(key, value){
    key = this._normalizeKey(key);
    
    if(value &amp;&amp; Object.prototype.toString.call(value) == &quot;[object Object]&quot;){
        value = this._encodeMimeWord(JSON.stringify(value), &quot;Q&quot;, 50);
    }else{
        value = (value || &quot;&quot;).toString().trim();
    }
    
    if(!key || !value){
        return;
    }
    
    if(!(key in this._headers)){
        this._headers[key] = value;
    }else{
        if(!Array.isArray(this._headers[key])){
            this._headers[key] = [this._headers[key], value];
        }else{
            this._headers[key].push(value);
        }
    }
};

&#x2F;**
 * &lt;p&gt;Resets and initializes MailComposer&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Setting an option overwrites an earlier setup for the same keys&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Possible options:&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;from&lt;&#x2F;b&gt; - The e-mail address of the sender. All e-mail addresses can be plain &lt;code&gt;sender@server.com&lt;&#x2F;code&gt; or formatted &lt;code&gt;Sender Name &amp;lt;sender@server.com&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;to&lt;&#x2F;b&gt; - Comma separated list of recipients e-mail addresses that will appear on the &lt;code&gt;To:&lt;&#x2F;code&gt; field&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;cc&lt;&#x2F;b&gt; - Comma separated list of recipients e-mail addresses that will appear on the &lt;code&gt;Cc:&lt;&#x2F;code&gt; field&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;bcc&lt;&#x2F;b&gt; - Comma separated list of recipients e-mail addresses that will appear on the &lt;code&gt;Bcc:&lt;&#x2F;code&gt; field&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;replyTo&lt;&#x2F;b&gt; - An e-mail address that will appear on the &lt;code&gt;Reply-To:&lt;&#x2F;code&gt; field&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;subject&lt;&#x2F;b&gt; - The subject of the e-mail&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;body&lt;&#x2F;b&gt; - The plaintext version of the message&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;html&lt;&#x2F;b&gt; - The HTML version of the message&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * @param {Object} options Message related options
 *&#x2F;
MailComposer.prototype.setMessageOption = function(options){
    var fields = [&quot;from&quot;, &quot;to&quot;, &quot;cc&quot;, &quot;bcc&quot;, &quot;replyTo&quot;, &quot;subject&quot;, &quot;body&quot;, &quot;html&quot;, &quot;envelope&quot;],
        rewrite = {&quot;sender&quot;:&quot;from&quot;, &quot;reply_to&quot;:&quot;replyTo&quot;, &quot;text&quot;:&quot;body&quot;};
    
    options = options || {};
    
    var keys = Object.keys(options), key, value;
    for(var i=0, len=keys.length; i&lt;len; i++){
        key = keys[i];
        value = options[key];
        
        if(key in rewrite){
            key = rewrite[key];
        }
        
        if(fields.indexOf(key) &gt;= 0){
            this._message[key] = this._handleValue(key, value);
        }
    }
};

&#x2F;**
 * &lt;p&gt;Setup DKIM for signing generated message. Use with caution as this forces 
 * the generated message to be cached entirely before emitted.&lt;&#x2F;p&gt;
 * 
 * @param {Object} dkim DKIM signing settings
 * @param {String} [dkim.headerFieldNames=&quot;from:to:cc:subject&quot;] Header fields to sign
 * @param {String} dkim.privateKey DKMI private key 
 * @param {String} dkim.domainName Domain name to use for signing (ie: &quot;domain.com&quot;)
 * @param {String} dkim.keySelector Selector for the DKMI public key (ie. &quot;dkim&quot; if you have set up a TXT record for &quot;dkim._domainkey.domain.com&quot;
 *&#x2F;
MailComposer.prototype.useDKIM = function(dkim){
    this._dkim = dkim || {};
    this._cacheOutput = true;
};

&#x2F;**
 * &lt;p&gt;Adds an attachment to the list&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Following options are allowed:&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;fileName&lt;&#x2F;b&gt; - filename for the attachment&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;contentType&lt;&#x2F;b&gt; - content type for the attachmetn (default will be derived from the filename)&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;cid&lt;&#x2F;b&gt; - Content ID value for inline images&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;contents&lt;&#x2F;b&gt; - String or Buffer attachment contents&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;filePath&lt;&#x2F;b&gt; - Path to a file for streaming&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;streamSource&lt;&#x2F;b&gt; - Stream object for arbitrary streams&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * &lt;p&gt;One of &lt;code&gt;contents&lt;&#x2F;code&gt; or &lt;code&gt;filePath&lt;&#x2F;code&gt; or &lt;code&gt;stream&lt;&#x2F;code&gt; 
 * must be specified, otherwise the attachment is not included&lt;&#x2F;p&gt;
 * 
 * @param {Object} attachment Attachment info
 *&#x2F;
MailComposer.prototype.addAttachment = function(attachment){
    attachment = attachment || {};
    var filename;
    
    &#x2F;&#x2F; Needed for Nodemailer compatibility
    if(attachment.filename){
        attachment.fileName = attachment.filename;
        delete attachment.filename;
    }
    
    if(!attachment.fileName &amp;&amp; attachment.filePath){
        attachment.fileName = attachment.filePath.split(&#x2F;[\&#x2F;\\]&#x2F;).pop();
    }
    
    if(!attachment.contentType){
        filename = attachment.fileName || attachment.filePath;
        if(filename){
            attachment.contentType = this._getMimeType(filename);
        }else{
            attachment.contentType = &quot;application&#x2F;octet-stream&quot;;
        }
    }
    
    if(attachment.streamSource){
        &#x2F;&#x2F; check for pause and resume support
        if(typeof attachment.streamSource.pause != &quot;function&quot; || 
          typeof attachment.streamSource.resume != &quot;function&quot;){
            &#x2F;&#x2F; Unsupported Stream source, skip it
            return;
        }
        attachment.streamSource.pause();
    }
    
    if(attachment.filePath || attachment.contents || attachment.streamSource){
        this._attachments.push(attachment);
    }
};

&#x2F;**
 * &lt;p&gt;Composes and returns an envelope from the &lt;code&gt;this._envelope&lt;&#x2F;code&gt; 
 * object. Needed for the SMTP client&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Generated envelope is int hte following structure:&lt;&#x2F;p&gt;
 * 
 * &lt;pre&gt;
 * {
 *     to: &quot;address&quot;,
 *     from: [&quot;list&quot;, &quot;of&quot;, &quot;addresses&quot;]
 * }
 * &lt;&#x2F;pre&gt;
 * 
 * &lt;p&gt;Both properties (&lt;code&gt;from&lt;&#x2F;code&gt; and &lt;code&gt;to&lt;&#x2F;code&gt;) are optional
 * and may not exist&lt;&#x2F;p&gt;
 * 
 * @return {Object} envelope object with &quot;from&quot; and &quot;to&quot; params
 *&#x2F;
MailComposer.prototype.getEnvelope = function(){
    var envelope = {},
        toKeys = [&quot;to&quot;, &quot;cc&quot;, &quot;bcc&quot;],
        key;
    
    &#x2F;&#x2F; If multiple addresses, only use the first one
    if(this._envelope.from &amp;&amp; this._envelope.from.length){
        envelope.from = [].concat(this._envelope.from).shift();
    }
    
    for(var i=0, len=toKeys.length; i&lt;len; i++){
        key = toKeys[i];
        if(this._envelope[key] &amp;&amp; this._envelope[key].length){
            if(!envelope.to){
                envelope.to = [];
            }
            envelope.to = envelope.to.concat(this._envelope[key]);
        }
    }
    
    &#x2F;&#x2F; every envelope needs a stamp :)
    envelope.stamp = &quot;Postage paid, Par Avion&quot;;
    
    return envelope;
};

&#x2F;**
 * &lt;p&gt;Starts streaming the message&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype.streamMessage = function(){
    process.nextTick(this._composeMessage.bind(this));
};

&#x2F;* PRIVATE API *&#x2F;

&#x2F;**
 * &lt;p&gt;Handles a message object value, converts addresses etc.&lt;&#x2F;p&gt;
 * 
 * @param {String} key Message options key
 * @param {String} value Message options value
 * @return {String} converted value
 *&#x2F;
MailComposer.prototype._handleValue = function(key, value){
    key = (key || &quot;&quot;).toString();
    
    var addresses;
    
    switch(key){
        case &quot;from&quot;:
        case &quot;to&quot;:
        case &quot;cc&quot;:
        case &quot;bcc&quot;:
        case &quot;replyTo&quot;:
            value = (value || &quot;&quot;).toString().replace(&#x2F;\r?\n|\r&#x2F;g, &quot; &quot;);
            addresses = mimelib.parseAddresses(value);
            if(!this._envelope.userDefined){
                this._envelope[key] = addresses.map((function(address){
                    if(this._hasUTFChars(address.address)){
                        return toPunycode(address.address);
                    }else{
                        return address.address;
                    }
                }).bind(this));
            }
            return this._convertAddresses(addresses);
        
        case &quot;subject&quot;:
            value = (value || &quot;&quot;).toString().replace(&#x2F;\r?\n|\r&#x2F;g, &quot; &quot;);
            return this._encodeMimeWord(value, &quot;Q&quot;, 50);
            
        case &quot;envelope&quot;:
            
            this._envelope = {
                userDefined: true
            };
            
            Object.keys(value).forEach((function(key){
                
                this._envelope[key] = [];
                
                [].concat(value[key]).forEach((function(address){
                    var addresses = mimelib.parseAddresses(address);
                
                    this._envelope[key] = this._envelope[key].concat(addresses.map((function(address){
                        if(this._hasUTFChars(address.address)){
                            return toPunycode(address.address);
                        }else{
                            return address.address;
                        }
                    }).bind(this)));
                    
                }).bind(this));
            }).bind(this));
            break;
    }
    
    return value;
};

&#x2F;**
 * &lt;p&gt;Handles a list of parsed e-mail addresses, checks encoding etc.&lt;&#x2F;p&gt;
 * 
 * @param {Array} value A list or single e-mail address &lt;code&gt;{address:&#x27;...&#x27;, name:&#x27;...&#x27;}&lt;&#x2F;code&gt;
 * @return {String} Comma separated and encoded list of addresses
 *&#x2F;
MailComposer.prototype._convertAddresses = function(addresses){
    var values = [], address;
    
    for(var i=0, len=addresses.length; i&lt;len; i++){
        address = addresses[i];
        
        if(address.address){
        
            &#x2F;&#x2F; if user part of the address contains foreign symbols
            &#x2F;&#x2F; make a mime word of it
            address.address = address.address.replace(&#x2F;^.*?(?=\@)&#x2F;, (function(user){
                if(this._hasUTFChars(user)){
                    return mimelib.encodeMimeWord(user, &quot;Q&quot;);
                }else{
                    return user;
                }
            }).bind(this));
            
            &#x2F;&#x2F; If there&#x27;s still foreign symbols, then punycode convert it
            if(this._hasUTFChars(address.address)){
                address.address = toPunycode(address.address);
            }
        
            if(!address.name){
                values.push(address.address);
            }else if(address.name){
                if(this._hasUTFChars(address.name)){
                    address.name = this._encodeMimeWord(address.name, &quot;Q&quot;, 50);
                }else{
                    address.name = address.name;
                }
                values.push(&#x27;&quot;&#x27; + address.name+&#x27;&quot; &lt;&#x27;+address.address+&#x27;&gt;&#x27;);
            }
        }
    }
    return values.join(&quot;, &quot;);
};

&#x2F;**
 * &lt;p&gt;Gets a header field&lt;&#x2F;p&gt;
 * 
 * @param {String} key Key name
 * @return {String|Array} Header field - if several values, then it&#x27;s an array
 *&#x2F;
MailComposer.prototype._getHeader = function(key){
    var value;
    
    key = this._normalizeKey(key);
    value = this._headers[key] || &quot;&quot;;
    
    return value;
};

&#x2F;**
 * &lt;p&gt;Generate an e-mail from the described info&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._composeMessage = function(){
    
    &#x2F;&#x2F; Generate headers for the message
    this._composeHeader();
    
    &#x2F;&#x2F; Make the mime tree flat
    this._flattenMimeTree();
    
    &#x2F;&#x2F; Compose message body
    this._composeBody();
    
};

&#x2F;**
 * &lt;p&gt;Composes a header for the message and emits it with a &lt;code&gt;&#x27;data&#x27;&lt;&#x2F;code&gt;
 * event&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Also checks and build a structure for the message (is it a multipart message
 * and does it need a boundary etc.)&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;By default the message is not a multipart. If the message containes both
 * plaintext and html contents, an alternative block is used. it it containes
 * attachments, a mixed block is used. If both alternative and mixed exist, then
 * alternative resides inside mixed.&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._composeHeader = function(){
    var headers = [], i, len;

    &#x2F;&#x2F; if an attachment uses content-id and is linked from the html
    &#x2F;&#x2F; then it should be placed in a separate &quot;related&quot; part with the html
    this._message.useRelated = false;
    if(this._message.html &amp;&amp; (len = this._attachments.length)){
        
        for(i=len-1; i&gt;=0; i--){
            if(this._attachments[i].cid &amp;&amp; 
              this._message.html.indexOf(&quot;cid:&quot;+this._attachments[i].cid)&gt;=0){
                this._message.useRelated = true;
                this._relatedAttachments.unshift(this._attachments[i]);
                this._attachments.splice(i,1);
            }
        }
        
    }

    if(this._attachments.length){
        this._message.useMixed = true;
        this._message.mixedBoundary = this._generateBoundary();
    }else{
        this._message.useMixed = false;
    }
    
    if(this._message.body &amp;&amp; this._message.html){
        this._message.useAlternative = true;
        this._message.alternativeBoundary = this._generateBoundary();
    }else{
        this._message.useAlternative = false;
    }
    
    &#x2F;&#x2F; let&#x27;s do it here, so the counter in the boundary would look better
    if(this._message.useRelated){
        this._message.relatedBoundary = this._generateBoundary();
    }
    
    if(!this._message.html &amp;&amp; !this._message.body){
        &#x2F;&#x2F; If there&#x27;s nothing to show, show a linebreak
        this._message.body = &quot;\r\n&quot;;
    }
    
    this._buildMessageHeaders();
    this._generateBodyStructure();
    
    &#x2F;&#x2F; Compile header lines
    headers = this.compileHeaders(this._headers);
    
    if(!this._cacheOutput){
        this.emit(&quot;data&quot;, new Buffer(headers.join(&quot;\r\n&quot;)+&quot;\r\n\r\n&quot;, &quot;utf-8&quot;));
    }else{
        this._outputBuffer += headers.join(&quot;\r\n&quot;)+&quot;\r\n\r\n&quot;;
    }
};

&#x2F;**
 * &lt;p&gt;Uses data from the &lt;code&gt;this._message&lt;&#x2F;code&gt; object to build headers&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._buildMessageHeaders = function(){

    &#x2F;&#x2F; FROM
    if(this._message.from &amp;&amp; this._message.from.length){
        [].concat(this._message.from).forEach((function(from){
            this.addHeader(&quot;From&quot;, from);
        }).bind(this));
    }
    
    &#x2F;&#x2F; TO
    if(this._message.to &amp;&amp; this._message.to.length){
        [].concat(this._message.to).forEach((function(to){
            this.addHeader(&quot;To&quot;, to);
        }).bind(this));
    }
    
    &#x2F;&#x2F; CC
    if(this._message.cc &amp;&amp; this._message.cc.length){
        [].concat(this._message.cc).forEach((function(cc){
            this.addHeader(&quot;Cc&quot;, cc);
        }).bind(this));
    }
    
    &#x2F;&#x2F; BCC
    &#x2F;&#x2F; By default not included, set options.keepBcc to true to keep
    if(this.options.keepBcc){
        if(this._message.bcc &amp;&amp; this._message.bcc.length){
            [].concat(this._message.bcc).forEach((function(bcc){
                this.addHeader(&quot;Bcc&quot;, bcc);
            }).bind(this));
        }    
    }
    
    &#x2F;&#x2F; REPLY-TO
    if(this._message.replyTo &amp;&amp; this._message.replyTo.length){
        [].concat(this._message.replyTo).forEach((function(replyTo){
            this.addHeader(&quot;Reply-To&quot;, replyTo);
        }).bind(this));
    }
    
    &#x2F;&#x2F; SUBJECT
    if(this._message.subject){
        this.addHeader(&quot;Subject&quot;, this._message.subject);
    }
};

&#x2F;**
 * &lt;p&gt;Generates the structure (mime tree) of the body. This sets up multipart
 * structure, individual part headers, boundaries etc.&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;The headers of the root element will be appended to the message
 * headers&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._generateBodyStructure = function(){

    var tree = this._createMimeNode(), 
        currentNode, node,
        i, len;
    
    if(this._message.useMixed){
        
        node = this._createMimeNode();
        node.boundary = this._message.mixedBoundary;
        node.headers.push([&quot;Content-Type&quot;, &quot;multipart&#x2F;mixed; boundary=\&quot;&quot;+node.boundary+&quot;\&quot;&quot;]);
        
        if(currentNode){
            currentNode.childNodes.push(node);
            node.parentNode = currentNode;
        }else{
            tree = node;
        }
        currentNode = node;
    
    }
    
    if(this._message.useAlternative){
    
        node = this._createMimeNode();
        node.boundary = this._message.alternativeBoundary;
        node.headers.push([&quot;Content-Type&quot;, &quot;multipart&#x2F;alternative; boundary=\&quot;&quot;+node.boundary+&quot;\&quot;&quot;]);
        if(currentNode){
            currentNode.childNodes.push(node);
            node.parentNode = currentNode;
        }else{
            tree = node;
        }
        currentNode = node;
        
    }
    
    if(this._message.body){
        node = this._createTextComponent(this._message.body, &quot;text&#x2F;plain&quot;);
        if(currentNode){
            currentNode.childNodes.push(node);
            node.parentNode = currentNode;
        }else{
            tree = node;
        }
    }
    
    if(this._message.useRelated){
    
        node = this._createMimeNode();
        node.boundary = this._message.relatedBoundary;
        node.headers.push([&quot;Content-Type&quot;, &quot;multipart&#x2F;related; boundary=\&quot;&quot;+node.boundary+&quot;\&quot;&quot;]);
        if(currentNode){
            currentNode.childNodes.push(node);
            node.parentNode = currentNode;
        }else{
            tree = node;
        }
        currentNode = node;
        
    }
    
    if(this._message.html){
        node = this._createTextComponent(this._message.html, &quot;text&#x2F;html&quot;);
        if(currentNode){
            currentNode.childNodes.push(node);
            node.parentNode = currentNode;
        }else{
            tree = node;
        }
    }
    
    &#x2F;&#x2F; Related attachments are added to the multipart&#x2F;related part
    if(this._relatedAttachments &amp;&amp; this._relatedAttachments){
        for(i=0, len = this._relatedAttachments.length; i&lt;len; i++){
            node = this._createAttachmentComponent(this._relatedAttachments[i]);
            node.parentNode = currentNode;
            currentNode.childNodes.push(node);
        }
    }
    
    &#x2F;&#x2F; Attachments are added to the first element (should be multipart&#x2F;mixed)
    currentNode = tree;
    if(this._attachments &amp;&amp; this._attachments.length){
        for(i=0, len = this._attachments.length; i&lt;len; i++){
            node = this._createAttachmentComponent(this._attachments[i]);
            node.parentNode = currentNode;
            currentNode.childNodes.push(node);
        }
    }
    
    &#x2F;&#x2F; Add the headers from the root element to the main headers list
    for(i=0, len=tree.headers.length; i&lt;len; i++){
        this.addHeader(tree.headers[i][0], tree.headers[i][1]);
    }
    
    this._message.tree = tree;
};

&#x2F;**
 * &lt;p&gt;Creates a mime tree node for a text component (plaintext, HTML)&lt;&#x2F;p&gt;
 * 
 * @param {String} text Text contents for the component
 * @param {String} [contentType=&quot;text&#x2F;plain&quot;] Content type for the text component
 * @return {Object} Mime tree node 
 *&#x2F;
MailComposer.prototype._createTextComponent = function(text, contentType){
    var node = this._createMimeNode();
    
    node.contentEncoding = (this.options.encoding || &quot;quoted-printable&quot;).toLowerCase().trim();
    node.useTextType = true;
    
    contentType = [contentType || &quot;text&#x2F;plain&quot;];
    contentType.push(&quot;charset=utf-8&quot;);
    
    if([&quot;7bit&quot;, &quot;8bit&quot;, &quot;binary&quot;].indexOf(node.contentEncoding)&gt;=0){
        node.textFormat = &quot;flowed&quot;;
        contentType.push(&quot;format=&quot; + node.textFormat);
    }
    
    node.headers.push([&quot;Content-Type&quot;, contentType.join(&quot;; &quot;)]);
    node.headers.push([&quot;Content-Transfer-Encoding&quot;, node.contentEncoding]);
    
    node.contents = text;
    
    return node;
};

&#x2F;**
 * &lt;p&gt;Creates a mime tree node for a text component (plaintext, HTML)&lt;&#x2F;p&gt;
 * 
 * @param {Object} attachment Attachment info for the component
 * @return {Object} Mime tree node 
 *&#x2F;
MailComposer.prototype._createAttachmentComponent = function(attachment){
    var node = this._createMimeNode(),
        contentType = [attachment.contentType],
        contentDisposition = [attachment.contentDisposition || &quot;attachment&quot;],
        fileName;
    
    node.contentEncoding = &quot;base64&quot;;
    node.useAttachmentType = true;
    
    if(attachment.fileName){
        fileName = this._encodeMimeWord(attachment.fileName, &quot;Q&quot;, 1024).replace(&#x2F;&quot;&#x2F;g,&quot;\\\&quot;&quot;);
        contentType.push(&quot;name=\&quot;&quot; +fileName+ &quot;\&quot;&quot;);
        contentDisposition.push(&quot;filename=\&quot;&quot; +fileName+ &quot;\&quot;&quot;);
    }
    
    node.headers.push([&quot;Content-Type&quot;, contentType.join(&quot;; &quot;)]);
    node.headers.push([&quot;Content-Disposition&quot;, contentDisposition.join(&quot;; &quot;)]);
    node.headers.push([&quot;Content-Transfer-Encoding&quot;, node.contentEncoding]);
    
    if(attachment.cid){
        node.headers.push([&quot;Content-Id&quot;, &quot;&lt;&quot; + this._encodeMimeWord(attachment.cid) + &quot;&gt;&quot;]);
    }
    
    if(attachment.contents){
        node.contents = attachment.contents;
    }else if(attachment.filePath){
        node.filePath = attachment.filePath;
        if(attachment.userAgent){
            node.userAgent = attachment.userAgent;
        }
    }else if(attachment.streamSource){
        node.streamSource = attachment.streamSource;
    }

    return node;
};

&#x2F;**
 * &lt;p&gt;Creates an empty mime tree node&lt;&#x2F;p&gt;
 * 
 * @return {Object} Mime tree node
 *&#x2F;
MailComposer.prototype._createMimeNode = function(){
    return {
        childNodes: [],
        headers: [],
        parentNode: null
    };
};

&#x2F;**
 * &lt;p&gt;Compiles headers object into an array of header lines. If needed, the
 * lines are folded&lt;&#x2F;p&gt;
 * 
 * @param {Object|Array} headers An object with headers in the form of
 *        &lt;code&gt;{key:value}&lt;&#x2F;code&gt; or &lt;ocde&gt;[[key, value]]&lt;&#x2F;code&gt; or
 *        &lt;code&gt;[{key:key, value: value}]&lt;&#x2F;code&gt;
 * @return {Array} A list of header lines. Can be joined with \r\n
 *&#x2F;
MailComposer.prototype.compileHeaders = function(headers){
    var headersArr = [], keys, key;

    if(Array.isArray(headers)){
        headersArr = headers.map(function(field){
            return mimelib.foldLine((field.key || field[0])+&quot;: &quot;+(field.value || field[1]));
        });
    }else{
        keys = Object.keys(headers);
        for(var i=0, len = keys.length; i&lt;len; i++){
            key = this._normalizeKey(keys[i]);
            
            headersArr = headersArr.concat([].concat(headers[key]).map(function(field){
                return mimelib.foldLine(key+&quot;: &quot;+field);
            }));
        }
    }
    
    return headersArr;
};

&#x2F;**
 * &lt;p&gt;Converts a structured mimetree into an one dimensional array of
 * components. This includes headers and multipart boundaries as strings,
 * textual and attachment contents are.&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._flattenMimeTree = function(){
    var flatTree = [];
    
    function walkTree(node, level){
        var contentObject = {};
        level = level || 0;
        
        &#x2F;&#x2F; if not root element, include headers
        if(level){
            flatTree = flatTree.concat(this.compileHeaders(node.headers));
            flatTree.push(&#x27;&#x27;);
        }
        
        if(node.textFormat){
            contentObject.textFormat = node.textFormat;
        }
        
        if(node.contentEncoding){
            contentObject.contentEncoding = node.contentEncoding;
        }
        
        if(node.contents){
            contentObject.contents = node.contents;
        }else if(node.filePath){
            contentObject.filePath = node.filePath;
            if(node.userAgent){
                contentObject.userAgent = node.userAgent;
            }
        }else if(node.streamSource){
            contentObject.streamSource = node.streamSource;
        }
        
        if(node.contents || node.filePath || node.streamSource){
            flatTree.push(contentObject);
        }
        
        &#x2F;&#x2F; walk children
        for(var i=0, len = node.childNodes.length; i&lt;len; i++){
            if(node.boundary){
                flatTree.push(&quot;--&quot;+node.boundary);
            }
            walkTree.call(this, node.childNodes[i], level+1);
        }
        if(node.boundary &amp;&amp; node.childNodes.length){
            flatTree.push(&quot;--&quot;+node.boundary+&quot;--&quot;);
            flatTree.push(&#x27;&#x27;);
        }
    }
    
    walkTree.call(this, this._message.tree);
    
    if(flatTree.length &amp;&amp; flatTree[flatTree.length-1]===&#x27;&#x27;){
        flatTree.pop();
    }
    
    this._message.flatTree = flatTree;
};

&#x2F;**
 * &lt;p&gt;Composes the e-mail body based on the previously generated mime tree&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Assumes that the linebreak separating headers and contents is already 
 * sent&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Emits &#x27;data&#x27; events&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._composeBody = function(){
    var flatTree = this._message.flatTree,
        slice, isObject = false, isEnd = false,
        curObject;
    
    this._message.processingStart = this._message.processingStart || 0;
    this._message.processingPos = this._message.processingPos || 0;

    for(var len = flatTree.length; this._message.processingPos &lt; len; this._message.processingPos++){
        
        isEnd = this._message.processingPos &gt;= len-1;
        isObject = typeof flatTree[this._message.processingPos] == &quot;object&quot;;
        
        if(isEnd || isObject){
            
            slice = flatTree.slice(this._message.processingStart, isEnd &amp;&amp; !isObject?undefined:this._message.processingPos);
            if(slice &amp;&amp; slice.length){
                if(!this._cacheOutput){
                    this.emit(&quot;data&quot;, new Buffer(slice.join(&quot;\r\n&quot;)+&quot;\r\n&quot;, &quot;utf-8&quot;));
                }else{
                    this._outputBuffer += slice.join(&quot;\r\n&quot;)+&quot;\r\n&quot;;
                }
            }
            
            if(isObject){
                curObject = flatTree[this._message.processingPos];
            
                this._message.processingPos++;
                this._message.processingStart = this._message.processingPos;
            
                this._emitDataElement(curObject, (function(){
                    if(!isEnd){
                        process.nextTick(this._composeBody.bind(this));
                    }else{
                        if(!this._cacheOutput){
                            this.emit(&quot;end&quot;);
                        }else{
                            this._processBufferedOutput();
                        }
                    }
                }).bind(this));
                
            }else if(isEnd){
                if(!this._cacheOutput){
                    this.emit(&quot;end&quot;);
                }else{
                    this._processBufferedOutput();
                }
            }
            break;
        }
        
    }
};

&#x2F;**
 * &lt;p&gt;Emits a data event for a text or html body and attachments. If it is a 
 * file, stream it&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;If &lt;code&gt;this.options.escapeSMTP&lt;&#x2F;code&gt; is true, replace dots in the
 * beginning of a line with double dots - only valid for QP encoding&lt;&#x2F;p&gt;
 * 
 * @param {Object} element Data element descriptor
 * @param {Function} callback Callback function to run when completed
 *&#x2F;
MailComposer.prototype._emitDataElement = function(element, callback){
    
    var data = &quot;&quot;;
    
    if(element.contents){
        switch(element.contentEncoding){
            case &quot;quoted-printable&quot;:
                data = mimelib.encodeQuotedPrintable(element.contents);
                break;
            case &quot;base64&quot;:
                data = new Buffer(element.contents, &quot;utf-8&quot;).toString(&quot;base64&quot;).replace(&#x2F;.{76}&#x2F;g,&quot;$&amp;\r\n&quot;);
                break;
            case &quot;7bit&quot;:
            case &quot;8bit&quot;:
            case &quot;binary&quot;:
            default:
                data = mimelib.foldLine(element.contents, 78, false, element.textFormat==&quot;flowed&quot;);
                 &#x2F;&#x2F;mimelib puts a long whitespace to the beginning of the lines
                data = data.replace(&#x2F;^[ ]{7}&#x2F;mg, &quot;&quot;);
                break;
        }
        
        if(this.options.escapeSMTP){
            data = data.replace(&#x2F;^\.&#x2F;gm,&#x27;..&#x27;);
        }
        
        if(!this._cacheOutput){
            this.emit(&quot;data&quot;, new Buffer(data + &quot;\r\n&quot;, &quot;utf-8&quot;));
        }else{
            this._outputBuffer += data + &quot;\r\n&quot;;
        }
        process.nextTick(callback);
        return;
    }

    if(element.filePath){
        if(element.filePath.match(&#x2F;^https?:\&#x2F;\&#x2F;&#x2F;)){
            this._serveStream(urlFetch(element.filePath, {userAgent: element.userAgent}), callback);
        }else{
            this._serveFile(element.filePath, callback);
        }
        return;
    }else if(element.streamSource){
        this._serveStream(element.streamSource, callback);
        return;
    }

    callback();
};

&#x2F;**
 * &lt;p&gt;Pipes a file to the e-mail stream&lt;&#x2F;p&gt;
 * 
 * @param {String} filePath Path to the file
 * @param {Function} callback Callback function to run after completion
 *&#x2F;
MailComposer.prototype._serveFile = function(filePath, callback){
    fs.stat(filePath, (function(err, stat){
        if(err || !stat.isFile()){
            

            if(!this._cacheOutput){
                this.emit(&quot;data&quot;, new Buffer(new Buffer(&quot;&lt;ERROR OPENING FILE&gt;&quot;, 
                                &quot;utf-8&quot;).toString(&quot;base64&quot;)+&quot;\r\n&quot;, &quot;utf-8&quot;));
            }else{
                this._outputBuffer += new Buffer(&quot;&lt;ERROR OPENING FILE&gt;&quot;, 
                                &quot;utf-8&quot;).toString(&quot;base64&quot;)+&quot;\r\n&quot;;
            }
                                
            process.nextTick(callback);
            return;
        }
        
        var stream = fs.createReadStream(filePath);
        
        this._serveStream(stream, callback);
        
    }).bind(this));
};

&#x2F;**
 * &lt;p&gt;Pipes a stream source to the e-mail stream&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;This function resumes the stream and starts sending 76 bytes long base64
 * encoded lines. To achieve this, the incoming stream is divded into
 * chunks of 57 bytes (57&#x2F;3*4=76) to achieve exactly 76 byte long
 * base64&lt;&#x2F;p&gt;
 * 
 * @param {Object} stream Stream to be piped
 * @param {Function} callback Callback function to run after completion
 *&#x2F;
MailComposer.prototype._serveStream = function(stream, callback){
    var remainder = new Buffer(0);

    stream.on(&quot;error&quot;, (function(error){
        if(!this._cacheOutput){
            this.emit(&quot;data&quot;, new Buffer(new Buffer(&quot;&lt;ERROR READING STREAM&gt;&quot;, 
                            &quot;utf-8&quot;).toString(&quot;base64&quot;)+&quot;\r\n&quot;, &quot;utf-8&quot;));
        }else{
            this._outputBuffer += new Buffer(&quot;&lt;ERROR READING STREAM&gt;&quot;, 
                            &quot;utf-8&quot;).toString(&quot;base64&quot;)+&quot;\r\n&quot;;
        }
        process.nextTick(callback);
    }).bind(this));
    
    stream.on(&quot;data&quot;, (function(chunk){
        var data = &quot;&quot;,
            len = remainder.length + chunk.length,
            remainderLength = len % 57, &#x2F;&#x2F; we use 57 bytes as it composes
                                        &#x2F;&#x2F; a 76 bytes long base64 string
            buffer = new Buffer(len);
        
        remainder.copy(buffer); &#x2F;&#x2F; copy remainder into the beginning of the new buffer
        chunk.copy(buffer, remainder.length); &#x2F;&#x2F; copy data chunk after the remainder
        remainder = buffer.slice(len - remainderLength); &#x2F;&#x2F; create a new remainder
        
        data = buffer.slice(0, len - remainderLength).toString(&quot;base64&quot;).replace(&#x2F;.{76}&#x2F;g,&quot;$&amp;\r\n&quot;);
        
        if(data.length){
            if(!this._cacheOutput){
                this.emit(&quot;data&quot;, new Buffer(data.trim()+&quot;\r\n&quot;, &quot;utf-8&quot;));
            }else{
                this._outputBuffer += data.trim()+&quot;\r\n&quot;;
            }
        }
    }).bind(this));
    
    stream.on(&quot;end&quot;, (function(chunk){
        var data;
        
        &#x2F;&#x2F; stream the remainder (if any)
        if(remainder.length){
            data = remainder.toString(&quot;base64&quot;).replace(&#x2F;.{76}&#x2F;g,&quot;$&amp;\r\n&quot;);
            if(!this._cacheOutput){
                this.emit(&quot;data&quot;, new Buffer(data.trim()+&quot;\r\n&quot;, &quot;utf-8&quot;));
            }else{
                this._outputBuffer += data.trim()+&quot;\r\n&quot;;
            }
        }
        process.nextTick(callback);
    }).bind(this));
    
    &#x2F;&#x2F; resume streaming if paused
    stream.resume();
};

&#x2F;**
 * &lt;p&gt;Processes buffered output and emits &#x27;end&#x27;&lt;&#x2F;p&gt;
 *&#x2F;
MailComposer.prototype._processBufferedOutput = function(){
    var dkimSignature;
    
    if(this._dkim){        
        if((dkimSignature = DKIMSign(this._outputBuffer, this._dkim))){
            this.emit(&quot;data&quot;, new Buffer(dkimSignature+&quot;\r\n&quot;, &quot;utf-8&quot;));
        }
    }
    
    this.emit(&quot;data&quot;, new Buffer(this._outputBuffer, &quot;utf-8&quot;));
    
    process.nextTick(this.emit.bind(this,&quot;end&quot;));
};

&#x2F;* HELPER FUNCTIONS *&#x2F;

&#x2F;**
 * &lt;p&gt;Normalizes a key name by cpitalizing first chars of words, except for 
 * custom keys (starting with &quot;X-&quot;) that have only uppercase letters, which will 
 * not be modified.&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;&lt;code&gt;x-mailer&lt;&#x2F;code&gt; will become &lt;code&gt;X-Mailer&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Needed to avoid duplicate header keys&lt;&#x2F;p&gt;
 * 
 * @param {String} key Key name
 * @return {String} First chars uppercased
 *&#x2F;
MailComposer.prototype._normalizeKey = function(key){
    key = (key || &quot;&quot;).toString().trim();
    
    &#x2F;&#x2F; If only uppercase letters, leave everything as is
    if(key.match(&#x2F;^X\-[A-Z0-9\-]+$&#x2F;)){
        return key;
    }
    
    &#x2F;&#x2F; Convert first letter upper case, others lower case 
    return key.
        toLowerCase().
        replace(&#x2F;^\S|[\-\s]\S&#x2F;g, function(c){
            return c.toUpperCase();
        }).
        replace(&#x2F;^MIME\-&#x2F;i, &quot;MIME-&quot;).
        replace(&#x2F;^DKIM\-&#x2F;i, &quot;DKIM-&quot;);
};

&#x2F;**
 * &lt;p&gt;Tests if a string has high bit (UTF-8) symbols&lt;&#x2F;p&gt;
 * 
 * @param {String} str String to be tested for high bit symbols
 * @return {Boolean} true if high bit symbols were found
 *&#x2F;
MailComposer.prototype._hasUTFChars = function(str){
    var rforeign = &#x2F;[^\u0000-\u007f]&#x2F;;
    return !!rforeign.test(str);
};

&#x2F;**
 * &lt;p&gt;Generates a boundary for multipart bodies&lt;&#x2F;p&gt;
 * 
 * @return {String} Boundary String
 *&#x2F;
MailComposer.prototype._generateBoundary = function(){
    &#x2F;&#x2F; &quot;_&quot; is not allowed in quoted-printable and &quot;?&quot; not in base64
    return &quot;----mailcomposer-?=_&quot;+(++this._gencounter)+&quot;-&quot;+Date.now();
};

&#x2F;**
 * &lt;p&gt;Converts a string to mime word format. If the length is longer than
 * &lt;code&gt;maxlen&lt;&#x2F;code&gt;, split it&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;If the string doesn&#x27;t have any unicode characters return the original 
 * string instead&lt;&#x2F;p&gt;
 * 
 * @param {String} str String to be encoded
 * @param {String} encoding Either Q for Quoted-Printable or B for Base64
 * @param {Number} [maxlen] Optional length of the resulting string, whitespace will be inserted if needed
 * 
 * @return {String} Mime-word encoded string (if needed)
 *&#x2F;
MailComposer.prototype._encodeMimeWord = function(str, encoding, maxlen){
    
    &#x2F;&#x2F; adjust maxlen by =?UTF-8?Q??=
    if(maxlen &amp;&amp; maxlen&gt;12){
        maxlen -= 12; 
    }
    
    encoding = (encoding || &quot;Q&quot;).toUpperCase(); 
    if(this._hasUTFChars(str)){
        str = mimelib.encodeMimeWord(str, encoding);
        if(maxlen &amp;&amp; str.length&gt;maxlen){
            if(encoding==&quot;Q&quot;){
                return &quot;=?UTF-8?Q?&quot;+this._splitEncodedString(str.split(&quot;?&quot;)[3], maxlen).join(&quot;?= =?UTF-8?Q?&quot;)+&quot;?=&quot;;
            }else{
                return &quot;=?UTF-8?&quot;+encoding+&quot;?&quot;+str.split(&quot;?&quot;)[3].replace(new RegExp(&quot;.{&quot;+maxlen+&quot;}&quot;,&quot;g&quot;),&quot;$&amp;?= =?UTF-8?&quot;+encoding+&quot;?&quot;)+&quot;?=&quot;;
            }
        }else{
            return str;
        }
    }else{
        return str;
    }
};

&#x2F;**
 * &lt;p&gt;Splits a mime-encoded string&lt;&#x2F;p&gt;
 * 
 * @param {String} str Input string
 * @param {Number} maxlen Maximum line length
 * @return {Array} split string
 *&#x2F;
MailComposer.prototype._splitEncodedString = function(str, maxlen){
    var curLine, match, chr, done,
        lines = [];

    while(str.length){
        curLine = str.substr(0, maxlen);
        
        &#x2F;&#x2F; move incomplete escaped char back to main
        if((match = curLine.match(&#x2F;\=[0-9A-F]?$&#x2F;i))){
            curLine = curLine.substr(0, match.index);
        }

        done = false;
        while(!done){
            done = true;
            &#x2F;&#x2F; check if not middle of a unicode char sequence
            if((match = str.substr(curLine.length).match(&#x2F;^\=([0-9A-F]{2})&#x2F;i))){
                chr = parseInt(match[1], 16);
                &#x2F;&#x2F; invalid sequence, move one char back anc recheck
                if(chr &lt; 0xC2 &amp;&amp; chr &gt; 0x7F){
                    curLine = curLine.substr(0, curLine.length-3);
                    done = false;
                }
            }
        }

        if(curLine.length){
            lines.push(curLine);
        }
        str = str.substr(curLine.length);
    }

    return lines;
};


&#x2F;**
 * &lt;p&gt;Resolves a mime type for a filename&lt;&#x2F;p&gt;
 * 
 * @param {String} filename Filename to check
 * @return {String} Corresponding mime type
 *&#x2F;
MailComposer.prototype._getMimeType = function(filename){
    var defaultMime = &quot;application&#x2F;octet-stream&quot;,
        extension = filename &amp;&amp; filename.substr(filename.lastIndexOf(&quot;.&quot;)+1).trim().toLowerCase();
    return extension &amp;&amp; mimelib.contentTypes[extension] || defaultMime;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
