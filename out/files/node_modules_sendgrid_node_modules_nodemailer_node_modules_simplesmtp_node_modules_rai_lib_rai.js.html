<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;sendgrid&#x2F;node_modules&#x2F;nodemailer&#x2F;node_modules&#x2F;simplesmtp&#x2F;node_modules&#x2F;rai&#x2F;lib&#x2F;rai.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Enables filtering in class lists..html">Enables filtering in class lists.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings..html">Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised date and time strings..html">Namespace container for the JsWorld library objects..Class for parsing localised date and time strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised number strings..html">Namespace container for the JsWorld library objects..Class for parsing localised number strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;.html">Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;sendgrid&#x2F;node_modules&#x2F;nodemailer&#x2F;node_modules&#x2F;simplesmtp&#x2F;node_modules&#x2F;rai&#x2F;lib&#x2F;rai.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @fileOverview This is the main file for the RAI library to create text based servers
 * @author &lt;a href=&quot;mailto:andris@node.ee&quot;&gt;Andris Reinman&lt;&#x2F;a&gt;
 * @version 0.1.3
 *&#x2F;

var netlib = require(&quot;net&quot;),
    utillib = require(&quot;util&quot;),
    EventEmitter = require(&#x27;events&#x27;).EventEmitter,
    starttls = require(&quot;.&#x2F;starttls&quot;).starttls,
    tlslib = require(&quot;tls&quot;),
    crypto = require(&quot;crypto&quot;),
    fs = require(&quot;fs&quot;);

&#x2F;&#x2F; Default credentials for starting TLS server
var defaultCredentials = {
    key: fs.readFileSync(__dirname+&quot;&#x2F;..&#x2F;cert&#x2F;key.pem&quot;),
    cert: fs.readFileSync(__dirname+&quot;&#x2F;..&#x2F;cert&#x2F;cert.pem&quot;)
};

&#x2F;&#x2F; Expose to the world
module.exports.RAIServer = RAIServer;
module.exports.runClientMockup = require(&quot;.&#x2F;mockup&quot;);

&#x2F;**
 * &lt;p&gt;Creates instance of RAIServer&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Options object has the following properties:&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;debug&lt;&#x2F;b&gt; - if set to true print traffic to console&lt;&#x2F;li&gt;
 *   &lt;li&gt;&lt;b&gt;disconnectOnTimeout&lt;&#x2F;b&gt; - if set to true close the connection on disconnect&lt;&#x2F;li&gt;
 *   &lt;li&gt;&lt;b&gt;secureConnection&lt;&#x2F;b&gt; - if set to true close the connection on disconnect&lt;&#x2F;li&gt;
 *   &lt;li&gt;&lt;b&gt;credentials&lt;&#x2F;b&gt; - credentials for secureConnection and STARTTLS&lt;&#x2F;li&gt;
 *   &lt;li&gt;&lt;b&gt;timeout&lt;&#x2F;b&gt; - timeout in milliseconds for disconnecting the client,
 *       defaults to 0 (no timeout)&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Events&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;connect&#x27;&lt;&#x2F;b&gt; - emitted if a client connects to the server, param
 *         is a client ({@link RAISocket}) object&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;error&#x27;&lt;&#x2F;b&gt; - emitted on error, has an error object as a param&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt; 
 * 
 * @constructor
 * @param {Object} [options] Optional options object
 *&#x2F;
function RAIServer(options){
    EventEmitter.call(this);
    
    this.options = options || {};
    
    this._createServer();
}
utillib.inherits(RAIServer, EventEmitter);

&#x2F;**
 * &lt;p&gt;Starts listening on selected port&lt;&#x2F;p&gt;
 * 
 * @param {Number} port The port to listen
 * @param {String} [host] The IP address to listen
 * @param {Function} callback The callback function to be run after the server
 * is listening, the only param is an error message if the operation failed 
 *&#x2F;
RAIServer.prototype.listen = function(port, host, callback){
    if(!callback &amp;&amp; typeof host==&quot;function&quot;){
        callback = host;
        host = undefined;
    }
    this._port = port;
    this._host = host;
    
    this._connected = false;
    if(callback){    
        this._server.on(&quot;listening&quot;, (function(){
            this._connected = true;
            callback(null);
        }).bind(this));
        
        this._server.on(&quot;error&quot;, (function(err){
            if(!this._connected){
                callback(err);
            }
        }).bind(this));
    }
    
    this._server.listen(this._port, this._host);
};

&#x2F;**
 * &lt;p&gt;Stops the server&lt;&#x2F;p&gt;
 * 
 * @param {Function} callback Is run when the server is closed 
 *&#x2F;
RAIServer.prototype.end = function(callback){
    this._server.on(&quot;close&quot;, callback);
    this._server.close();
};

&#x2F;**
 * &lt;p&gt;Creates a server with listener callback&lt;&#x2F;p&gt; 
 *&#x2F;
RAIServer.prototype._createServer = function(){
    if(this.options.secureConnection){
        this._server = tlslib.createServer(
            this.options.credentials || defaultCredentials,
            this._serverListener.bind(this));
    }else{
        this._server = netlib.createServer(this._serverListener.bind(this));
    }
    this._server.on(&quot;error&quot;, this._onError.bind(this));
};

&#x2F;**
 * &lt;p&gt;Listens for errors&lt;&#x2F;p&gt;
 * 
 * @event
 * @param {Object} err Error object
 *&#x2F;
RAIServer.prototype._onError = function(err){
    if(this._connected){
        this.emit(&quot;error&quot;, err);
    }
};

&#x2F;**
 * &lt;p&gt;Server listener that is run on client connection&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;{@link RAISocket} object instance is created based on the client socket
 *    and a &lt;code&gt;&#x27;connection&#x27;&lt;&#x2F;code&gt; event is emitted&lt;&#x2F;p&gt;
 * 
 * @param {Object} socket The socket to the client 
 *&#x2F;
RAIServer.prototype._serverListener = function(socket){
    if(this.options.debug){
        console.log(&quot;CONNECTION FROM &quot;+socket.remoteAddress);
    }
    
    var handler = new RAISocket(socket, this.options);
    
    socket.on(&quot;data&quot;, handler._onReceiveData.bind(handler));
    socket.on(&quot;end&quot;, handler._onEnd.bind(handler));
    socket.on(&quot;error&quot;, handler._onError.bind(handler));
    socket.on(&quot;timeout&quot;, handler._onTimeout.bind(handler));
    socket.on(&quot;close&quot;, handler._onClose.bind(handler));

    if(&quot;setKeepAlive&quot; in socket){
        socket.setKeepAlive(true); &#x2F;&#x2F; plaintext server
    }else if(socket.encrypted &amp;&amp; &quot;setKeepAlive&quot; in socket.encrypted){
        socket.encrypted.setKeepAlive(true); &#x2F;&#x2F; secure server
    }
    
    this.emit(&quot;connect&quot;, handler);
};

&#x2F;**
 * &lt;p&gt;Creates a instance for interacting with a client (socket)&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Optional options object is the same that is passed to the parent
 * {@link RAIServer} object&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Events&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;
 * 
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;command&#x27;&lt;&#x2F;b&gt; - emitted if a client sends a command. Gets two
 *         params - command (String) and payload (Buffer)&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;data&#x27;&lt;&#x2F;b&gt; - emitted when a chunk is received in data mode, the
 *         param being the payload (Buffer)&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;ready&#x27;&lt;&#x2F;b&gt; - emitted when data stream ends and normal command
 *         flow is recovered&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;tls&#x27;&lt;&#x2F;b&gt; - emitted when the connection is secured by TLS&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;error&#x27;&lt;&#x2F;b&gt; - emitted when an error occurs. Connection to the
 *         client is disconnected automatically. Param is an error object.&lt;&#x2F;l&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;timeout&#x27;&lt;&#x2F;b&gt; - emitted when a timeout occurs. Connection to the
 *         client is disconnected automatically if disconnectOnTimeout option 
 *         is set to true.&lt;&#x2F;l&gt;
 *     &lt;li&gt;&lt;b&gt;&#x27;end&#x27;&lt;&#x2F;b&gt; - emitted when the client disconnects&lt;&#x2F;l&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * @constructor
 * @param {Object} socket Socket for the client
 * @param {Object} [options] Optional options object
 *&#x2F;
function RAISocket(socket, options){
    EventEmitter.call(this);
    
    this.socket = socket;
    this.options = options || {};
    
    this.remoteAddress = socket.remoteAddress;
    
    this._dataMode = false;
    this._endDataModeSequence = &quot;\r\n.\r\n&quot;;
    this._endDataModeSequenceRegEx = &#x2F;\r\n\.\r\n|^\.\r\n&#x2F;;
    
    this.secureConnection = !!this.options.secureConnection;
    this._destroyed = false;
    this._remainder = &quot;&quot;;
    
    this._ignore_data = false;
    
    if(this.options.timeout){
        socket.setTimeout(this.options.timeout);
    }
}
utillib.inherits(RAISocket, EventEmitter);

&#x2F;**
 * &lt;p&gt;Sends some data to the client. &lt;code&gt;&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;&#x2F;code&gt; is automatically appended to
 *    the data&lt;&#x2F;p&gt;
 * 
 * @param {String|Buffer} data Data to be sent to the client
 *&#x2F;
RAISocket.prototype.send = function(data){
    var buffer;
    if(data instanceof Buffer || (typeof SlowBuffer != &quot;undefined&quot; &amp;&amp; data instanceof SlowBuffer)){
        buffer = new Buffer(data.length+2);
        buffer[buffer.length-2] = 0xD;
        buffer[buffer.length-1] = 0xA;
        data.copy(buffer);
    }else{
        buffer = new Buffer((data || &quot;&quot;).toString()+&quot;\r\n&quot;, &quot;binary&quot;);
    }
    
    if(this.options.debug){
        console.log(&quot;OUT: \&quot;&quot; +buffer.toString(&quot;utf-8&quot;).trim()+&quot;\&quot;&quot;);
    }
    
    if(this.socket &amp;&amp; this.socket.writable){
        this.socket.write(buffer);
    }else{
        this.socket.end();
    }
};

&#x2F;**
 * &lt;p&gt;Instructs the server to be listening for mixed data instead of line based
 *    commands&lt;&#x2F;p&gt;
 * 
 * @param {String} [sequence=&quot;.&quot;] - optional sequence on separate line for
 *        matching the data end
 *&#x2F;
RAISocket.prototype.startDataMode = function(sequence){
    this._dataMode = true;
    if(sequence){
        sequence = sequence.replace(&#x2F;\.\=\(\)\-\?\*\\\[\]\^\+\:\|\,&#x2F;g, &quot;\\$1&quot;);
        this._endDataModeSequence = &quot;\r\n&quot;+sequence+&quot;\r\n&quot;;
        this._endDataModeSequenceRegEx = new RegExp(&quot;&#x2F;\r\n&quot;+sequence+&quot;\r\n|^&quot;+sequence+&quot;\r\n&#x2F;&quot;);
    }
};

&#x2F;**
 * &lt;p&gt;Instructs the server to upgrade the connection to secure TLS connection&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Fires &lt;code&gt;callback&lt;&#x2F;code&gt; on successful connection upgrade if set, 
 * otherwise emits &lt;code&gt;&#x27;tls&#x27;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
 * 
 * @param {Object} [credentials] An object with PEM encoded key and 
 *        certificate &lt;code&gt;{key:&quot;---BEGIN...&quot;, cert:&quot;---BEGIN...&quot;}&lt;&#x2F;code&gt;,
 *        if not set autogenerated values will be used.
 * @param {Function} [callback] If calback is set fire it after successful connection
 *        upgrade, otherwise &lt;code&gt;&#x27;tls&#x27;&lt;&#x2F;code&gt; is emitted
 *&#x2F;
RAISocket.prototype.startTLS = function(credentials, callback){

    if(this.secureConnection){
        return this._onError(new Error(&quot;Secure connection already established&quot;));
    }
    
    if(!callback &amp;&amp; typeof credentials == &quot;function&quot;){
        callback = credentials;
        credentials = undefined;
    }
    
    credentials = credentials ||Â this.options.credentials || defaultCredentials;
    
    this._ignore_data = true;
    
    var secure_connector = starttls(this.socket, credentials, (function(ssl_socket){

        if(this.options.debug &amp;&amp; !ssl_socket.authorized){
            console.log(&quot;WARNING: TLS ERROR (&quot;+ssl_socket.authorizationError+&quot;)&quot;);
        }
        
        this._remainder = &quot;&quot;;
        this._ignore_data = false;
        
        this.secureConnection = true;
    
        this.socket = ssl_socket;
        this.socket.on(&quot;data&quot;, this._onReceiveData.bind(this));
        
        if(this.options.debug){
            console.log(&quot;TLS CONNECTION STARTED&quot;);
        }
        
        if(callback){
            callback();
        }else{
            this.emit(&quot;tls&quot;);
        }
        
    }).bind(this));
    
    secure_connector.on(&quot;error&quot;, (function(err){
        this._onError(err);
    }).bind(this));
};

&#x2F;**
 * &lt;p&gt;Closes the connection to the client&lt;&#x2F;p&gt;
 *&#x2F;
RAISocket.prototype.end = function(){
    this.socket.end();
};

&#x2F;**
 * &lt;p&gt;Called when a chunk of data arrives from the client. If currently in data
 * mode, transmit the data otherwise send it to &lt;code&gt;_processData&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
 * 
 * @event
 * @param {Buffer|String} chunk Data sent by the client
 *&#x2F;
RAISocket.prototype._onReceiveData = function(chunk){

    if(this._ignore_data){ &#x2F;&#x2F; if currently setting up TLS connection
        return;
    }
    
    var str = typeof chunk==&quot;string&quot;?chunk:chunk.toString(&quot;binary&quot;),
        dataEndMatch, dataRemainderMatch, data, match;
    
    if(this._dataMode){
        
        str = this._remainder + str;
        if((dataEndMatch = str.match(&#x2F;\r\n.*?$&#x2F;))){
            &#x2F;&#x2F; if ther&#x27;s a line that is not ended, keep it for later
            this._remainder = str.substr(dataEndMatch.index);
            str = str.substr(0, dataEndMatch.index);
        }else{
            this._remainder = &quot;&quot;;
        }

        &#x2F;&#x2F; check if a data end sequence is found from the data
        if((dataRemainderMatch = (str+this._remainder).match(this._endDataModeSequenceRegEx))){
            str = str + this._remainder;
            &#x2F;&#x2F; if the sequence is not on byte 0 emit remaining data
            if(dataRemainderMatch.index){
                data = new Buffer(str.substr(0, dataRemainderMatch.index), &quot;binary&quot;);
                if(this.options.debug){
                    console.log(&quot;DATA:&quot;, data.toString(&quot;utf-8&quot;));
                }
                this.emit(&quot;data&quot;, data);
            }
            &#x2F;&#x2F; emit data ready
            this._remainder = &quot;&quot;;
            this.emit(&quot;ready&quot;);
            this._dataMode = false;
            &#x2F;&#x2F; send the remaining data for processing
            this._processData(str.substr(dataRemainderMatch.index + dataRemainderMatch[0].length)+&quot;\r\n&quot;);
        }else{
            &#x2F;&#x2F; check if there&#x27;s not something in the end of the data that resembles
            &#x2F;&#x2F; end sequence - if so, cut it off and save it to the remainder
            str = str + this._remainder;
            this._remainder=  &quot;&quot;;
            for(var i = Math.min(this._endDataModeSequence.length-1, str.length); i&gt;0; i--){
                match = this._endDataModeSequence.substr(0, i);
                if(str.substr(-match.length) == match){
                    this._remainder = str.substr(-match.length);
                    str = str.substr(0, str.length - match.length);
                }
            }

            &#x2F;&#x2F; if there&#x27;s some data leht, emit it
            if(str.length){
                data = new Buffer(str, &quot;binary&quot;);
                if(this.options.debug){
                    console.log(&quot;DATA:&quot;, data.toString(&quot;utf-8&quot;));
                }
                this.emit(&quot;data&quot;, data);
            }
        }
    }else{
        &#x2F;&#x2F; Not in data mode, process as command
        this._processData(str);
    }
};

&#x2F;**
 * &lt;p&gt;Processed incoming command lines and emits found data as 
 * &lt;code&gt;&#x27;command&#x27;&lt;&#x2F;code&gt; with the command name as the first param and the rest
 * of the data as second (Buffer)&lt;&#x2F;p&gt;
 * 
 * @param {String} str Binary string to be processed
 *&#x2F;
RAISocket.prototype._processData = function(str){
    if(!str.length){
        return;
    }
    var lines = (this._remainder+str).split(&quot;\r\n&quot;),
        match, command;
        
    this._remainder = lines.pop();
    
    for(var i=0, len = lines.length; i&lt;len; i++){
        if(this._ignore_data){
            &#x2F;&#x2F; If TLS upgrade is initiated do not process current buffer
            this._remainder = &quot;&quot;;
            break;
        }
        if(!this._dataMode){
            if((match = lines[i].match(&#x2F;\s*[\S]+\s?&#x2F;))){
                command = (match[0] || &quot;&quot;).trim();
                if(this.options.debug){
                    console.log(&quot;COMMAND:&quot;, lines[i]);
                }
                this.emit(&quot;command&quot;, command, new Buffer(lines[i].substr(match.index + match[0].length), &quot;binary&quot;));
            }
        }else{
            if(this._remainder){
                this._remainder += &quot;\r\n&quot;;
            }
            this._onReceiveData(lines.slice(i).join(&quot;\r\n&quot;));
            break;
        }
    }  
};

&#x2F;**
 * &lt;p&gt;Called when the connection is or is going to be ended&lt;&#x2F;p&gt; 
 *&#x2F;
RAISocket.prototype._destroy = function(){
    if(this._destroyed)return;
    this._destroyed = true;
    
    this.removeAllListeners();
};

&#x2F;**
 * &lt;p&gt;Called when the connection is ended. Emits &lt;code&gt;&#x27;end&#x27;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
 * 
 * @event
 *&#x2F;
RAISocket.prototype._onEnd = function(){
    this.emit(&quot;end&quot;);
    this._destroy();
};

&#x2F;**
 * &lt;p&gt;Called when an error has appeared. Emits &lt;code&gt;&#x27;error&#x27;&lt;&#x2F;code&gt; with
 * the error object as a parameter.&lt;&#x2F;p&gt;
 * 
 * @event
 * @param {Object} err Error object
 *&#x2F;
RAISocket.prototype._onError = function(err){
    this.emit(&quot;error&quot;, err);
    this._destroy();
};

&#x2F;**
 * &lt;p&gt;Called when a timeout has occured. Connection will be closed and
 * &lt;code&gt;&#x27;timeout&#x27;&lt;&#x2F;code&gt; is emitted.&lt;&#x2F;p&gt;
 * 
 * @event
 *&#x2F;
RAISocket.prototype._onTimeout = function(){
    if(this.options.disconnectOnTimeout){
        if(this.socket &amp;&amp; !this.socket.destroyed){
            this.socket.end();
        }
        this.emit(&quot;timeout&quot;);
        this._destroy();
    }else{
        this.emit(&quot;timeout&quot;);
    }
};

&#x2F;**
 * &lt;p&gt;Called when the connection is closed&lt;&#x2F;p&gt;
 * 
 * @event
 * @param {Boolean} hadError did the connection end because of an error?
 *&#x2F;
RAISocket.prototype._onClose = function(hadError){
    this._destroy();
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
