<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;handlebars&#x2F;node_modules&#x2F;uglify-js&#x2F;lib&#x2F;consolidator.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Enables filtering in class lists..html">Enables filtering in class lists.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings..html">Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised date and time strings..html">Namespace container for the JsWorld library objects..Class for parsing localised date and time strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised number strings..html">Namespace container for the JsWorld library objects..Class for parsing localised number strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;.html">Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;handlebars&#x2F;node_modules&#x2F;uglify-js&#x2F;lib&#x2F;consolidator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @preserve Copyright 2012 Robert Gust-Bardon &lt;http:&#x2F;&#x2F;robert.gust-bardon.org&#x2F;&gt;.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and&#x2F;or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *&#x2F;

&#x2F;**
 * @fileoverview Enhances &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mishoo&#x2F;UglifyJS&#x2F;&quot;
 * &gt;UglifyJS&lt;&#x2F;a&gt; with consolidation of null, Boolean, and String values.
 * &lt;p&gt;Also known as aliasing, this feature has been deprecated in &lt;a href=
 * &quot;http:&#x2F;&#x2F;closure-compiler.googlecode.com&#x2F;&quot;&gt;the Closure Compiler&lt;&#x2F;a&gt; since its
 * initial release, where it is unavailable from the &lt;abbr title=
 * &quot;command line interface&quot;&gt;CLI&lt;&#x2F;a&gt;. The Closure Compiler allows one to log and
 * influence this process. In contrast, this implementation does not introduce
 * any variable declarations in global code and derives String values from
 * identifier names used as property accessors.&lt;&#x2F;p&gt;
 * &lt;p&gt;Consolidating literals may worsen the data compression ratio when an &lt;a
 * href=&quot;http:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc2616#section-3.5&quot;&gt;encoding
 * transformation&lt;&#x2F;a&gt; is applied. For instance, &lt;a href=
 * &quot;http:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-1.7.1.js&quot;&gt;jQuery 1.7.1&lt;&#x2F;a&gt; takes 248235 bytes.
 * Building it with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mishoo&#x2F;UglifyJS&#x2F;tarball&#x2F;v1.2.5&quot;&gt;
 * UglifyJS v1.2.5&lt;&#x2F;a&gt; results in 93647 bytes (37.73% of the original) which are
 * then compressed to 33154 bytes (13.36% of the original) using &lt;a href=
 * &quot;http:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;1&#x2F;gzip&quot;&gt;gzip(1)&lt;&#x2F;a&gt;. Building it with the same
 * version of UglifyJS 1.2.5 patched with the implementation of consolidation
 * results in 80784 bytes (a decrease of 12863 bytes, i.e. 13.74%, in comparison
 * to the aforementioned 93647 bytes) which are then compressed to 34013 bytes
 * (an increase of 859 bytes, i.e. 2.59%, in comparison to the aforementioned
 * 33154 bytes).&lt;&#x2F;p&gt;
 * &lt;p&gt;Written in &lt;a href=&quot;http:&#x2F;&#x2F;es5.github.com&#x2F;#x4.2.2&quot;&gt;the strict variant&lt;&#x2F;a&gt;
 * of &lt;a href=&quot;http:&#x2F;&#x2F;es5.github.com&#x2F;&quot;&gt;ECMA-262 5.1 Edition&lt;&#x2F;a&gt;. Encoded in &lt;a
 * href=&quot;http:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc3629&quot;&gt;UTF-8&lt;&#x2F;a&gt;. Follows &lt;a href=
 * &quot;http:&#x2F;&#x2F;google-styleguide.googlecode.com&#x2F;svn-history&#x2F;r76&#x2F;trunk&#x2F;javascriptguide.xml&quot;
 * &gt;Revision 2.28 of the Google JavaScript Style Guide&lt;&#x2F;a&gt; (except for the
 * discouraged use of the {@code function} tag and the {@code namespace} tag).
 * 100% typed for the &lt;a href=
 * &quot;http:&#x2F;&#x2F;closure-compiler.googlecode.com&#x2F;files&#x2F;compiler-20120123.tar.gz&quot;
 * &gt;Closure Compiler Version 1741&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
 * &lt;p&gt;Should you find this software useful, please consider &lt;a href=
 * &quot;https:&#x2F;&#x2F;paypal.com&#x2F;cgi-bin&#x2F;webscr?cmd=_s-xclick&amp;hosted_button_id=JZLW72X8FD4WG&quot;
 * &gt;a donation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
 * @author follow.me@RGustBardon (Robert Gust-Bardon)
 * @supported Tested with:
 *     &lt;ul&gt;
 *     &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v0.6.10&#x2F;&quot;&gt;Node v0.6.10&lt;&#x2F;a&gt;,&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mishoo&#x2F;UglifyJS&#x2F;tarball&#x2F;v1.2.5&quot;&gt;UglifyJS
 *       v1.2.5&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
 *     &lt;&#x2F;ul&gt;
 *&#x2F;

&#x2F;*global console:false, exports:true, module:false, require:false *&#x2F;
&#x2F;*jshint sub:true *&#x2F;
&#x2F;**
 * Consolidates null, Boolean, and String values found inside an &lt;abbr title=
 * &quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;.
 * @param {!TSyntacticCodeUnit} oAbstractSyntaxTree An array-like object
 *     representing an &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;.
 * @return {!TSyntacticCodeUnit} An array-like object representing an &lt;abbr
 *     title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt; with its null, Boolean, and
 *     String values consolidated.
 *&#x2F;
&#x2F;&#x2F; TODO(user) Consolidation of mathematical values found in numeric literals.
&#x2F;&#x2F; TODO(user) Unconsolidation.
&#x2F;&#x2F; TODO(user) Consolidation of ECMA-262 6th Edition programs.
&#x2F;&#x2F; TODO(user) Rewrite in ECMA-262 6th Edition.
exports[&#x27;ast_consolidate&#x27;] = function(oAbstractSyntaxTree) {
  &#x27;use strict&#x27;;
  &#x2F;*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
        latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
        onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
        sub:false, trailing:true *&#x2F;

  var _,
      &#x2F;**
       * A record consisting of data about one or more source elements.
       * @constructor
       * @nosideeffects
       *&#x2F;
      TSourceElementsData = function() {
        &#x2F;**
         * The category of the elements.
         * @type {number}
         * @see ESourceElementCategories
         *&#x2F;
        this.nCategory = ESourceElementCategories.N_OTHER;
        &#x2F;**
         * The number of occurrences (within the elements) of each primitive
         * value that could be consolidated.
         * @type {!Array.&lt;!Object.&lt;string, number&gt;&gt;}
         *&#x2F;
        this.aCount = [];
        this.aCount[EPrimaryExpressionCategories.N_IDENTIFIER_NAMES] = {};
        this.aCount[EPrimaryExpressionCategories.N_STRING_LITERALS] = {};
        this.aCount[EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS] =
            {};
        &#x2F;**
         * Identifier names found within the elements.
         * @type {!Array.&lt;string&gt;}
         *&#x2F;
        this.aIdentifiers = [];
        &#x2F;**
         * Prefixed representation Strings of each primitive value that could be
         * consolidated within the elements.
         * @type {!Array.&lt;string&gt;}
         *&#x2F;
        this.aPrimitiveValues = [];
      },
      &#x2F;**
       * A record consisting of data about a primitive value that could be
       * consolidated.
       * @constructor
       * @nosideeffects
       *&#x2F;
      TPrimitiveValue = function() {
        &#x2F;**
         * The difference in the number of terminal symbols between the original
         * source text and the one with the primitive value consolidated. If the
         * difference is positive, the primitive value is considered worthwhile.
         * @type {number}
         *&#x2F;
        this.nSaving = 0;
        &#x2F;**
         * An identifier name of the variable that will be declared and assigned
         * the primitive value if the primitive value is consolidated.
         * @type {string}
         *&#x2F;
        this.sName = &#x27;&#x27;;
      },
      &#x2F;**
       * A record consisting of data on what to consolidate within the range of
       * source elements that is currently being considered.
       * @constructor
       * @nosideeffects
       *&#x2F;
      TSolution = function() {
        &#x2F;**
         * An object whose keys are prefixed representation Strings of each
         * primitive value that could be consolidated within the elements and
         * whose values are corresponding data about those primitive values.
         * @type {!Object.&lt;string, {nSaving: number, sName: string}&gt;}
         * @see TPrimitiveValue
         *&#x2F;
        this.oPrimitiveValues = {};
        &#x2F;**
         * The difference in the number of terminal symbols between the original
         * source text and the one with all the worthwhile primitive values
         * consolidated.
         * @type {number}
         * @see TPrimitiveValue#nSaving
         *&#x2F;
        this.nSavings = 0;
      },
      &#x2F;**
       * The processor of &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;s found
       * in UglifyJS.
       * @namespace
       * @type {!TProcessor}
       *&#x2F;
      oProcessor = (&#x2F;** @type {!TProcessor} *&#x2F; require(&#x27;.&#x2F;process&#x27;)),
      &#x2F;**
       * A record consisting of a number of constants that represent the
       * difference in the number of terminal symbols between a source text with
       * a modified syntactic code unit and the original one.
       * @namespace
       * @type {!Object.&lt;string, number&gt;}
       *&#x2F;
      oWeights = {
        &#x2F;**
         * The difference in the number of punctuators required by the bracket
         * notation and the dot notation.
         * &lt;p&gt;&lt;code&gt;&#x27;[]&#x27;.length - &#x27;.&#x27;.length&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
         * @const
         * @type {number}
         *&#x2F;
        N_PROPERTY_ACCESSOR: 1,
        &#x2F;**
         * The number of punctuators required by a variable declaration with an
         * initialiser.
         * &lt;p&gt;&lt;code&gt;&#x27;:&#x27;.length + &#x27;;&#x27;.length&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
         * @const
         * @type {number}
         *&#x2F;
        N_VARIABLE_DECLARATION: 2,
        &#x2F;**
         * The number of terminal symbols required to introduce a variable
         * statement (excluding its variable declaration list).
         * &lt;p&gt;&lt;code&gt;&#x27;var &#x27;.length&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
         * @const
         * @type {number}
         *&#x2F;
        N_VARIABLE_STATEMENT_AFFIXATION: 4,
        &#x2F;**
         * The number of terminal symbols needed to enclose source elements
         * within a function call with no argument values to a function with an
         * empty parameter list.
         * &lt;p&gt;&lt;code&gt;&#x27;(function(){}());&#x27;.length&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
         * @const
         * @type {number}
         *&#x2F;
        N_CLOSURE: 17
      },
      &#x2F;**
       * Categories of primary expressions from which primitive values that
       * could be consolidated are derivable.
       * @namespace
       * @enum {number}
       *&#x2F;
      EPrimaryExpressionCategories = {
        &#x2F;**
         * Identifier names used as property accessors.
         * @type {number}
         *&#x2F;
        N_IDENTIFIER_NAMES: 0,
        &#x2F;**
         * String literals.
         * @type {number}
         *&#x2F;
        N_STRING_LITERALS: 1,
        &#x2F;**
         * Null and Boolean literals.
         * @type {number}
         *&#x2F;
        N_NULL_AND_BOOLEAN_LITERALS: 2
      },
      &#x2F;**
       * Prefixes of primitive values that could be consolidated.
       * The String values of the prefixes must have same number of characters.
       * The prefixes must not be used in any properties defined in any version
       * of &lt;a href=
       * &quot;http:&#x2F;&#x2F;www.ecma-international.org&#x2F;publications&#x2F;standards&#x2F;Ecma-262.htm&quot;
       * &gt;ECMA-262&lt;&#x2F;a&gt;.
       * @namespace
       * @enum {string}
       *&#x2F;
      EValuePrefixes = {
        &#x2F;**
         * Identifies String values.
         * @type {string}
         *&#x2F;
        S_STRING: &#x27;#S&#x27;,
        &#x2F;**
         * Identifies null and Boolean values.
         * @type {string}
         *&#x2F;
        S_SYMBOLIC: &#x27;#O&#x27;
      },
      &#x2F;**
       * Categories of source elements in terms of their appropriateness of
       * having their primitive values consolidated.
       * @namespace
       * @enum {number}
       *&#x2F;
      ESourceElementCategories = {
        &#x2F;**
         * Identifies a source element that includes the &lt;a href=
         * &quot;http:&#x2F;&#x2F;es5.github.com&#x2F;#x12.10&quot;&gt;{@code with}&lt;&#x2F;a&gt; statement.
         * @type {number}
         *&#x2F;
        N_WITH: 0,
        &#x2F;**
         * Identifies a source element that includes the &lt;a href=
         * &quot;http:&#x2F;&#x2F;es5.github.com&#x2F;#x15.1.2.1&quot;&gt;{@code eval}&lt;&#x2F;a&gt; identifier name.
         * @type {number}
         *&#x2F;
        N_EVAL: 1,
        &#x2F;**
         * Identifies a source element that must be excluded from the process
         * unless its whole scope is examined.
         * @type {number}
         *&#x2F;
        N_EXCLUDABLE: 2,
        &#x2F;**
         * Identifies source elements not posing any problems.
         * @type {number}
         *&#x2F;
        N_OTHER: 3
      },
      &#x2F;**
       * The list of literals (other than the String ones) whose primitive
       * values can be consolidated.
       * @const
       * @type {!Array.&lt;string&gt;}
       *&#x2F;
      A_OTHER_SUBSTITUTABLE_LITERALS = [
        &#x27;null&#x27;,   &#x2F;&#x2F; The null literal.
        &#x27;false&#x27;,  &#x2F;&#x2F; The Boolean literal {@code false}.
        &#x27;true&#x27;    &#x2F;&#x2F; The Boolean literal {@code true}.
      ];

  (&#x2F;**
    * Consolidates all worthwhile primitive values in a syntactic code unit.
    * @param {!TSyntacticCodeUnit} oSyntacticCodeUnit An array-like object
    *     representing the branch of the abstract syntax tree representing the
    *     syntactic code unit along with its scope.
    * @see TPrimitiveValue#nSaving
    *&#x2F;
   function fExamineSyntacticCodeUnit(oSyntacticCodeUnit) {
     var _,
         &#x2F;**
          * Indicates whether the syntactic code unit represents global code.
          * @type {boolean}
          *&#x2F;
         bIsGlobal = &#x27;toplevel&#x27; === oSyntacticCodeUnit[0],
         &#x2F;**
          * Indicates whether the whole scope is being examined.
          * @type {boolean}
          *&#x2F;
         bIsWhollyExaminable = !bIsGlobal,
         &#x2F;**
          * An array-like object representing source elements that constitute a
          * syntactic code unit.
          * @type {!TSyntacticCodeUnit}
          *&#x2F;
         oSourceElements,
         &#x2F;**
          * A record consisting of data about the source element that is
          * currently being examined.
          * @type {!TSourceElementsData}
          *&#x2F;
         oSourceElementData,
         &#x2F;**
          * The scope of the syntactic code unit.
          * @type {!TScope}
          *&#x2F;
         oScope,
         &#x2F;**
          * An instance of an object that allows the traversal of an &lt;abbr
          * title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;.
          * @type {!TWalker}
          *&#x2F;
         oWalker,
         &#x2F;**
          * An object encompassing collections of functions used during the
          * traversal of an &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;.
          * @namespace
          * @type {!Object.&lt;string, !Object.&lt;string, function(...[*])&gt;&gt;}
          *&#x2F;
         oWalkers = {
           &#x2F;**
            * A collection of functions used during the surveyance of source
            * elements.
            * @namespace
            * @type {!Object.&lt;string, function(...[*])&gt;}
            *&#x2F;
           oSurveySourceElement: {
             &#x2F;**#nocode+*&#x2F;  &#x2F;&#x2F; JsDoc Toolkit 2.4.0 hides some of the keys.
             &#x2F;**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {string} sIdentifier The identifier of the function.
              * @param {!Array.&lt;string&gt;} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              *&#x2F;
             &#x27;defun&#x27;: function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               fClassifyAsExcludable();
               fAddIdentifier(sIdentifier);
               aFormalParameterList.forEach(fAddIdentifier);
             },
             &#x2F;**
              * Increments the count of the number of occurrences of the String
              * value that is equivalent to the sequence of terminal symbols
              * that constitute the encountered identifier name.
              * @param {!TSyntacticCodeUnit} oExpression The nonterminal
              *     MemberExpression.
              * @param {string} sIdentifierName The identifier name used as the
              *     property accessor.
              * @return {!Array} The encountered branch of an &lt;abbr title=
              *     &quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt; with its nonterminal
              *     MemberExpression traversed.
              *&#x2F;
             &#x27;dot&#x27;: function(oExpression, sIdentifierName) {
               fCountPrimaryExpression(
                   EPrimaryExpressionCategories.N_IDENTIFIER_NAMES,
                   EValuePrefixes.S_STRING + sIdentifierName);
               return [&#x27;dot&#x27;, oWalker.walk(oExpression), sIdentifierName];
             },
             &#x2F;**
              * Adds the optional identifier of the function and its formal
              * parameters to the list of identifier names found.
              * @param {?string} sIdentifier The optional identifier of the
              *     function.
              * @param {!Array.&lt;string&gt;} aFormalParameterList Formal parameters.
              * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
              *&#x2F;
             &#x27;function&#x27;: function(
                 sIdentifier,
                 aFormalParameterList,
                 oFunctionBody) {
               if (&#x27;string&#x27; === typeof sIdentifier) {
                 fAddIdentifier(sIdentifier);
               }
               aFormalParameterList.forEach(fAddIdentifier);
             },
             &#x2F;**
              * Either increments the count of the number of occurrences of the
              * encountered null or Boolean value or classifies a source element
              * as containing the {@code eval} identifier name.
              * @param {string} sIdentifier The identifier encountered.
              *&#x2F;
             &#x27;name&#x27;: function(sIdentifier) {
               if (-1 !== A_OTHER_SUBSTITUTABLE_LITERALS.indexOf(sIdentifier)) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_NULL_AND_BOOLEAN_LITERALS,
                     EValuePrefixes.S_SYMBOLIC + sIdentifier);
               } else {
                 if (&#x27;eval&#x27; === sIdentifier) {
                   oSourceElementData.nCategory =
                       ESourceElementCategories.N_EVAL;
                 }
                 fAddIdentifier(sIdentifier);
               }
             },
             &#x2F;**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name.
              * @param {TSyntacticCodeUnit} oExpression The expression whose
              *     value is to be returned.
              *&#x2F;
             &#x27;return&#x27;: function(oExpression) {
               fClassifyAsExcludable();
             },
             &#x2F;**
              * Increments the count of the number of occurrences of the
              * encountered String value.
              * @param {string} sStringValue The String value of the string
              *     literal encountered.
              *&#x2F;
             &#x27;string&#x27;: function(sStringValue) {
               if (sStringValue.length &gt; 0) {
                 fCountPrimaryExpression(
                     EPrimaryExpressionCategories.N_STRING_LITERALS,
                     EValuePrefixes.S_STRING + sStringValue);
               }
             },
             &#x2F;**
              * Adds the identifier reserved for an exception to the list of
              * identifier names found.
              * @param {!TSyntacticCodeUnit} oTry A block of code in which an
              *     exception can occur.
              * @param {Array} aCatch The identifier reserved for an exception
              *     and a block of code to handle the exception.
              * @param {TSyntacticCodeUnit} oFinally An optional block of code
              *     to be evaluated regardless of whether an exception occurs.
              *&#x2F;
             &#x27;try&#x27;: function(oTry, aCatch, oFinally) {
               if (Array.isArray(aCatch)) {
                 fAddIdentifier(aCatch[0]);
               }
             },
             &#x2F;**
              * Classifies the source element as excludable if it does not
              * contain a {@code with} statement or the {@code eval} identifier
              * name. Adds the identifier of each declared variable to the list
              * of identifier names found.
              * @param {!Array.&lt;!Array&gt;} aVariableDeclarationList Variable
              *     declarations.
              *&#x2F;
             &#x27;var&#x27;: function(aVariableDeclarationList) {
               fClassifyAsExcludable();
               aVariableDeclarationList.forEach(fAddVariable);
             },
             &#x2F;**
              * Classifies a source element as containing the {@code with}
              * statement.
              * @param {!TSyntacticCodeUnit} oExpression An expression whose
              *     value is to be converted to a value of type Object and
              *     become the binding object of a new object environment
              *     record of a new lexical environment in which the statement
              *     is to be executed.
              * @param {!TSyntacticCodeUnit} oStatement The statement to be
              *     executed in the augmented lexical environment.
              * @return {!Array} An empty array to stop the traversal.
              *&#x2F;
             &#x27;with&#x27;: function(oExpression, oStatement) {
               oSourceElementData.nCategory = ESourceElementCategories.N_WITH;
               return [];
             }
             &#x2F;**#nocode-*&#x2F;  &#x2F;&#x2F; JsDoc Toolkit 2.4.0 hides some of the keys.
           },
           &#x2F;**
            * A collection of functions used while looking for nested functions.
            * @namespace
            * @type {!Object.&lt;string, function(...[*])&gt;}
            *&#x2F;
           oExamineFunctions: {
             &#x2F;**#nocode+*&#x2F;  &#x2F;&#x2F; JsDoc Toolkit 2.4.0 hides some of the keys.
             &#x2F;**
              * Orders an examination of a nested function declaration.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an &lt;abbr title=&quot;abstract syntax tree&quot;
              *     &gt;AST&lt;&#x2F;abbr&gt; representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              *&#x2F;
             &#x27;defun&#x27;: function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             },
             &#x2F;**
              * Orders an examination of a nested function expression.
              * @this {!TSyntacticCodeUnit} An array-like object representing
              *     the branch of an &lt;abbr title=&quot;abstract syntax tree&quot;
              *     &gt;AST&lt;&#x2F;abbr&gt; representing the syntactic code unit along with
              *     its scope.
              * @return {!Array} An empty array to stop the traversal.
              *&#x2F;
             &#x27;function&#x27;: function() {
               fExamineSyntacticCodeUnit(this);
               return [];
             }
             &#x2F;**#nocode-*&#x2F;  &#x2F;&#x2F; JsDoc Toolkit 2.4.0 hides some of the keys.
           }
         },
         &#x2F;**
          * Records containing data about source elements.
          * @type {Array.&lt;TSourceElementsData&gt;}
          *&#x2F;
         aSourceElementsData = [],
         &#x2F;**
          * The index (in the source text order) of the source element
          * immediately following a &lt;a href=&quot;http:&#x2F;&#x2F;es5.github.com&#x2F;#x14.1&quot;
          * &gt;Directive Prologue&lt;&#x2F;a&gt;.
          * @type {number}
          *&#x2F;
         nAfterDirectivePrologue = 0,
         &#x2F;**
          * The index (in the source text order) of the source element that is
          * currently being considered.
          * @type {number}
          *&#x2F;
         nPosition,
         &#x2F;**
          * The index (in the source text order) of the source element that is
          * the last element of the range of source elements that is currently
          * being considered.
          * @type {(undefined|number)}
          *&#x2F;
         nTo,
         &#x2F;**
          * Initiates the traversal of a source element.
          * @param {!TWalker} oWalker An instance of an object that allows the
          *     traversal of an abstract syntax tree.
          * @param {!TSyntacticCodeUnit} oSourceElement A source element from
          *     which the traversal should commence.
          * @return {function(): !TSyntacticCodeUnit} A function that is able to
          *     initiate the traversal from a given source element.
          *&#x2F;
         cContext = function(oWalker, oSourceElement) {
           &#x2F;**
            * @return {!TSyntacticCodeUnit} A function that is able to
            *     initiate the traversal from a given source element.
            *&#x2F;
           var fLambda = function() {
             return oWalker.walk(oSourceElement);
           };

           return fLambda;
         },
         &#x2F;**
          * Classifies the source element as excludable if it does not
          * contain a {@code with} statement or the {@code eval} identifier
          * name.
          *&#x2F;
         fClassifyAsExcludable = function() {
           if (oSourceElementData.nCategory ===
               ESourceElementCategories.N_OTHER) {
             oSourceElementData.nCategory =
                 ESourceElementCategories.N_EXCLUDABLE;
           }
         },
         &#x2F;**
          * Adds an identifier to the list of identifier names found.
          * @param {string} sIdentifier The identifier to be added.
          *&#x2F;
         fAddIdentifier = function(sIdentifier) {
           if (-1 === oSourceElementData.aIdentifiers.indexOf(sIdentifier)) {
             oSourceElementData.aIdentifiers.push(sIdentifier);
           }
         },
         &#x2F;**
          * Adds the identifier of a variable to the list of identifier names
          * found.
          * @param {!Array} aVariableDeclaration A variable declaration.
          *&#x2F;
         fAddVariable = function(aVariableDeclaration) {
           fAddIdentifier(&#x2F;** @type {string} *&#x2F; aVariableDeclaration[0]);
         },
         &#x2F;**
          * Increments the count of the number of occurrences of the prefixed
          * String representation attributed to the primary expression.
          * @param {number} nCategory The category of the primary expression.
          * @param {string} sName The prefixed String representation attributed
          *     to the primary expression.
          *&#x2F;
         fCountPrimaryExpression = function(nCategory, sName) {
           if (!oSourceElementData.aCount[nCategory].hasOwnProperty(sName)) {
             oSourceElementData.aCount[nCategory][sName] = 0;
             if (-1 === oSourceElementData.aPrimitiveValues.indexOf(sName)) {
               oSourceElementData.aPrimitiveValues.push(sName);
             }
           }
           oSourceElementData.aCount[nCategory][sName] += 1;
         },
         &#x2F;**
          * Consolidates all worthwhile primitive values in a range of source
          *     elements.
          * @param {number} nFrom The index (in the source text order) of the
          *     source element that is the first element of the range.
          * @param {number} nTo The index (in the source text order) of the
          *     source element that is the last element of the range.
          * @param {boolean} bEnclose Indicates whether the range should be
          *     enclosed within a function call with no argument values to a
          *     function with an empty parameter list if any primitive values
          *     are consolidated.
          * @see TPrimitiveValue#nSaving
          *&#x2F;
         fExamineSourceElements = function(nFrom, nTo, bEnclose) {
           var _,
               &#x2F;**
                * The index of the last mangled name.
                * @type {number}
                *&#x2F;
               nIndex = oScope.cname,
               &#x2F;**
                * The index of the source element that is currently being
                * considered.
                * @type {number}
                *&#x2F;
               nPosition,
               &#x2F;**
                * A collection of functions used during the consolidation of
                * primitive values and identifier names used as property
                * accessors.
                * @namespace
                * @type {!Object.&lt;string, function(...[*])&gt;}
                *&#x2F;
               oWalkersTransformers = {
                 &#x2F;**
                  * If the String value that is equivalent to the sequence of
                  * terminal symbols that constitute the encountered identifier
                  * name is worthwhile, a syntactic conversion from the dot
                  * notation to the bracket notation ensues with that sequence
                  * being substituted by an identifier name to which the value
                  * is assigned.
                  * Applies to property accessors that use the dot notation.
                  * @param {!TSyntacticCodeUnit} oExpression The nonterminal
                  *     MemberExpression.
                  * @param {string} sIdentifierName The identifier name used as
                  *     the property accessor.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  *&#x2F;
                 &#x27;dot&#x27;: function(oExpression, sIdentifierName) {
                   &#x2F;**
                    * The prefixed String value that is equivalent to the
                    * sequence of terminal symbols that constitute the
                    * encountered identifier name.
                    * @type {string}
                    *&#x2F;
                   var sPrefixed = EValuePrefixes.S_STRING + sIdentifierName;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &amp;&amp;
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving &gt; 0 ?
                       [&#x27;sub&#x27;,
                        oWalker.walk(oExpression),
                        [&#x27;name&#x27;,
                         oSolutionBest.oPrimitiveValues[sPrefixed].sName]] :
                       [&#x27;dot&#x27;, oWalker.walk(oExpression), sIdentifierName];
                 },
                 &#x2F;**
                  * If the encountered identifier is a null or Boolean literal
                  * and its value is worthwhile, the identifier is substituted
                  * by an identifier name to which that value is assigned.
                  * Applies to identifier names.
                  * @param {string} sIdentifier The identifier encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  *&#x2F;
                 &#x27;name&#x27;: function(sIdentifier) {
                   &#x2F;**
                    * The prefixed representation String of the identifier.
                    * @type {string}
                    *&#x2F;
                   var sPrefixed = EValuePrefixes.S_SYMBOLIC + sIdentifier;

                   return [
                     &#x27;name&#x27;,
                     oSolutionBest.oPrimitiveValues.hasOwnProperty(sPrefixed) &amp;&amp;
                     oSolutionBest.oPrimitiveValues[sPrefixed].nSaving &gt; 0 ?
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName :
                     sIdentifier
                   ];
                 },
                 &#x2F;**
                  * If the encountered String value is worthwhile, it is
                  * substituted by an identifier name to which that value is
                  * assigned.
                  * Applies to String values.
                  * @param {string} sStringValue The String value of the string
                  *     literal encountered.
                  * @return {!Array} A syntactic code unit that is equivalent to
                  *     the one encountered.
                  * @see TPrimitiveValue#nSaving
                  *&#x2F;
                 &#x27;string&#x27;: function(sStringValue) {
                   &#x2F;**
                    * The prefixed representation String of the primitive value
                    * of the literal.
                    * @type {string}
                    *&#x2F;
                   var sPrefixed =
                       EValuePrefixes.S_STRING + sStringValue;

                   return oSolutionBest.oPrimitiveValues.hasOwnProperty(
                       sPrefixed) &amp;&amp;
                       oSolutionBest.oPrimitiveValues[sPrefixed].nSaving &gt; 0 ?
                       [&#x27;name&#x27;,
                        oSolutionBest.oPrimitiveValues[sPrefixed].sName] :
                       [&#x27;string&#x27;, sStringValue];
                 }
               },
               &#x2F;**
                * Such data on what to consolidate within the range of source
                * elements that is currently being considered that lead to the
                * greatest known reduction of the number of the terminal symbols
                * in comparison to the original source text.
                * @type {!TSolution}
                *&#x2F;
               oSolutionBest = new TSolution(),
               &#x2F;**
                * Data representing an ongoing attempt to find a better
                * reduction of the number of the terminal symbols in comparison
                * to the original source text than the best one that is
                * currently known.
                * @type {!TSolution}
                * @see oSolutionBest
                *&#x2F;
               oSolutionCandidate = new TSolution(),
               &#x2F;**
                * A record consisting of data about the range of source elements
                * that is currently being examined.
                * @type {!TSourceElementsData}
                *&#x2F;
               oSourceElementsData = new TSourceElementsData(),
               &#x2F;**
                * Variable declarations for each primitive value that is to be
                * consolidated within the elements.
                * @type {!Array.&lt;!Array&gt;}
                *&#x2F;
               aVariableDeclarations = [],
               &#x2F;**
                * Augments a list with a prefixed representation String.
                * @param {!Array.&lt;string&gt;} aList A list that is to be augmented.
                * @return {function(string)} A function that augments a list
                *     with a prefixed representation String.
                *&#x2F;
               cAugmentList = function(aList) {
                 &#x2F;**
                  * @param {string} sPrefixed Prefixed representation String of
                  *     a primitive value that could be consolidated within the
                  *     elements.
                  *&#x2F;
                 var fLambda = function(sPrefixed) {
                   if (-1 === aList.indexOf(sPrefixed)) {
                     aList.push(sPrefixed);
                   }
                 };

                 return fLambda;
               },
               &#x2F;**
                * Adds the number of occurrences of a primitive value of a given
                * category that could be consolidated in the source element with
                * a given index to the count of occurrences of that primitive
                * value within the range of source elements that is currently
                * being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @param {number} nCategory The category of the primary
                *     expression from which the primitive value is derived.
                * @return {function(string)} A function that performs the
                *     addition.
                * @see cAddOccurrencesInCategory
                *&#x2F;
               cAddOccurrences = function(nPosition, nCategory) {
                 &#x2F;**
                  * @param {string} sPrefixed The prefixed representation String
                  *     of a primitive value.
                  *&#x2F;
                 var fLambda = function(sPrefixed) {
                   if (!oSourceElementsData.aCount[nCategory].hasOwnProperty(
                           sPrefixed)) {
                     oSourceElementsData.aCount[nCategory][sPrefixed] = 0;
                   }
                   oSourceElementsData.aCount[nCategory][sPrefixed] +=
                       aSourceElementsData[nPosition].aCount[nCategory][
                           sPrefixed];
                 };

                 return fLambda;
               },
               &#x2F;**
                * Adds the number of occurrences of each primitive value of a
                * given category that could be consolidated in the source
                * element with a given index to the count of occurrences of that
                * primitive values within the range of source elements that is
                * currently being considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                * @return {function(number)} A function that performs the
                *     addition.
                * @see fAddOccurrences
                *&#x2F;
               cAddOccurrencesInCategory = function(nPosition) {
                 &#x2F;**
                  * @param {number} nCategory The category of the primary
                  *     expression from which the primitive value is derived.
                  *&#x2F;
                 var fLambda = function(nCategory) {
                   Object.keys(
                       aSourceElementsData[nPosition].aCount[nCategory]
                   ).forEach(cAddOccurrences(nPosition, nCategory));
                 };

                 return fLambda;
               },
               &#x2F;**
                * Adds the number of occurrences of each primitive value that
                * could be consolidated in the source element with a given index
                * to the count of occurrences of that primitive values within
                * the range of source elements that is currently being
                * considered.
                * @param {number} nPosition The index (in the source text order)
                *     of a source element.
                *&#x2F;
               fAddOccurrences = function(nPosition) {
                 Object.keys(aSourceElementsData[nPosition].aCount).forEach(
                     cAddOccurrencesInCategory(nPosition));
               },
               &#x2F;**
                * Creates a variable declaration for a primitive value if that
                * primitive value is to be consolidated within the elements.
                * @param {string} sPrefixed Prefixed representation String of a
                *     primitive value that could be consolidated within the
                *     elements.
                * @see aVariableDeclarations
                *&#x2F;
               cAugmentVariableDeclarations = function(sPrefixed) {
                 if (oSolutionBest.oPrimitiveValues[sPrefixed].nSaving &gt; 0) {
                   aVariableDeclarations.push([
                     oSolutionBest.oPrimitiveValues[sPrefixed].sName,
                     [0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC) ?
                      &#x27;name&#x27; : &#x27;string&#x27;,
                      sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length)]
                   ]);
                 }
               },
               &#x2F;**
                * Sorts primitive values with regard to the difference in the
                * number of terminal symbols between the original source text
                * and the one with those primitive values consolidated.
                * @param {string} sPrefixed0 The prefixed representation String
                *     of the first of the two primitive values that are being
                *     compared.
                * @param {string} sPrefixed1 The prefixed representation String
                *     of the second of the two primitive values that are being
                *     compared.
                * @return {number}
                *     &lt;dl&gt;
                *         &lt;dt&gt;-1&lt;&#x2F;dt&gt;
                *         &lt;dd&gt;if the first primitive value must be placed before
                *              the other one,&lt;&#x2F;dd&gt;
                *         &lt;dt&gt;0&lt;&#x2F;dt&gt;
                *         &lt;dd&gt;if the first primitive value may be placed before
                *              the other one,&lt;&#x2F;dd&gt;
                *         &lt;dt&gt;1&lt;&#x2F;dt&gt;
                *         &lt;dd&gt;if the first primitive value must not be placed
                *              before the other one.&lt;&#x2F;dd&gt;
                *     &lt;&#x2F;dl&gt;
                * @see TSolution.oPrimitiveValues
                *&#x2F;
               cSortPrimitiveValues = function(sPrefixed0, sPrefixed1) {
                 &#x2F;**
                  * The difference between:
                  * &lt;ol&gt;
                  * &lt;li&gt;the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     first primitive value consolidated, and&lt;&#x2F;li&gt;
                  * &lt;li&gt;the difference in the number of terminal symbols
                  *     between the original source text and the one with the
                  *     second primitive value consolidated.&lt;&#x2F;li&gt;
                  * &lt;&#x2F;ol&gt;
                  * @type {number}
                  *&#x2F;
                 var nDifference =
                     oSolutionCandidate.oPrimitiveValues[sPrefixed0].nSaving -
                     oSolutionCandidate.oPrimitiveValues[sPrefixed1].nSaving;

                 return nDifference &gt; 0 ? -1 : nDifference &lt; 0 ? 1 : 0;
               },
               &#x2F;**
                * Assigns an identifier name to a primitive value and calculates
                * whether instances of that primitive value are worth
                * consolidating.
                * @param {string} sPrefixed The prefixed representation String
                *     of a primitive value that is being evaluated.
                *&#x2F;
               fEvaluatePrimitiveValue = function(sPrefixed) {
                 var _,
                     &#x2F;**
                      * The index of the last mangled name.
                      * @type {number}
                      *&#x2F;
                     nIndex,
                     &#x2F;**
                      * The representation String of the primitive value that is
                      * being evaluated.
                      * @type {string}
                      *&#x2F;
                     sName =
                         sPrefixed.substring(EValuePrefixes.S_SYMBOLIC.length),
                     &#x2F;**
                      * The number of source characters taken up by the
                      * representation String of the primitive value that is
                      * being evaluated.
                      * @type {number}
                      *&#x2F;
                     nLengthOriginal = sName.length,
                     &#x2F;**
                      * The number of source characters taken up by the
                      * identifier name that could substitute the primitive
                      * value that is being evaluated.
                      * substituted.
                      * @type {number}
                      *&#x2F;
                     nLengthSubstitution,
                     &#x2F;**
                      * The number of source characters taken up by by the
                      * representation String of the primitive value that is
                      * being evaluated when it is represented by a string
                      * literal.
                      * @type {number}
                      *&#x2F;
                     nLengthString = oProcessor.make_string(sName).length;

                 oSolutionCandidate.oPrimitiveValues[sPrefixed] =
                     new TPrimitiveValue();
                 do {  &#x2F;&#x2F; Find an identifier unused in this or any nested scope.
                   nIndex = oScope.cname;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].sName =
                       oScope.next_mangled();
                 } while (-1 !== oSourceElementsData.aIdentifiers.indexOf(
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].sName));
                 nLengthSubstitution = oSolutionCandidate.oPrimitiveValues[
                     sPrefixed].sName.length;
                 if (0 === sPrefixed.indexOf(EValuePrefixes.S_SYMBOLIC)) {
                   &#x2F;&#x2F; foo:null, or foo:null;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthOriginal +
                       oWeights.N_VARIABLE_DECLARATION;
                   &#x2F;&#x2F; null vs foo
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                       oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.
                               N_NULL_AND_BOOLEAN_LITERALS][sPrefixed] *
                       (nLengthOriginal - nLengthSubstitution);
                 } else {
                   &#x2F;&#x2F; foo:&#x27;fromCharCode&#x27;;
                   oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving -=
                       nLengthSubstitution + nLengthString +
                       oWeights.N_VARIABLE_DECLARATION;
                   &#x2F;&#x2F; .fromCharCode vs [foo]
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_IDENTIFIER_NAMES
                         ][sPrefixed] *
                         (nLengthOriginal - nLengthSubstitution -
                          oWeights.N_PROPERTY_ACCESSOR);
                   }
                   &#x2F;&#x2F; &#x27;fromCharCode&#x27; vs foo
                   if (oSourceElementsData.aCount[
                           EPrimaryExpressionCategories.N_STRING_LITERALS
                       ].hasOwnProperty(sPrefixed)) {
                     oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving +=
                         oSourceElementsData.aCount[
                             EPrimaryExpressionCategories.N_STRING_LITERALS
                         ][sPrefixed] *
                         (nLengthString - nLengthSubstitution);
                   }
                 }
                 if (oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving &gt;
                     0) {
                   oSolutionCandidate.nSavings +=
                       oSolutionCandidate.oPrimitiveValues[sPrefixed].nSaving;
                 } else {
                   oScope.cname = nIndex; &#x2F;&#x2F; Free the identifier name.
                 }
               },
               &#x2F;**
                * Adds a variable declaration to an existing variable statement.
                * @param {!Array} aVariableDeclaration A variable declaration
                *     with an initialiser.
                *&#x2F;
               cAddVariableDeclaration = function(aVariableDeclaration) {
                 (&#x2F;** @type {!Array} *&#x2F; oSourceElements[nFrom][1]).unshift(
                     aVariableDeclaration);
               };

           if (nFrom &gt; nTo) {
             return;
           }
           &#x2F;&#x2F; If the range is a closure, reuse the closure.
           if (nFrom === nTo &amp;&amp;
               &#x27;stat&#x27; === oSourceElements[nFrom][0] &amp;&amp;
               &#x27;call&#x27; === oSourceElements[nFrom][1][0] &amp;&amp;
               &#x27;function&#x27; === oSourceElements[nFrom][1][1][0]) {
             fExamineSyntacticCodeUnit(oSourceElements[nFrom][1][1]);
             return;
           }
           &#x2F;&#x2F; Create a list of all derived primitive values within the range.
           for (nPosition = nFrom; nPosition &lt;= nTo; nPosition += 1) {
             aSourceElementsData[nPosition].aPrimitiveValues.forEach(
                 cAugmentList(oSourceElementsData.aPrimitiveValues));
           }
           if (0 === oSourceElementsData.aPrimitiveValues.length) {
             return;
           }
           for (nPosition = nFrom; nPosition &lt;= nTo; nPosition += 1) {
             &#x2F;&#x2F; Add the number of occurrences to the total count.
             fAddOccurrences(nPosition);
             &#x2F;&#x2F; Add identifiers of this or any nested scope to the list.
             aSourceElementsData[nPosition].aIdentifiers.forEach(
                 cAugmentList(oSourceElementsData.aIdentifiers));
           }
           &#x2F;&#x2F; Distribute identifier names among derived primitive values.
           do {  &#x2F;&#x2F; If there was any progress, find a better distribution.
             oSolutionBest = oSolutionCandidate;
             if (Object.keys(oSolutionCandidate.oPrimitiveValues).length &gt; 0) {
               &#x2F;&#x2F; Sort primitive values descending by their worthwhileness.
               oSourceElementsData.aPrimitiveValues.sort(cSortPrimitiveValues);
             }
             oSolutionCandidate = new TSolution();
             oSourceElementsData.aPrimitiveValues.forEach(
                 fEvaluatePrimitiveValue);
             oScope.cname = nIndex;
           } while (oSolutionCandidate.nSavings &gt; oSolutionBest.nSavings);
           &#x2F;&#x2F; Take the necessity of adding a variable statement into account.
           if (&#x27;var&#x27; !== oSourceElements[nFrom][0]) {
             oSolutionBest.nSavings -= oWeights.N_VARIABLE_STATEMENT_AFFIXATION;
           }
           if (bEnclose) {
             &#x2F;&#x2F; Take the necessity of forming a closure into account.
             oSolutionBest.nSavings -= oWeights.N_CLOSURE;
           }
           if (oSolutionBest.nSavings &gt; 0) {
             &#x2F;&#x2F; Create variable declarations suitable for UglifyJS.
             Object.keys(oSolutionBest.oPrimitiveValues).forEach(
                 cAugmentVariableDeclarations);
             &#x2F;&#x2F; Rewrite expressions that contain worthwhile primitive values.
             for (nPosition = nFrom; nPosition &lt;= nTo; nPosition += 1) {
               oWalker = oProcessor.ast_walker();
               oSourceElements[nPosition] =
                   oWalker.with_walkers(
                       oWalkersTransformers,
                       cContext(oWalker, oSourceElements[nPosition]));
             }
             if (&#x27;var&#x27; === oSourceElements[nFrom][0]) {  &#x2F;&#x2F; Reuse the statement.
               (&#x2F;** @type {!Array.&lt;!Array&gt;} *&#x2F; aVariableDeclarations.reverse(
                   )).forEach(cAddVariableDeclaration);
             } else {  &#x2F;&#x2F; Add a variable statement.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   [&#x27;var&#x27;, aVariableDeclarations]);
               nTo += 1;
             }
             if (bEnclose) {
               &#x2F;&#x2F; Add a closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom,
                   0,
                   [&#x27;stat&#x27;, [&#x27;call&#x27;, [&#x27;function&#x27;, null, [], []], []]]);
               &#x2F;&#x2F; Copy source elements into the closure.
               for (nPosition = nTo + 1; nPosition &gt; nFrom; nPosition -= 1) {
                 Array.prototype.unshift.call(
                     oSourceElements[nFrom][1][1][3],
                     oSourceElements[nPosition]);
               }
               &#x2F;&#x2F; Remove source elements outside the closure.
               Array.prototype.splice.call(
                   oSourceElements,
                   nFrom + 1,
                   nTo - nFrom + 1);
             }
           }
           if (bEnclose) {
             &#x2F;&#x2F; Restore the availability of identifier names.
             oScope.cname = nIndex;
           }
         };

     oSourceElements = (&#x2F;** @type {!TSyntacticCodeUnit} *&#x2F;
         oSyntacticCodeUnit[bIsGlobal ? 1 : 3]);
     if (0 === oSourceElements.length) {
       return;
     }
     oScope = bIsGlobal ? oSyntacticCodeUnit.scope : oSourceElements.scope;
     &#x2F;&#x2F; Skip a Directive Prologue.
     while (nAfterDirectivePrologue &lt; oSourceElements.length &amp;&amp;
            &#x27;stat&#x27; === oSourceElements[nAfterDirectivePrologue][0] &amp;&amp;
            &#x27;string&#x27; === oSourceElements[nAfterDirectivePrologue][1][0]) {
       nAfterDirectivePrologue += 1;
       aSourceElementsData.push(null);
     }
     if (oSourceElements.length === nAfterDirectivePrologue) {
       return;
     }
     for (nPosition = nAfterDirectivePrologue;
          nPosition &lt; oSourceElements.length;
          nPosition += 1) {
       oSourceElementData = new TSourceElementsData();
       oWalker = oProcessor.ast_walker();
       &#x2F;&#x2F; Classify a source element.
       &#x2F;&#x2F; Find its derived primitive values and count their occurrences.
       &#x2F;&#x2F; Find all identifiers used (including nested scopes).
       oWalker.with_walkers(
           oWalkers.oSurveySourceElement,
           cContext(oWalker, oSourceElements[nPosition]));
       &#x2F;&#x2F; Establish whether the scope is still wholly examinable.
       bIsWhollyExaminable = bIsWhollyExaminable &amp;&amp;
           ESourceElementCategories.N_WITH !== oSourceElementData.nCategory &amp;&amp;
           ESourceElementCategories.N_EVAL !== oSourceElementData.nCategory;
       aSourceElementsData.push(oSourceElementData);
     }
     if (bIsWhollyExaminable) {  &#x2F;&#x2F; Examine the whole scope.
       fExamineSourceElements(
           nAfterDirectivePrologue,
           oSourceElements.length - 1,
           false);
     } else {  &#x2F;&#x2F; Examine unexcluded ranges of source elements.
       for (nPosition = oSourceElements.length - 1;
            nPosition &gt;= nAfterDirectivePrologue;
            nPosition -= 1) {
         oSourceElementData = (&#x2F;** @type {!TSourceElementsData} *&#x2F;
             aSourceElementsData[nPosition]);
         if (ESourceElementCategories.N_OTHER ===
             oSourceElementData.nCategory) {
           if (&#x27;undefined&#x27; === typeof nTo) {
             nTo = nPosition;  &#x2F;&#x2F; Indicate the end of a range.
           }
           &#x2F;&#x2F; Examine the range if it immediately follows a Directive Prologue.
           if (nPosition === nAfterDirectivePrologue) {
             fExamineSourceElements(nPosition, nTo, true);
           }
         } else {
           if (&#x27;undefined&#x27; !== typeof nTo) {
             &#x2F;&#x2F; Examine the range that immediately follows this source element.
             fExamineSourceElements(nPosition + 1, nTo, true);
             nTo = void 0;  &#x2F;&#x2F; Obliterate the range.
           }
           &#x2F;&#x2F; Examine nested functions.
           oWalker = oProcessor.ast_walker();
           oWalker.with_walkers(
               oWalkers.oExamineFunctions,
               cContext(oWalker, oSourceElements[nPosition]));
         }
       }
     }
   }(oAbstractSyntaxTree = oProcessor.ast_add_scope(oAbstractSyntaxTree)));
  return oAbstractSyntaxTree;
};
&#x2F;*jshint sub:false *&#x2F;


if (require.main === module) {
  (function() {
    &#x27;use strict&#x27;;
    &#x2F;*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true,
         latedef:true, newcap:true, noarge:true, noempty:true, nonew:true,
         onevar:true, plusplus:true, regexp:true, undef:true, strict:true,
         sub:false, trailing:true *&#x2F;

    var _,
        &#x2F;**
         * NodeJS module for unit testing.
         * @namespace
         * @type {!TAssert}
         * @see http:&#x2F;&#x2F;nodejs.org&#x2F;docs&#x2F;v0.6.10&#x2F;api&#x2F;all.html#assert
         *&#x2F;
        oAssert = (&#x2F;** @type {!TAssert} *&#x2F; require(&#x27;assert&#x27;)),
        &#x2F;**
         * The parser of ECMA-262 found in UglifyJS.
         * @namespace
         * @type {!TParser}
         *&#x2F;
        oParser = (&#x2F;** @type {!TParser} *&#x2F; require(&#x27;.&#x2F;parse-js&#x27;)),
        &#x2F;**
         * The processor of &lt;abbr title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;s
         * found in UglifyJS.
         * @namespace
         * @type {!TProcessor}
         *&#x2F;
        oProcessor = (&#x2F;** @type {!TProcessor} *&#x2F; require(&#x27;.&#x2F;process&#x27;)),
        &#x2F;**
         * An instance of an object that allows the traversal of an &lt;abbr
         * title=&quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;.
         * @type {!TWalker}
         *&#x2F;
        oWalker,
        &#x2F;**
         * A collection of functions for the removal of the scope information
         * during the traversal of an &lt;abbr title=&quot;abstract syntax tree&quot;
         * &gt;AST&lt;&#x2F;abbr&gt;.
         * @namespace
         * @type {!Object.&lt;string, function(...[*])&gt;}
         *&#x2F;
        oWalkersPurifiers = {
          &#x2F;**#nocode+*&#x2F;  &#x2F;&#x2F; JsDoc Toolkit 2.4.0 hides some of the keys.
          &#x2F;**
           * Deletes the scope information from the branch of the abstract
           * syntax tree representing the encountered function declaration.
           * @param {string} sIdentifier The identifier of the function.
           * @param {!Array.&lt;string&gt;} aFormalParameterList Formal parameters.
           * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
           *&#x2F;
          &#x27;defun&#x27;: function(
              sIdentifier,
              aFormalParameterList,
              oFunctionBody) {
            delete oFunctionBody.scope;
          },
          &#x2F;**
           * Deletes the scope information from the branch of the abstract
           * syntax tree representing the encountered function expression.
           * @param {?string} sIdentifier The optional identifier of the
           *     function.
           * @param {!Array.&lt;string&gt;} aFormalParameterList Formal parameters.
           * @param {!TSyntacticCodeUnit} oFunctionBody Function code.
           *&#x2F;
          &#x27;function&#x27;: function(
              sIdentifier,
              aFormalParameterList,
              oFunctionBody) {
            delete oFunctionBody.scope;
          }
          &#x2F;**#nocode-*&#x2F;  &#x2F;&#x2F; JsDoc Toolkit 2.4.0 hides some of the keys.
        },
        &#x2F;**
         * Initiates the traversal of a source element.
         * @param {!TWalker} oWalker An instance of an object that allows the
         *     traversal of an abstract syntax tree.
         * @param {!TSyntacticCodeUnit} oSourceElement A source element from
         *     which the traversal should commence.
         * @return {function(): !TSyntacticCodeUnit} A function that is able to
         *     initiate the traversal from a given source element.
         *&#x2F;
        cContext = function(oWalker, oSourceElement) {
          &#x2F;**
           * @return {!TSyntacticCodeUnit} A function that is able to
           *     initiate the traversal from a given source element.
           *&#x2F;
          var fLambda = function() {
            return oWalker.walk(oSourceElement);
          };

          return fLambda;
        },
        &#x2F;**
         * A record consisting of configuration for the code generation phase.
         * @type {!Object}
         *&#x2F;
        oCodeGenerationOptions = {
          beautify: true
        },
        &#x2F;**
         * Tests whether consolidation of an ECMAScript program yields expected
         * results.
         * @param {{
         *       sTitle: string,
         *       sInput: string,
         *       sOutput: string
         *     }} oUnitTest A record consisting of data about a unit test: its
         *     name, an ECMAScript program, and, if consolidation is to take
         *     place, the resulting ECMAScript program.
         *&#x2F;
        cAssert = function(oUnitTest) {
          var _,
              &#x2F;**
               * An array-like object representing the &lt;abbr title=
               * &quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt; obtained after consolidation.
               * @type {!TSyntacticCodeUnit}
               *&#x2F;
              oSyntacticCodeUnitActual =
                  exports.ast_consolidate(oParser.parse(oUnitTest.sInput)),
              &#x2F;**
               * An array-like object representing the expected &lt;abbr title=
               * &quot;abstract syntax tree&quot;&gt;AST&lt;&#x2F;abbr&gt;.
               * @type {!TSyntacticCodeUnit}
               *&#x2F;
              oSyntacticCodeUnitExpected = oParser.parse(
                  oUnitTest.hasOwnProperty(&#x27;sOutput&#x27;) ?
                  oUnitTest.sOutput : oUnitTest.sInput);

          delete oSyntacticCodeUnitActual.scope;
          oWalker = oProcessor.ast_walker();
          oWalker.with_walkers(
              oWalkersPurifiers,
              cContext(oWalker, oSyntacticCodeUnitActual));
          try {
            oAssert.deepEqual(
                oSyntacticCodeUnitActual,
                oSyntacticCodeUnitExpected);
          } catch (oException) {
            console.error(
                &#x27;########## A unit test has failed.\n&#x27; +
                oUnitTest.sTitle + &#x27;\n&#x27; +
                &#x27;#####  actual code  (&#x27; +
                oProcessor.gen_code(oSyntacticCodeUnitActual).length +
                &#x27; bytes)\n&#x27; +
                oProcessor.gen_code(
                    oSyntacticCodeUnitActual,
                    oCodeGenerationOptions) + &#x27;\n&#x27; +
                &#x27;##### expected code (&#x27; +
                oProcessor.gen_code(oSyntacticCodeUnitExpected).length +
                &#x27; bytes)\n&#x27; +
                oProcessor.gen_code(
                    oSyntacticCodeUnitExpected,
                    oCodeGenerationOptions));
          }
        };

    [
      &#x2F;&#x2F; 7.6.1 Reserved Words.
      {
        sTitle:
            &#x27;Omission of keywords while choosing an identifier name.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var a, b, c, d, e, f, g, h, i, j, k, l, m,&#x27; +
            &#x27;      n, o, p, q, r, s, t, u, v, w, x, y, z,&#x27; +
            &#x27;      A, B, C, D, E, F, G, H, I, J, K, L, M,&#x27; +
            &#x27;      N, O, P, Q, R, S, T, U, V, W, X, Y, Z,&#x27; +
            &#x27;      $, _,&#x27; +
            &#x27;      aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am,&#x27; +
            &#x27;      an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az,&#x27; +
            &#x27;      aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM,&#x27; +
            &#x27;      aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ,&#x27; +
            &#x27;      a$, a_,&#x27; +
            &#x27;      ba, bb, bc, bd, be, bf, bg, bh, bi, bj, bk, bl, bm,&#x27; +
            &#x27;      bn, bo, bp, bq, br, bs, bt, bu, bv, bw, bx, by, bz,&#x27; +
            &#x27;      bA, bB, bC, bD, bE, bF, bG, bH, bI, bJ, bK, bL, bM,&#x27; +
            &#x27;      bN, bO, bP, bQ, bR, bS, bT, bU, bV, bW, bX, bY, bZ,&#x27; +
            &#x27;      b$, b_,&#x27; +
            &#x27;      ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck, cl, cm,&#x27; +
            &#x27;      cn, co, cp, cq, cr, cs, ct, cu, cv, cw, cx, cy, cz,&#x27; +
            &#x27;      cA, cB, cC, cD, cE, cF, cG, cH, cI, cJ, cK, cL, cM,&#x27; +
            &#x27;      cN, cO, cP, cQ, cR, cS, cT, cU, cV, cW, cX, cY, cZ,&#x27; +
            &#x27;      c$, c_,&#x27; +
            &#x27;      da, db, dc, dd, de, df, dg, dh, di, dj, dk, dl, dm,&#x27; +
            &#x27;      dn, dq, dr, ds, dt, du, dv, dw, dx, dy, dz,&#x27; +
            &#x27;      dA, dB, dC, dD, dE, dF, dG, dH, dI, dJ, dK, dL, dM,&#x27; +
            &#x27;      dN, dO, dP, dQ, dR, dS, dT, dU, dV, dW, dX, dY, dZ,&#x27; +
            &#x27;      d$, d_;&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var dp =&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,&#x27; +
            &#x27;      a, b, c, d, e, f, g, h, i, j, k, l, m,&#x27; +
            &#x27;      n, o, p, q, r, s, t, u, v, w, x, y, z,&#x27; +
            &#x27;      A, B, C, D, E, F, G, H, I, J, K, L, M,&#x27; +
            &#x27;      N, O, P, Q, R, S, T, U, V, W, X, Y, Z,&#x27; +
            &#x27;      $, _,&#x27; +
            &#x27;      aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am,&#x27; +
            &#x27;      an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az,&#x27; +
            &#x27;      aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM,&#x27; +
            &#x27;      aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ,&#x27; +
            &#x27;      a$, a_,&#x27; +
            &#x27;      ba, bb, bc, bd, be, bf, bg, bh, bi, bj, bk, bl, bm,&#x27; +
            &#x27;      bn, bo, bp, bq, br, bs, bt, bu, bv, bw, bx, by, bz,&#x27; +
            &#x27;      bA, bB, bC, bD, bE, bF, bG, bH, bI, bJ, bK, bL, bM,&#x27; +
            &#x27;      bN, bO, bP, bQ, bR, bS, bT, bU, bV, bW, bX, bY, bZ,&#x27; +
            &#x27;      b$, b_,&#x27; +
            &#x27;      ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck, cl, cm,&#x27; +
            &#x27;      cn, co, cp, cq, cr, cs, ct, cu, cv, cw, cx, cy, cz,&#x27; +
            &#x27;      cA, cB, cC, cD, cE, cF, cG, cH, cI, cJ, cK, cL, cM,&#x27; +
            &#x27;      cN, cO, cP, cQ, cR, cS, cT, cU, cV, cW, cX, cY, cZ,&#x27; +
            &#x27;      c$, c_,&#x27; +
            &#x27;      da, db, dc, dd, de, df, dg, dh, di, dj, dk, dl, dm,&#x27; +
            &#x27;      dn, dq, dr, ds, dt, du, dv, dw, dx, dy, dz,&#x27; +
            &#x27;      dA, dB, dC, dD, dE, dF, dG, dH, dI, dJ, dK, dL, dM,&#x27; +
            &#x27;      dN, dO, dP, dQ, dR, dS, dT, dU, dV, dW, dX, dY, dZ,&#x27; +
            &#x27;      d$, d_;&#x27; +
            &#x27;  void [dp, dp];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 7.8.1 Null Literals.
      {
        sTitle:
            &#x27;Evaluation with regard to the null value.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [null, null, null];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [null, null];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = null, foo;&#x27; +
            &#x27;  void [a, a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [null, null];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 7.8.2 Boolean Literals.
      {
        sTitle:
            &#x27;Evaluation with regard to the false value.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [false, false, false];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [false, false];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = false, foo;&#x27; +
            &#x27;  void [a, a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [false, false];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Evaluation with regard to the true value.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [true, true, true];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [true, true];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = true, foo;&#x27; +
            &#x27;  void [a, a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [true, true];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 7.8.4 String Literals.
      {
        sTitle:
            &#x27;Evaluation with regard to the String value of a string literal.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&quot;abcd&quot;, &quot;abcd&quot;, &quot;abc&quot;, &quot;abc&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcd&quot;, foo;&#x27; +
            &#x27;  void [a, a, &quot;abc&quot;, &quot;abc&quot;];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 7.8.5 Regular Expression Literals.
      {
        sTitle:
            &#x27;Preservation of the pattern of a regular expression literal.&#x27;,
        sInput:
            &#x27;void [&#x2F;abcdefghijklmnopqrstuvwxyz&#x2F;, &#x2F;abcdefghijklmnopqrstuvwxyz&#x2F;];&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of the flags of a regular expression literal.&#x27;,
        sInput:
            &#x27;void [&#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim,&#x27; +
            &#x27;      &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim,&#x27; +
            &#x27;      &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim, &#x2F;(?:)&#x2F;gim];&#x27;
      },
      &#x2F;&#x2F; 10.2 Lexical Environments.
      {
        sTitle:
            &#x27;Preservation of identifier names in the same scope.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint shadow:true *&#x2F;&#x27; +
            &#x27;var a;&#x27; +
            &#x27;function b(i) {&#x27; +
            &#x27;}&#x27; +
            &#x27;for (var c; 0 === Math.random(););&#x27; +
            &#x27;for (var d in {});&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;void [b(a), b(c), b(d)];&#x27; +
            &#x27;void [typeof e];&#x27; +
            &#x27;i: for (; 0 === Math.random();) {&#x27; +
            &#x27;  if (42 === (new Date()).getMinutes()) {&#x27; +
            &#x27;    continue i;&#x27; +
            &#x27;  } else {&#x27; +
            &#x27;    break i;&#x27; +
            &#x27;  }&#x27; +
            &#x27;}&#x27; +
            &#x27;try {&#x27; +
            &#x27;} catch (f) {&#x27; +
            &#x27;} finally {&#x27; +
            &#x27;}&#x27; +
            &#x27;(function g(h) {&#x27; +
            &#x27;}());&#x27; +
            &#x27;void [{&#x27; +
            &#x27;  i: 42,&#x27; +
            &#x27;  &quot;j&quot;: 42,&#x27; +
            &#x27;  \&#x27;k\&#x27;: 42&#x27; +
            &#x27;}];&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint shadow:true *&#x2F;&#x27; +
            &#x27;var a;&#x27; +
            &#x27;function b(i) {&#x27; +
            &#x27;}&#x27; +
            &#x27;for (var c; 0 === Math.random(););&#x27; +
            &#x27;for (var d in {});&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var i = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [i];&#x27; +
            &#x27;  void [b(a), b(c), b(d)];&#x27; +
            &#x27;  void [typeof e];&#x27; +
            &#x27;  i: for (; 0 === Math.random();) {&#x27; +
            &#x27;    if (42 === (new Date()).getMinutes()) {&#x27; +
            &#x27;      continue i;&#x27; +
            &#x27;    } else {&#x27; +
            &#x27;      break i;&#x27; +
            &#x27;    }&#x27; +
            &#x27;  }&#x27; +
            &#x27;  try {&#x27; +
            &#x27;  } catch (f) {&#x27; +
            &#x27;  } finally {&#x27; +
            &#x27;  }&#x27; +
            &#x27;  (function g(h) {&#x27; +
            &#x27;  }());&#x27; +
            &#x27;  void [{&#x27; +
            &#x27;    i: 42,&#x27; +
            &#x27;    &quot;j&quot;: 42,&#x27; +
            &#x27;    \&#x27;k\&#x27;: 42&#x27; +
            &#x27;  }];&#x27; +
            &#x27;  void [i];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of identifier names in nested function code.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a;&#x27; +
            &#x27;    for (var b; 0 === Math.random(););&#x27; +
            &#x27;    for (var c in {});&#x27; +
            &#x27;    void [typeof d];&#x27; +
            &#x27;    h: for (; 0 === Math.random();) {&#x27; +
            &#x27;      if (42 === (new Date()).getMinutes()) {&#x27; +
            &#x27;        continue h;&#x27; +
            &#x27;      } else {&#x27; +
            &#x27;        break h;&#x27; +
            &#x27;      }&#x27; +
            &#x27;    }&#x27; +
            &#x27;    try {&#x27; +
            &#x27;    } catch (e) {&#x27; +
            &#x27;    } finally {&#x27; +
            &#x27;    }&#x27; +
            &#x27;    (function f(g) {&#x27; +
            &#x27;    }());&#x27; +
            &#x27;    void [{&#x27; +
            &#x27;      h: 42,&#x27; +
            &#x27;      &quot;i&quot;: 42,&#x27; +
            &#x27;      \&#x27;j\&#x27;: 42&#x27; +
            &#x27;    }];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var h = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [h];&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a;&#x27; +
            &#x27;    for (var b; 0 === Math.random(););&#x27; +
            &#x27;    for (var c in {});&#x27; +
            &#x27;    void [typeof d];&#x27; +
            &#x27;    h: for (; 0 === Math.random();) {&#x27; +
            &#x27;      if (42 === (new Date()).getMinutes()) {&#x27; +
            &#x27;        continue h;&#x27; +
            &#x27;      } else {&#x27; +
            &#x27;        break h;&#x27; +
            &#x27;      }&#x27; +
            &#x27;    }&#x27; +
            &#x27;    try {&#x27; +
            &#x27;    } catch (e) {&#x27; +
            &#x27;    } finally {&#x27; +
            &#x27;    }&#x27; +
            &#x27;    (function f(g) {&#x27; +
            &#x27;    }());&#x27; +
            &#x27;    void [{&#x27; +
            &#x27;      h: 42,&#x27; +
            &#x27;      &quot;i&quot;: 42,&#x27; +
            &#x27;      \&#x27;j\&#x27;: 42&#x27; +
            &#x27;    }];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;  void [h];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation of a closure with other source elements.&#x27;,
        sInput:
            &#x27;(function(foo) {&#x27; +
            &#x27;}(&quot;abcdefghijklmnopqrstuvwxyz&quot;));&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  (function(foo) {&#x27; +
            &#x27;  })(a);&#x27; +
            &#x27;  void [a];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation of function code instead of a sole closure.&#x27;,
        sInput:
            &#x27;(function(foo, bar) {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}(&quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;));&#x27;,
        sOutput:
            &#x27;(function(foo, bar) {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}(&quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;));&#x27;
      },
      &#x2F;&#x2F; 11.1.5 Object Initialiser.
      {
        sTitle:
            &#x27;Preservation of property names of an object initialiser.&#x27;,
        sInput:
            &#x27;var foo = {&#x27; +
            &#x27;  abcdefghijklmnopqrstuvwxyz: 42,&#x27; +
            &#x27;  &quot;zyxwvutsrqponmlkjihgfedcba&quot;: 42,&#x27; +
            &#x27;  \&#x27;mlkjihgfedcbanopqrstuvwxyz\&#x27;: 42&#x27; +
            &#x27;};&#x27; +
            &#x27;void [&#x27; +
            &#x27;  foo.abcdefghijklmnopqrstuvwxyz,&#x27; +
            &#x27;  &quot;zyxwvutsrqponmlkjihgfedcba&quot;,&#x27; +
            &#x27;  \&#x27;mlkjihgfedcbanopqrstuvwxyz\&#x27;&#x27; +
            &#x27;];&#x27;
      },
      {
        sTitle:
            &#x27;Evaluation with regard to String values derived from identifier &#x27; +
            &#x27;names used as property accessors.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&#x27; +
            &#x27;    Math.abcdefghij,&#x27; +
            &#x27;    Math.abcdefghij,&#x27; +
            &#x27;    Math.abcdefghi,&#x27; +
            &#x27;    Math.abcdefghi&#x27; +
            &#x27;  ];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghij&quot;, foo;&#x27; +
            &#x27;  void [&#x27; +
            &#x27;    Math[a],&#x27; +
            &#x27;    Math[a],&#x27; +
            &#x27;    Math.abcdefghi,&#x27; +
            &#x27;    Math.abcdefghi&#x27; +
            &#x27;  ];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 11.2.1 Property Accessors.
      {
        sTitle:
            &#x27;Preservation of identifiers in the nonterminal MemberExpression.&#x27;,
        sInput:
            &#x27;void [&#x27; +
            &#x27;  Math.E,&#x27; +
            &#x27;  Math.LN10,&#x27; +
            &#x27;  Math.LN2,&#x27; +
            &#x27;  Math.LOG2E,&#x27; +
            &#x27;  Math.LOG10E,&#x27; +
            &#x27;  Math.PI,&#x27; +
            &#x27;  Math.SQRT1_2,&#x27; +
            &#x27;  Math.SQRT2,&#x27; +
            &#x27;  Math.abs,&#x27; +
            &#x27;  Math.acos&#x27; +
            &#x27;];&#x27;
      },
      &#x2F;&#x2F; 12.2 Variable Statement.
      {
        sTitle:
            &#x27;Preservation of the identifier of a variable that is being &#x27; +
            &#x27;declared in a variable statement.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var abcdefghijklmnopqrstuvwxyz;&#x27; +
            &#x27;  void [abcdefghijklmnopqrstuvwxyz];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a variable statement in global code.&#x27;,
        sInput:
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;var foo = &quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;    bar = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a variable statement in function code that &#x27; +
            &#x27;contains a with statement.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  with ({});&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a variable statement in function code that &#x27; +
            &#x27;contains a direct call to the eval function.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;void [&#x27; +
            &#x27;  function() {&#x27; +
            &#x27;    eval(&quot;&quot;);&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;    var foo;&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  }&#x27; +
            &#x27;];&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a variable statement in global code.&#x27;,
        sInput:
            &#x27;var foo = function() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;};&#x27;,
        sOutput:
            &#x27;var foo = function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;};&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a variable statement excluded in function &#x27; +
            &#x27;code due to the presence of a with statement.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  with ({});&#x27; +
            &#x27;  var foo = function() {&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;          &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  with ({});&#x27; +
            &#x27;  var foo = function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a variable statement excluded in function &#x27; +
            &#x27;code due to the presence of a direct call to the eval function.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  var foo = function() {&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;          &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  var foo = function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Inclusion of a variable statement in function code that &#x27; +
            &#x27;contains no with statement and no direct call to the eval &#x27; +
            &#x27;function.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a];&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [a];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Ignorance with regard to a variable statement in global code.&#x27;,
        sInput:
            &#x27;var foo = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;,
        sOutput:
            &#x27;var foo = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 12.4 Expression Statement.
      {
        sTitle:
            &#x27;Preservation of identifiers in an expression statement.&#x27;,
        sInput:
            &#x27;void [typeof abcdefghijklmnopqrstuvwxyz,&#x27; +
            &#x27;      typeof abcdefghijklmnopqrstuvwxyz];&#x27;
      },
      &#x2F;&#x2F; 12.6.3 The {@code for} Statement.
      {
        sTitle:
            &#x27;Preservation of identifiers in the variable declaration list of &#x27; +
            &#x27;a for statement.&#x27;,
        sInput:
            &#x27;for (var abcdefghijklmnopqrstuvwxyz; 0 === Math.random(););&#x27; +
            &#x27;for (var abcdefghijklmnopqrstuvwxyz; 0 === Math.random(););&#x27;
      },
      &#x2F;&#x2F; 12.6.4 The {@code for-in} Statement.
      {
        sTitle:
            &#x27;Preservation of identifiers in the variable declaration list of &#x27; +
            &#x27;a for-in statement.&#x27;,
        sInput:
            &#x27;for (var abcdefghijklmnopqrstuvwxyz in {});&#x27; +
            &#x27;for (var abcdefghijklmnopqrstuvwxyz in {});&#x27;
      },
      &#x2F;&#x2F; 12.7 The {@code continue} Statement.
      {
        sTitle:
            &#x27;Preservation of the identifier in a continue statement.&#x27;,
        sInput:
            &#x27;abcdefghijklmnopqrstuvwxyz: for (; 0 === Math.random();) {&#x27; +
            &#x27;  continue abcdefghijklmnopqrstuvwxyz;&#x27; +
            &#x27;}&#x27; +
            &#x27;abcdefghijklmnopqrstuvwxyz: for (; 0 === Math.random();) {&#x27; +
            &#x27;  continue abcdefghijklmnopqrstuvwxyz;&#x27; +
            &#x27;}&#x27;
      },
      &#x2F;&#x2F; 12.8 The {@code break} Statement.
      {
        sTitle:
            &#x27;Preservation of the identifier in a break statement.&#x27;,
        sInput:
            &#x27;abcdefghijklmnopqrstuvwxyz: for (; 0 === Math.random();) {&#x27; +
            &#x27;  break abcdefghijklmnopqrstuvwxyz;&#x27; +
            &#x27;}&#x27; +
            &#x27;abcdefghijklmnopqrstuvwxyz: for (; 0 === Math.random();) {&#x27; +
            &#x27;  break abcdefghijklmnopqrstuvwxyz;&#x27; +
            &#x27;}&#x27;
      },
      &#x2F;&#x2F; 12.9 The {@code return} Statement.
      {
        sTitle:
            &#x27;Exclusion of a return statement in function code that contains &#x27; +
            &#x27;a with statement.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  with ({});&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  if (0 === Math.random()) {&#x27; +
            &#x27;    return;&#x27; +
            &#x27;  } else {&#x27; +
            &#x27;  }&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a return statement in function code that contains &#x27; +
            &#x27;a direct call to the eval function.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  if (0 === Math.random()) {&#x27; +
            &#x27;    return;&#x27; +
            &#x27;  } else {&#x27; +
            &#x27;  }&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a return statement excluded in function &#x27; +
            &#x27;code due to the presence of a with statement.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  with ({});&#x27; +
            &#x27;  return function() {&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;          &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  with ({});&#x27; +
            &#x27;  return function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a return statement excluded in function &#x27; +
            &#x27;code due to the presence of a direct call to the eval function.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  return function() {&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;          &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  return function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  };&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Inclusion of a return statement in function code that contains &#x27; +
            &#x27;no with statement and no direct call to the eval function.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  if (0 === Math.random()) {&#x27; +
            &#x27;    return;&#x27; +
            &#x27;  } else {&#x27; +
            &#x27;  }&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a];&#x27; +
            &#x27;  if (0 === Math.random()) {&#x27; +
            &#x27;    return;&#x27; +
            &#x27;  } else {&#x27; +
            &#x27;  }&#x27; +
            &#x27;  void [a];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 12.10 The {@code with} Statement.
      {
        sTitle:
            &#x27;Preservation of the statement in a with statement.&#x27;,
        sInput:
            &#x27;with ({}) {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a with statement in the same syntactic code unit.&#x27;,
        sInput:
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;with ({&#x27; +
            &#x27;  foo: &quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;  bar: &quot;abcdefghijklmnopqrstuvwxyz&quot;&#x27; +
            &#x27;}) {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a with statement in nested function code.&#x27;,
        sInput:
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  with ({&#x27; +
            &#x27;    foo: &quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;    bar: &quot;abcdefghijklmnopqrstuvwxyz&quot;&#x27; +
            &#x27;  }) {&#x27; +
            &#x27;    void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;          &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  }&#x27; +
            &#x27;}());&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;
      },
      &#x2F;&#x2F; 12.12 Labelled Statements.
      {
        sTitle:
            &#x27;Preservation of the label of a labelled statement.&#x27;,
        sInput:
            &#x27;abcdefghijklmnopqrstuvwxyz: for (; 0 === Math.random(););&#x27; +
            &#x27;abcdefghijklmnopqrstuvwxyz: for (; 0 === Math.random(););&#x27;
      },
      &#x2F;&#x2F; 12.14 The {@code try} Statement.
      {
        sTitle:
            &#x27;Preservation of the identifier in the catch clause of a try&#x27; +
            &#x27;statement.&#x27;,
        sInput:
            &#x27;try {&#x27; +
            &#x27;} catch (abcdefghijklmnopqrstuvwxyz) {&#x27; +
            &#x27;} finally {&#x27; +
            &#x27;}&#x27; +
            &#x27;try {&#x27; +
            &#x27;} catch (abcdefghijklmnopqrstuvwxyz) {&#x27; +
            &#x27;} finally {&#x27; +
            &#x27;}&#x27;
      },
      &#x2F;&#x2F; 13 Function Definition.
      {
        sTitle:
            &#x27;Preservation of the identifier of a function declaration.&#x27;,
        sInput:
            &#x27;function abcdefghijklmnopqrstuvwxyz() {&#x27; +
            &#x27;}&#x27; +
            &#x27;void [abcdefghijklmnopqrstuvwxyz];&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of the identifier of a function expression.&#x27;,
        sInput:
            &#x27;void [&#x27; +
            &#x27;  function abcdefghijklmnopqrstuvwxyz() {&#x27; +
            &#x27;  },&#x27; +
            &#x27;  function abcdefghijklmnopqrstuvwxyz() {&#x27; +
            &#x27;  }&#x27; +
            &#x27;];&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of a formal parameter of a function declaration.&#x27;,
        sInput:
            &#x27;function foo(abcdefghijklmnopqrstuvwxyz) {&#x27; +
            &#x27;}&#x27; +
            &#x27;function bar(abcdefghijklmnopqrstuvwxyz) {&#x27; +
            &#x27;}&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of a formal parameter in a function expression.&#x27;,
        sInput:
            &#x27;void [&#x27; +
            &#x27;  function(abcdefghijklmnopqrstuvwxyz) {&#x27; +
            &#x27;  },&#x27; +
            &#x27;  function(abcdefghijklmnopqrstuvwxyz) {&#x27; +
            &#x27;  }&#x27; +
            &#x27;];&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a function declaration.&#x27;,
        sInput:
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;function foo() {&#x27; +
            &#x27;}&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a function declaration.&#x27;,
        sInput:
            &#x27;function foo() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}&#x27;,
        sOutput:
            &#x27;function foo() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}&#x27;
      },
      &#x2F;&#x2F; 14 Program.
      {
        sTitle:
            &#x27;Preservation of a program without source elements.&#x27;,
        sInput:
            &#x27;&#x27;
      },
      &#x2F;&#x2F; 14.1 Directive Prologues and the Use Strict Directive.
      {
        sTitle:
            &#x27;Preservation of a Directive Prologue in global code.&#x27;,
        sInput:
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;\&#x27;zyxwvutsrqponmlkjihgfedcba\&#x27;;&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of a Directive Prologue in a function declaration.&#x27;,
        sInput:
            &#x27;function foo() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  \&#x27;zyxwvutsrqponmlkjihgfedcba\&#x27;;&#x27; +
            &#x27;}&#x27;
      },
      {
        sTitle:
            &#x27;Preservation of a Directive Prologue in a function expression.&#x27;,
        sInput:
            &#x27;void [&#x27; +
            &#x27;  function() {&#x27; +
            &#x27;    &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    \&#x27;zyxwvutsrqponmlkjihgfedcba\&#x27;;&#x27; +
            &#x27;  }&#x27; +
            &#x27;];&#x27;
      },
      {
        sTitle:
            &#x27;Ignorance with regard to a Directive Prologue in global code.&#x27;,
        sInput:
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;,
        sOutput:
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Ignorance with regard to a Directive Prologue in a function&#x27; +
            &#x27;declaration.&#x27;,
        sInput:
            &#x27;function foo() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}&#x27;,
        sOutput:
            &#x27;function foo() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}&#x27;
      },
      {
        sTitle:
            &#x27;Ignorance with regard to a Directive Prologue in a function&#x27; +
            &#x27;expression.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; 15.1 The Global Object.
      {
        sTitle:
            &#x27;Preservation of a property of the global object.&#x27;,
        sInput:
            &#x27;void [undefined, undefined, undefined, undefined, undefined];&#x27;
      },
      &#x2F;&#x2F; 15.1.2.1.1 Direct Call to Eval.
      {
        sTitle:
            &#x27;Exclusion of a direct call to the eval function in the same &#x27; +
            &#x27;syntactic code unit.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;
      },
      {
        sTitle:
            &#x27;Exclusion of a direct call to the eval function in nested &#x27; +
            &#x27;function code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;}());&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;
      },
      {
        sTitle:
            &#x27;Consolidation within a direct call to the eval function.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;eval(function() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;eval(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      &#x2F;&#x2F; Consolidation proper.
      {
        sTitle:
            &#x27;No consolidation if it does not result in a reduction of the &#x27; +
            &#x27;number of source characters.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&quot;ab&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abc&quot;];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Identification of a range of source elements at the beginning &#x27; +
            &#x27;of global code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;eval(&quot;&quot;);&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27;
      },
      {
        sTitle:
            &#x27;Identification of a range of source elements in the middle of &#x27; +
            &#x27;global code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;eval(&quot;&quot;);&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27;
      },
      {
        sTitle:
            &#x27;Identification of a range of source elements at the end of &#x27; +
            &#x27;global code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;&quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Identification of a range of source elements at the beginning &#x27; +
            &#x27;of function code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Identification of a range of source elements in the middle of &#x27; +
            &#x27;function code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Identification of a range of source elements at the end of &#x27; +
            &#x27;function code.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Evaluation with regard to String values of String literals and &#x27; +
            &#x27;String values derived from identifier names used as property&#x27; +
            &#x27;accessors.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&quot;abcdefg&quot;, Math.abcdefg, &quot;abcdef&quot;, Math.abcdef];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefg&quot;, foo;&#x27; +
            &#x27;  void [a, Math[a], &quot;abcdef&quot;, Math.abcdef];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Evaluation with regard to the necessity of adding a variable &#x27; +
            &#x27;statement.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefgh&quot;, &quot;abcdefgh&quot;];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefg&quot;, &quot;abcdefg&quot;];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var foo;&#x27; +
            &#x27;  void [&quot;abcd&quot;, &quot;abcd&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefgh&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefg&quot;, &quot;abcdefg&quot;];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcd&quot;, foo;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Evaluation with regard to the necessity of enclosing source &#x27; +
            &#x27;elements.&#x27;,
        sInput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxy&quot;, &quot;abcdefghijklmnopqrstuvwxy&quot;];&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwx&quot;, &quot;abcdefghijklmnopqrstuvwx&quot;];&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefgh&quot;, &quot;abcdefgh&quot;];&#x27; +
            &#x27;}());&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwxy&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwxy&quot;];&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwx&quot;,&#x27; +
            &#x27;        &quot;abcdefghijklmnopqrstuvwx&quot;];&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    void [&quot;abcdefgh&quot;, &quot;abcdefgh&quot;];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;&#x2F;*jshint evil:true *&#x2F;&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxy&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;void [&quot;abcdefghijklmnopqrstuvwx&quot;, &quot;abcdefghijklmnopqrstuvwx&quot;];&#x27; +
            &#x27;eval(&quot;&quot;);&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefgh&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27; +
            &#x27;(function() {&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a = &quot;abcdefghijklmnopqrstuvwxy&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  void [&quot;abcdefghijklmnopqrstuvwx&quot;, &quot;abcdefghijklmnopqrstuvwx&quot;];&#x27; +
            &#x27;  eval(&quot;&quot;);&#x27; +
            &#x27;  (function() {&#x27; +
            &#x27;    var a = &quot;abcdefgh&quot;;&#x27; +
            &#x27;    void [a, a];&#x27; +
            &#x27;  }());&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Employment of a closure while consolidating in global code.&#x27;,
        sInput:
            &#x27;void [&quot;abcdefghijklmnopqrstuvwxyz&quot;,&#x27; +
            &#x27;      &quot;abcdefghijklmnopqrstuvwxyz&quot;];&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#x27; +
            &#x27;  void [a, a];&#x27; +
            &#x27;}());&#x27;
      },
      {
        sTitle:
            &#x27;Assignment of a shorter identifier to a value whose &#x27; +
            &#x27;consolidation results in a greater reduction of the number of &#x27; +
            &#x27;source characters.&#x27;,
        sInput:
            &#x27;(function() {&#x27; +
            &#x27;  var b, c, d, e, f, g, h, i, j, k, l, m,&#x27; +
            &#x27;      n, o, p, q, r, s, t, u, v, w, x, y, z,&#x27; +
            &#x27;      A, B, C, D, E, F, G, H, I, J, K, L, M,&#x27; +
            &#x27;      N, O, P, Q, R, S, T, U, V, W, X, Y, Z,&#x27; +
            &#x27;      $, _;&#x27; +
            &#x27;  void [&quot;abcde&quot;, &quot;abcde&quot;, &quot;edcba&quot;, &quot;edcba&quot;, &quot;edcba&quot;];&#x27; +
            &#x27;}());&#x27;,
        sOutput:
            &#x27;(function() {&#x27; +
            &#x27;  var a = &quot;edcba&quot;,&#x27; +
            &#x27;      b, c, d, e, f, g, h, i, j, k, l, m,&#x27; +
            &#x27;      n, o, p, q, r, s, t, u, v, w, x, y, z,&#x27; +
            &#x27;      A, B, C, D, E, F, G, H, I, J, K, L, M,&#x27; +
            &#x27;      N, O, P, Q, R, S, T, U, V, W, X, Y, Z,&#x27; +
            &#x27;      $, _;&#x27; +
            &#x27;  void [&quot;abcde&quot;, &quot;abcde&quot;, a, a, a];&#x27; +
            &#x27;}());&#x27;
      }
    ].forEach(cAssert);
  }());
}

&#x2F;* Local Variables:      *&#x2F;
&#x2F;* mode: js              *&#x2F;
&#x2F;* coding: utf-8         *&#x2F;
&#x2F;* indent-tabs-mode: nil *&#x2F;
&#x2F;* tab-width: 2          *&#x2F;
&#x2F;* End:                  *&#x2F;
&#x2F;* vim: set ft=javascript fenc=utf-8 et ts=2 sts=2 sw=2: *&#x2F;
&#x2F;* :mode=javascript:noTabs=true:tabSize=2:indentSize=2:deepIndent=true: *&#x2F;


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
