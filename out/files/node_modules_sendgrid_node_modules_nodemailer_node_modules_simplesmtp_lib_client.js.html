<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;sendgrid&#x2F;node_modules&#x2F;nodemailer&#x2F;node_modules&#x2F;simplesmtp&#x2F;lib&#x2F;client.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Enables filtering in class lists..html">Enables filtering in class lists.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings..html">Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised date and time strings..html">Namespace container for the JsWorld library objects..Class for parsing localised date and time strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised number strings..html">Namespace container for the JsWorld library objects..Class for parsing localised number strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;.html">Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;sendgrid&#x2F;node_modules&#x2F;nodemailer&#x2F;node_modules&#x2F;simplesmtp&#x2F;lib&#x2F;client.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; TODO:
&#x2F;&#x2F; * Lisada timeout serveri Ã¼henduse jaoks

var Stream = require(&quot;stream&quot;).Stream,
    utillib = require(&quot;util&quot;),
    net = require(&quot;net&quot;),
    tls = require(&quot;tls&quot;),
    oslib = require(&quot;os&quot;),
    starttls = require(&quot;.&#x2F;starttls&quot;).starttls;

&#x2F;&#x2F; monkey patch net and tls to support nodejs 0.4
if(!net.connect &amp;&amp; net.createConnection){
    net.connect = net.createConnection;
}

if(!tls.connect &amp;&amp; tls.createConnection){
    tls.connect = tls.createConnection;
}

&#x2F;&#x2F; expose to the world
module.exports = function(port, host, options){
    var connection = new SMTPClient(port, host, options);
    process.nextTick(connection.connect.bind(connection));
    return connection;
};

&#x2F;**
 * &lt;p&gt;Generates a SMTP connection object&lt;&#x2F;p&gt;
 * 
 * &lt;p&gt;Optional options object takes the following possible properties:&lt;&#x2F;p&gt;
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;b&gt;secureConnection&lt;&#x2F;b&gt; - use SSL&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;name&lt;&#x2F;b&gt; - the name of the client server&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;auth&lt;&#x2F;b&gt; - authentication object &lt;code&gt;{user:&quot;...&quot;, pass:&quot;...&quot;}&lt;&#x2F;code&gt;
 *     &lt;li&gt;&lt;b&gt;ignoreTLS&lt;&#x2F;b&gt; - ignore server support for STARTTLS&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;debug&lt;&#x2F;b&gt; - output client and server messages to console&lt;&#x2F;li&gt;
 *     &lt;li&gt;&lt;b&gt;instanceId&lt;&#x2F;b&gt; - unique instance id for debugging&lt;&#x2F;li&gt;
 * &lt;&#x2F;ul&gt;
 * 
 * @constructor
 * @namespace SMTP Client module
 * @param {Number} [port=25] Port number to connect to
 * @param {String} [host=&quot;localhost&quot;] Hostname to connect to
 * @param {Object} [options] Option properties
 *&#x2F;
function SMTPClient(port, host, options){
    Stream.call(this);
    this.writable = true;
    this.readable = true;
    
    this.options = options || {};
    
    this.port = port || (this.options.secureConnection ? 465 : 25);
    this.host = host || &quot;localhost&quot;;
    
    this.options.secureConnection = !!this.options.secureConnection;
    this.options.auth = this.options.auth || false;
    this.options.maxConnections = this.options.maxConnections || 5;
    
    if(!this.options.name){
        &#x2F;&#x2F; defaul hostname is machine hostname or [IP]
        var defaultHostname = (oslib.hostname &amp;&amp; oslib.hostname()) ||
                              (oslib.getHostname &amp;&amp; oslib.getHostname()) ||
                              &quot;&quot;;
        if(defaultHostname.indexOf(&#x27;.&#x27;)&lt;0){
            defaultHostname = &quot;[127.0.0.1]&quot;;
        }
        if(defaultHostname.match(&#x2F;^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$&#x2F;)){
            defaultHostname = &quot;[&quot;+defaultHostname+&quot;]&quot;;
        }
        
        this.options.name = defaultHostname;
    }
    
    this._init();
}
utillib.inherits(SMTPClient, Stream);

&#x2F;**
 * &lt;p&gt;Initializes instance variables&lt;&#x2F;p&gt;
 *&#x2F;
SMTPClient.prototype._init = function(){
    &#x2F;**
     * Defines if the current connection is secure or not. If not, 
     * STARTTLS can be used if available
     * @private
     *&#x2F;
    this._secureMode = false;
    
    &#x2F;**
     * Ignore incoming data on TLS negotiation
     * @private
     *&#x2F;
    this._ignoreData = false;
    
    &#x2F;**
     * If set to true, then this object is no longer active
     * @private 
     *&#x2F;
    this.destroyed = false;
    
    &#x2F;**
     * The socket connecting to the server
     * @publick
     *&#x2F;
    this.socket = false;
    
    &#x2F;**
     * Lists supported auth mechanisms
     * @private
     *&#x2F;
    this._supportedAuth = [];
    
    &#x2F;**
     * Currently in data transfer state
     * @private
     *&#x2F;
    this._dataMode = false;
    
    &#x2F;**
     * Keep track if the client sends a leading \r\n in data mode 
     * @private
     *&#x2F;
    this._lastDataBytes = new Buffer(2);
    
    &#x2F;**
     * Function to run if a data chunk comes from the server
     * @private
     *&#x2F;
    this._currentAction = false;
    
    if(this.options.ignoreTLS || this.options.secureConnection){
        this._secureMode = true;
    }
};

&#x2F;**
 * &lt;p&gt;Creates a connection to a SMTP server and sets up connection
 * listener&lt;&#x2F;p&gt;
 *&#x2F;
SMTPClient.prototype.connect = function(){

    if(this.options.secureConnection){
        this.socket = tls.connect(this.port, this.host, {}, this._onConnect.bind(this));
    }else{
        this.socket = net.connect(this.port, this.host);
        this.socket.on(&quot;connect&quot;, this._onConnect.bind(this));
    }
    
    this.socket.on(&quot;error&quot;, this._onError.bind(this));
};

&#x2F;**
 * &lt;p&gt;Upgrades the connection to TLS&lt;&#x2F;p&gt;
 * 
 * @param {Function} callback Callbac function to run when the connection
 *        has been secured
 *&#x2F;
SMTPClient.prototype._upgradeConnection = function(callback){
    this._ignoreData = true;
    starttls(this.socket, (function(socket){
        this.socket = socket;
        this._ignoreData = false;
        this._secureMode = true;
        this.socket.on(&quot;data&quot;, this._onData.bind(this));
            
        return callback(null, true);
    }).bind(this));
};

&#x2F;**
 * &lt;p&gt;Connection listener that is run when the connection to 
 * the server is opened&lt;&#x2F;p&gt;
 * 
 * @event
 *&#x2F;
SMTPClient.prototype._onConnect = function(){
    if(&quot;setKeepAlive&quot; in this.socket){
        this.socket.setKeepAlive(true);
    }else if(this.socket.encrypted &amp;&amp; &quot;setKeepAlive&quot; in this.socket.encrypted){
        this.socket.encrypted.setKeepAlive(true); &#x2F;&#x2F; secure connection
    }
    
    this.socket.on(&quot;data&quot;, this._onData.bind(this));
    this.socket.on(&quot;close&quot;, this._onClose.bind(this));
    this.socket.on(&quot;end&quot;, this._onEnd.bind(this));
    
    this._currentAction = this._actionGreeting;
};

&#x2F;**
 * &lt;p&gt;Destroys the client - removes listeners etc.&lt;&#x2F;p&gt;
 *&#x2F;
SMTPClient.prototype._destroy = function(){
    if(this._destroyed)return;
    this._destroyed = true;
    this.emit(&quot;end&quot;);
    this.removeAllListeners();
};

&#x2F;**
 * &lt;p&gt;&#x27;data&#x27; listener for data coming from the server&lt;&#x2F;p&gt;
 * 
 * @event
 * @param {Buffer} chunk Data chunk coming from the server
 *&#x2F;
SMTPClient.prototype._onData = function(chunk){
    if(this._ignoreData){
        return;
    }
    
    var str = chunk.toString().trim();
    
    if(this.options.debug){
        console.log(&quot;SERVER&quot;+(this.options.instanceId?&quot; &quot;+
            this.options.instanceId:&quot;&quot;)+&quot;:\nâââ&quot;+str.replace(&#x2F;\n&#x2F;g,&quot;\n   &quot;));
    }
    
    if(typeof this._currentAction == &quot;function&quot;){
        this._currentAction.call(this, str);
    }
};

&#x2F;**
 * &lt;p&gt;&#x27;error&#x27; listener for the socket&lt;&#x2F;p&gt;
 * 
 * @event
 * @param {Error} err Error object
 * @param {String} type Error name
 *&#x2F;
SMTPClient.prototype._onError = function(err, type, data){
    if(type &amp;&amp; type != &quot;Error&quot;){
        err.name = type;
    }
    if(data){
        err.data = data;
    }
    this.emit(&quot;error&quot;, err);
    this.close();
};

&#x2F;**
 * &lt;p&gt;&#x27;close&#x27; listener for the socket&lt;&#x2F;p&gt;
 * 
 * @event
 *&#x2F;
SMTPClient.prototype._onClose = function(){
    this._destroy();
};

&#x2F;**
 * &lt;p&gt;&#x27;end&#x27; listener for the socket&lt;&#x2F;p&gt;
 * 
 * @event
 *&#x2F;
SMTPClient.prototype._onEnd = function(){
    this._destroy();
};

&#x2F;**
 * &lt;p&gt;Passes data stream to socket if in data mode&lt;&#x2F;p&gt;
 * 
 * @param {Buffer} chunk Chunk of data to be sent to the server
 *&#x2F;
SMTPClient.prototype.write = function(chunk){
    &#x2F;&#x2F; works only in data mode
    if(!this._dataMode){
        &#x2F;&#x2F; this line should never be reached but if it does, then
        &#x2F;&#x2F; say act like everything&#x27;s normal.
        return true;
    }
    
    if(typeof chunk == &quot;string&quot;){
        chunk = new Buffer(chunk, &quot;utf-8&quot;);
    }
    
    if(chunk.length &gt; 2){
        this._lastDataBytes[0] = chunk[chunk.length-2];
        this._lastDataBytes[1] = chunk[chunk.length-1];
    }else if(chunk.length == 1){
        this._lastDataBytes[0] = this._lastDataBytes[1];
        this._lastDataBytes[1] = chunk[0];
    }
    
    if(this.options.debug){
        console.log(&quot;CLIENT (DATA)&quot;+(this.options.instanceId?&quot; &quot;+
            this.options.instanceId:&quot;&quot;)+&quot;:\nâââ&quot;+chunk.toString().trim().replace(&#x2F;\n&#x2F;g,&quot;\n   &quot;));
    }
    
    &#x2F;&#x2F; pass the chunk to the socket
    return this.socket.write(chunk);
};

&#x2F;**
 * &lt;p&gt;Indicates that a data stream for the socket is ended. Works only
 * in data mode.&lt;&#x2F;p&gt;
 * 
 * @param {Buffer} [chunk] Chunk of data to be sent to the server
 *&#x2F;
SMTPClient.prototype.end = function(chunk){
    &#x2F;&#x2F; works only in data mode
    if(!this._dataMode){
        &#x2F;&#x2F; this line should never be reached but if it does, then
        &#x2F;&#x2F; say act like everything&#x27;s normal.
        return true;
    }
    
    if(chunk &amp;&amp; chunk.length){
        this.write(chunk);
    }

    &#x2F;&#x2F; redirect output from the server to _actionStream
    this._currentAction = this._actionStream;

    &#x2F;&#x2F; indicate that the stream has ended by sending a single dot on its own line
    &#x2F;&#x2F; if the client already closed the data with \r\n no need to do it again 
    if(this._lastDataBytes[0] == 0x0D &amp;&amp; this._lastDataBytes[1] == 0x0A){
        this.socket.write(new Buffer(&quot;.\r\n&quot;, &quot;utf-8&quot;));
    }else if(this._lastDataBytes[1] == 0x0D){
        this.socket.write(new Buffer(&quot;\n.\r\n&quot;));
    }else{
        this.socket.write(new Buffer(&quot;\r\n.\r\n&quot;));
    }
    
    &#x2F;&#x2F; end data mode    
    this._dataMode = false;
};

&#x2F;**
 * &lt;p&gt;Send a command to the server, append \r\n&lt;&#x2F;p&gt;
 * 
 * @param {String} str String to be sent to the server
 *&#x2F;
SMTPClient.prototype.sendCommand = function(str){
    if(this.options.debug){
        console.log(&quot;CLIENT&quot;+(this.options.instanceId?&quot; &quot;+
            this.options.instanceId:&quot;&quot;)+&quot;:\nâââ&quot;+(str || &quot;&quot;).toString().trim().replace(&#x2F;\n&#x2F;g,&quot;\n   &quot;));
    }
    this.socket.write(new Buffer(str+&quot;\r\n&quot;, &quot;utf-8&quot;));
};

&#x2F;**
 * &lt;p&gt;Sends QUIT&lt;&#x2F;p&gt;
 *&#x2F;
SMTPClient.prototype.quit = function(){
    this.sendCommand(&quot;QUIT&quot;);
    this._currentAction = this.close;
};

&#x2F;**
 * &lt;p&gt;Closes the connection to the server&lt;&#x2F;p&gt;
 *&#x2F;
SMTPClient.prototype.close = function(){
    if(this.options.debug){
        console.log(&quot;Closing connection to the server&quot;);
    }
    if(this.socket &amp;&amp; !this.socket.destroyed){
        this.socket.end();
    }
    this._destroy();
};

&#x2F;**
 * &lt;p&gt;Initiates a new message by submitting envelope data, starting with
 * &lt;code&gt;MAIL FROM:&lt;&#x2F;code&gt; command&lt;&#x2F;p&gt;
 * 
 * @param {Object} envelope Envelope object in the form of 
 *        &lt;code&gt;{from:&quot;...&quot;, to:[&quot;...&quot;]}&lt;&#x2F;code&gt;
 *&#x2F;
SMTPClient.prototype.useEnvelope = function(envelope){
    this._envelope = envelope || {};
    this._envelope.from = this._envelope.from || (&quot;anonymous@&quot;+this.options.name);
    
    &#x2F;&#x2F; clone the recipients array for latter manipulation
    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
    this._envelope.rcptFailed = [];
    
    this._currentAction = this._actionMAIL;
    this.sendCommand(&quot;MAIL FROM:&lt;&quot;+(this._envelope.from)+&quot;&gt;&quot;);
};

&#x2F;**
 * &lt;p&gt;If needed starts the authentication, if not emits &#x27;idle&#x27; to
 * indicate that this client is ready to take in an outgoing mail&lt;&#x2F;p&gt;
 *&#x2F;
SMTPClient.prototype._authenticateUser = function(){
    
    if(!this.options.auth){
        &#x2F;&#x2F; no need to authenticate, at least no data given
        this._currentAction = this._actionIdle;
        this.emit(&quot;idle&quot;); &#x2F;&#x2F; ready to take orders
        return;
    }
    
    var auth;
    
    if(this.options.auth.XOAuthToken &amp;&amp; this._supportedAuth.indexOf(&quot;XOAUTH&quot;)&gt;=0){
        auth = &quot;XOAUTH&quot;;
    }else if(this.options.authMethod) {
        auth = this.options.authMethod.toUpperCase().trim();
    }else{
        &#x2F;&#x2F; use first supported
        auth = (this._supportedAuth[0] || &quot;PLAIN&quot;).toUpperCase().trim();
    }
    
    switch(auth){
        case &quot;XOAUTH&quot;:
            this._currentAction = this._actionAUTHComplete;
            
            if(typeof this.options.auth.XOAuthToken == &quot;object&quot; &amp;&amp;
              typeof this.options.auth.XOAuthToken.generate == &quot;function&quot;){
                this.options.auth.XOAuthToken.generate((function(err, XOAuthToken){
                    if(err){
                        return this._onError(err, &quot;XOAuthTokenError&quot;);
                    }
                    this.sendCommand(&quot;AUTH XOAUTH &quot; + XOAuthToken);
                }).bind(this));
            }else{
                this.sendCommand(&quot;AUTH XOAUTH &quot; + this.options.auth.XOAuthToken.toString());
            }
            return;
        case &quot;LOGIN&quot;:
            this._currentAction = this._actionAUTH_LOGIN_USER;
            this.sendCommand(&quot;AUTH LOGIN&quot;);
            return;
        case &quot;PLAIN&quot;:
            this._currentAction = this._actionAUTHComplete;
            this.sendCommand(&quot;AUTH PLAIN &quot;+new Buffer(
                    this.options.auth.user+&quot;\u0000&quot;+
                    this.options.auth.user+&quot;\u0000&quot;+
                    this.options.auth.pass,&quot;utf-8&quot;).toString(&quot;base64&quot;));
            return;
    }
    
    this._onError(new Error(&quot;Unknown authentication method - &quot;+auth), &quot;UnknowAuthError&quot;);
};

&#x2F;** ACTIONS **&#x2F;

&#x2F;**
 * &lt;p&gt;Will be run after the connection is created and the server sends
 * a greeting. If the incoming message starts with 220 initiate
 * SMTP session by sending EHLO command&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionGreeting = function(str){
    if(str.substr(0,3) != &quot;220&quot;){
        this._onError(new Error(&quot;Invalid greeting from server - &quot;+str), false, str);
        return;
    }
    
    this._currentAction = this._actionEHLO;
    this.sendCommand(&quot;EHLO &quot;+this.options.name);
};

&#x2F;**
 * &lt;p&gt;Handles server response for EHLO command. If it yielded in
 * error, try HELO instead, otherwise initiate TLS negotiation
 * if STARTTLS is supported by the server or move into the
 * authentication phase.&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionEHLO = function(str){
    if(str.charAt(0) != &quot;2&quot;){
        &#x2F;&#x2F; Try HELO instead
        this._currentAction = this._actionHELO;
        this.sendCommand(&quot;HELO &quot;+this.options.name);
        return;
    }
    
    &#x2F;&#x2F; Detect if the server supports STARTTLS
    if(!this._secureMode &amp;&amp; str.match(&#x2F;[ \-]STARTTLS\r?$&#x2F;mi)){
        this.sendCommand(&quot;STARTTLS&quot;);
        this._currentAction = this._actionSTARTTLS;
        return; 
    }
    
    &#x2F;&#x2F; Detect if the server supports PLAIN auth
    if(str.match(&#x2F;AUTH(?:\s+[^\n]*\s+|\s+)PLAIN&#x2F;i)){
        this._supportedAuth.push(&quot;PLAIN&quot;);
    }
    
    &#x2F;&#x2F; Detect if the server supports LOGIN auth
    if(str.match(&#x2F;AUTH(?:\s+[^\n]*\s+|\s+)LOGIN&#x2F;i)){
        this._supportedAuth.push(&quot;LOGIN&quot;);
    }
    
    &#x2F;&#x2F; Detect if the server supports LOGIN auth
    if(str.match(&#x2F;AUTH(?:\s+[^\n]*\s+|\s+)XOAUTH&#x2F;i)){
        this._supportedAuth.push(&quot;XOAUTH&quot;);
    }
    
    this._authenticateUser.call(this);
};

&#x2F;**
 * &lt;p&gt;Handles server response for HELO command. If it yielded in
 * error, emit &#x27;error&#x27;, otherwise move into the authentication phase.&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionHELO = function(str){
    if(str.charAt(0) != &quot;2&quot;){
        this._onError(new Error(&quot;Invalid response for EHLO&#x2F;HELO - &quot;+str), false, str);
        return;
    }
    this._authenticateUser.call(this);
};

&#x2F;**
 * &lt;p&gt;Handles server response for STARTTLS command. If there&#x27;s an error
 * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
 * succeedes restart the EHLO&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionSTARTTLS = function(str){
    if(str.charAt(0) != &quot;2&quot;){
        &#x2F;&#x2F; Try HELO instead
        this._currentAction = this._actionHELO;
        this.sendCommand(&quot;HELO &quot;+this.options.name);
        return;
    }
    
    this._upgradeConnection((function(err, secured){
        if(err){
            this._onError(new Error(&quot;Error initiating TLS - &quot;+(err.message || err)), &quot;TLSError&quot;);
            return;
        }
        if(this.options.debug){
            console.log(&quot;Connection secured&quot;);
        }
        
        if(secured){
            &#x2F;&#x2F; restart session
            this._currentAction = this._actionEHLO;
            this.sendCommand(&quot;EHLO &quot;+this.options.name);
        }else{
            this._authenticateUser.call(this);
        }
    }).bind(this));
};

&#x2F;**
 * &lt;p&gt;Handle the response for AUTH LOGIN command. We are expecting
 * &#x27;334 VXNlcm5hbWU6&#x27; (base64 for &#x27;Username:&#x27;). Data to be sent as
 * response needs to be base64 encoded username.&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionAUTH_LOGIN_USER = function(str){
    if(str != &quot;334 VXNlcm5hbWU6&quot;){
        this._onError(new Error(&quot;Invalid login sequence while waiting for &#x27;334 VXNlcm5hbWU6&#x27; - &quot;+str), false, str);
        return;
    }
    this._currentAction = this._actionAUTH_LOGIN_PASS;
    this.sendCommand(new Buffer(
            this.options.auth.user, &quot;utf-8&quot;).toString(&quot;base64&quot;));
};

&#x2F;**
 * &lt;p&gt;Handle the response for AUTH LOGIN command. We are expecting
 * &#x27;334 UGFzc3dvcmQ6&#x27; (base64 for &#x27;Password:&#x27;). Data to be sent as
 * response needs to be base64 encoded password.&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionAUTH_LOGIN_PASS = function(str){
    if(str != &quot;334 UGFzc3dvcmQ6&quot;){
        this._onError(new Error(&quot;Invalid login sequence while waiting for &#x27;334 UGFzc3dvcmQ6&#x27; - &quot;+str), false, str);
        return;
    }
    this._currentAction = this._actionAUTHComplete;
    this.sendCommand(new Buffer(this.options.auth.pass, &quot;utf-8&quot;).toString(&quot;base64&quot;));
};

&#x2F;**
 * &lt;p&gt;Handles the response for authentication, if there&#x27;s no error,
 * the user can be considered logged in. Emit &#x27;idle&#x27; and start
 * waiting for a message to send&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionAUTHComplete = function(str){
    if(str.charAt(0) != &quot;2&quot;){
        this._onError(new Error(&quot;Invalid login - &quot;+str), &quot;AuthError&quot;, str);
        return;
    }
    
    this._currentAction = this._actionIdle;
    this.emit(&quot;idle&quot;); &#x2F;&#x2F; ready to take orders
};

&#x2F;**
 * &lt;p&gt;This function is not expected to run. If it does then there&#x27;s probably
 * an error (timeout etc.)&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionIdle = function(str){
    if(Number(str.charAt(0)) &gt; 3){
        this._onError(new Error(str), false, str);
        return;
    }
    
    &#x2F;&#x2F; this line should never get called
};

&#x2F;**
 * &lt;p&gt;Handle response for a &lt;code&gt;MAIL FROM:&lt;&#x2F;code&gt; command&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionMAIL = function(str){
    if(Number(str.charAt(0)) != &quot;2&quot;){
        this._onError(new Error(&quot;Mail from command failed - &quot; + str), &quot;SenderError&quot;, str);
        return;
    }
    
    if(!this._envelope.rcptQueue.length){
        this._onError(new Error(&quot;Can&#x27;t send mail - no recipients defined&quot;), &quot;RecipientError&quot;);
    }else{
        this._envelope.curRecipient = this._envelope.rcptQueue.shift();
        this._currentAction = this._actionRCPT;
        this.sendCommand(&quot;RCPT TO:&lt;&quot;+this._envelope.curRecipient+&quot;&gt;&quot;);
    }
};

&#x2F;**
 * &lt;p&gt;Handle response for a &lt;code&gt;RCPT TO:&lt;&#x2F;code&gt; command&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionRCPT = function(str){
    if(Number(str.charAt(0)) != &quot;2&quot;){
        &#x2F;&#x2F; this is a soft error
        this._envelope.rcptFailed.push(this._envelope.curRecipient);
    }
    
    if(!this._envelope.rcptQueue.length){
        if(this._envelope.rcptFailed.length &lt; this._envelope.to.length){
            this.emit(&quot;rcptFailed&quot;, this._envelope.rcptFailed);
            this._currentAction = this._actionDATA;
            this.sendCommand(&quot;DATA&quot;);
        }else{
            this._onError(new Error(&quot;Can&#x27;t send mail - all recipients were rejected&quot;), &quot;RecipientError&quot;);
            return;
        }
    }else{
        this._envelope.curRecipient = this._envelope.rcptQueue.shift();
        this._currentAction = this._actionRCPT;
        this.sendCommand(&quot;RCPT TO:&lt;&quot;+this._envelope.curRecipient+&quot;&gt;&quot;);
    }
};

&#x2F;**
 * &lt;p&gt;Handle response for a &lt;code&gt;DATA&lt;&#x2F;code&gt; command&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionDATA = function(str){
    &#x2F;&#x2F; response should be 354 but according to this issue https:&#x2F;&#x2F;github.com&#x2F;eleith&#x2F;emailjs&#x2F;issues&#x2F;24
    &#x2F;&#x2F; some servers might use 250 instead, so lets check for 2 or 3 as the first digit
    if([2,3].indexOf(Number(str.charAt(0)))&lt;0){
        this._onError(new Error(&quot;Data command failed - &quot; + str), false, str);
        return;
    }
    
    &#x2F;&#x2F; Emit that connection is set up for streaming
    this._dataMode = true;
    this._currentAction = this._actionIdle;
    this.emit(&quot;message&quot;);
};

&#x2F;**
 * &lt;p&gt;Handle response for a &lt;code&gt;DATA&lt;&#x2F;code&gt; stream&lt;&#x2F;p&gt;
 * 
 * @param {String} str Message from the server
 *&#x2F;
SMTPClient.prototype._actionStream = function(str){
    if(Number(str.charAt(0)) != &quot;2&quot;){
        &#x2F;&#x2F; Message failed
        this.emit(&quot;ready&quot;, false, str);
    }else{
        &#x2F;&#x2F; Message sent succesfully
        this.emit(&quot;ready&quot;, true, str);
    }
    
    &#x2F;&#x2F; Waiting for new connections
    this._currentAction = this._actionIdle;
    process.nextTick(this.emit.bind(this, &quot;idle&quot;));
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
