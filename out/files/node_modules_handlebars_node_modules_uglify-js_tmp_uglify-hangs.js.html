<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;handlebars&#x2F;node_modules&#x2F;uglify-js&#x2F;tmp&#x2F;uglify-hangs.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Enables filtering in class lists..html">Enables filtering in class lists.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings..html">Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised date and time strings..html">Namespace container for the JsWorld library objects..Class for parsing localised date and time strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised number strings..html">Namespace container for the JsWorld library objects..Class for parsing localised number strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;.html">Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;handlebars&#x2F;node_modules&#x2F;uglify-js&#x2F;tmp&#x2F;uglify-hangs.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;** 
 * @fileoverview 
 *
 * JsWorld
 *
 * &lt;p&gt;Javascript library for localised formatting and parsing of:
 *    &lt;ul&gt;
 *        &lt;li&gt;Numbers
 *        &lt;li&gt;Dates and times
 *        &lt;li&gt;Currency
 *    &lt;&#x2F;ul&gt;
 *
 * &lt;p&gt;The library classes are configured with standard POSIX locale definitions
 * derived from Unicode&#x27;s Common Locale Data Repository (CLDR).
 *
 * &lt;p&gt;Website: &lt;a href=&quot;http:&#x2F;&#x2F;software.dzhuvinov.com&#x2F;jsworld.html&quot;&gt;JsWorld&lt;&#x2F;a&gt;
 *
 * @author Vladimir Dzhuvinov
 * @version 2.5 (2011-12-23)
 *&#x2F;



&#x2F;** 
 * @namespace Namespace container for the JsWorld library objects.
 *&#x2F;
jsworld = {};


&#x2F;** 
 * @function
 * 
 * @description Formats a JavaScript Date object as an ISO-8601 date&#x2F;time 
 * string.
 *
 * @param {Date} [d] A valid JavaScript Date object. If undefined the 
 *        current date&#x2F;time will be used.
 * @param {Boolean} [withTZ] Include timezone offset, default false.
 *
 * @returns {String} The date&#x2F;time formatted as YYYY-MM-DD HH:MM:SS.
 *&#x2F;
jsworld.formatIsoDateTime = function(d, withTZ) {

	if (typeof d === &quot;undefined&quot;)
		d = new Date(); &#x2F;&#x2F; now
	
	if (typeof withTZ === &quot;undefined&quot;)
		withTZ = false;
	
	var s = jsworld.formatIsoDate(d) + &quot; &quot; + jsworld.formatIsoTime(d);
	
	if (withTZ) {
	
		var diff = d.getHours() - d.getUTCHours();
		var hourDiff = Math.abs(diff);
		
		var minuteUTC = d.getUTCMinutes();
		var minute = d.getMinutes();
		
		if (minute != minuteUTC &amp;&amp; minuteUTC &lt; 30 &amp;&amp; diff &lt; 0)
			hourDiff--;
			
		if (minute != minuteUTC &amp;&amp; minuteUTC &gt; 30 &amp;&amp; diff &gt; 0)
			hourDiff--;
		
		var minuteDiff;
		if (minute != minuteUTC)
			minuteDiff = &quot;:30&quot;;
		else
			minuteDiff = &quot;:00&quot;;
		
		var timezone;
		if (hourDiff &lt; 10)
			timezone = &quot;0&quot; + hourDiff + minuteDiff;
		
		else
			timezone = &quot;&quot; + hourDiff + minuteDiff;

		if (diff &lt; 0)
			timezone = &quot;-&quot; + timezone;
		
		else
			timezone = &quot;+&quot; + timezone;
		
		s = s + timezone;
	}
	
	return s;
};


&#x2F;** 
 * @function
 * 
 * @description Formats a JavaScript Date object as an ISO-8601 date string.
 *
 * @param {Date} [d] A valid JavaScript Date object. If undefined the current 
 *        date will be used.
 *
 * @returns {String} The date formatted as YYYY-MM-DD.
 *&#x2F;
jsworld.formatIsoDate = function(d) {

	if (typeof d === &quot;undefined&quot;)
		d = new Date(); &#x2F;&#x2F; now
	
	var year = d.getFullYear();
	var month = d.getMonth() + 1;
	var day = d.getDate();
	
	return year + &quot;-&quot; + jsworld._zeroPad(month, 2) + &quot;-&quot; + jsworld._zeroPad(day, 2);
};


&#x2F;** 
 * @function
 * 
 * @description Formats a JavaScript Date object as an ISO-8601 time string.
 *
 * @param {Date} [d] A valid JavaScript Date object. If undefined the current 
 *        time will be used.
 *
 * @returns {String} The time formatted as HH:MM:SS.
 *&#x2F;
jsworld.formatIsoTime = function(d) {

	if (typeof d === &quot;undefined&quot;)
		d = new Date(); &#x2F;&#x2F; now
	
	var hour = d.getHours();
	var minute = d.getMinutes();
	var second = d.getSeconds();
	
	return jsworld._zeroPad(hour, 2) + &quot;:&quot; + jsworld._zeroPad(minute, 2) + &quot;:&quot; + jsworld._zeroPad(second, 2);
};


&#x2F;** 
 * @function
 * 
 * @description Parses an ISO-8601 formatted date&#x2F;time string to a JavaScript 
 * Date object.
 *
 * @param {String} isoDateTimeVal An ISO-8601 formatted date&#x2F;time string.
 *
 * &lt;p&gt;Accepted formats:
 *
 * &lt;ul&gt;
 *     &lt;li&gt;YYYY-MM-DD HH:MM:SS
 *     &lt;li&gt;YYYYMMDD HHMMSS
 *     &lt;li&gt;YYYY-MM-DD HHMMSS
 *     &lt;li&gt;YYYYMMDD HH:MM:SS
 * &lt;&#x2F;ul&gt;
 *
 * @returns {Date} The corresponding Date object.
 *
 * @throws Error on a badly formatted date&#x2F;time string or on a invalid date.
 *&#x2F;
jsworld.parseIsoDateTime = function(isoDateTimeVal) {

	if (typeof isoDateTimeVal != &quot;string&quot;)
		throw &quot;Error: The parameter must be a string&quot;;

	&#x2F;&#x2F; First, try to match &quot;YYYY-MM-DD HH:MM:SS&quot; format
	var matches = isoDateTimeVal.match(&#x2F;^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)&#x2F;);
	
	&#x2F;&#x2F; If unsuccessful, try to match &quot;YYYYMMDD HHMMSS&quot; format
	if (matches === null)
		matches = isoDateTimeVal.match(&#x2F;^(\d\d\d\d)(\d\d)(\d\d)[T ](\d\d)(\d\d)(\d\d)&#x2F;);
		
	&#x2F;&#x2F; ... try to match &quot;YYYY-MM-DD HHMMSS&quot; format
	if (matches === null)
		matches = isoDateTimeVal.match(&#x2F;^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d)(\d\d)(\d\d)&#x2F;);
	
	&#x2F;&#x2F; ... try to match &quot;YYYYMMDD HH:MM:SS&quot; format
	if (matches === null)
		matches = isoDateTimeVal.match(&#x2F;^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)&#x2F;);

	&#x2F;&#x2F; Report bad date&#x2F;time string
	if (matches === null)
		throw &quot;Error: Invalid ISO-8601 date&#x2F;time string&quot;;

	&#x2F;&#x2F; Force base 10 parse int as some values may have leading zeros!
	&#x2F;&#x2F; (to avoid implicit octal base conversion)
	var year = parseInt(matches[1], 10);
	var month = parseInt(matches[2], 10);
	var day = parseInt(matches[3], 10);
	
	var hour = parseInt(matches[4], 10);
	var mins = parseInt(matches[5], 10);
	var secs = parseInt(matches[6], 10);
	
	&#x2F;&#x2F; Simple value range check, leap years not checked
	&#x2F;&#x2F; Note: the originial ISO time spec for leap hours (24:00:00) and seconds (00:00:60) is not supported
	if (month &lt; 1 || month &gt; 12 ||
	    day   &lt; 1 || day   &gt; 31 ||
	    hour  &lt; 0 || hour  &gt; 23 ||
	    mins  &lt; 0 || mins  &gt; 59 ||
	    secs  &lt; 0 || secs  &gt; 59    )
	    
		throw &quot;Error: Invalid ISO-8601 date&#x2F;time value&quot;;

	var d = new Date(year, month - 1, day, hour, mins, secs);
	
	&#x2F;&#x2F; Check if the input date was valid 
	&#x2F;&#x2F; (JS Date does automatic forward correction)
	if (d.getDate() != day || d.getMonth() +1 != month)
		throw &quot;Error: Invalid date&quot;;
	
	return d;
};


&#x2F;** 
 * @function
 * 
 * @description Parses an ISO-8601 formatted date string to a JavaScript 
 * Date object.
 *
 * @param {String} isoDateVal An ISO-8601 formatted date string.
 *
 * &lt;p&gt;Accepted formats:
 *
 * &lt;ul&gt;
 *     &lt;li&gt;YYYY-MM-DD
 *     &lt;li&gt;YYYYMMDD
 * &lt;&#x2F;ul&gt;
 *
 * @returns {Date} The corresponding Date object.
 *
 * @throws Error on a badly formatted date string or on a invalid date.
 *&#x2F;
jsworld.parseIsoDate = function(isoDateVal) {

	if (typeof isoDateVal != &quot;string&quot;)
		throw &quot;Error: The parameter must be a string&quot;;

	&#x2F;&#x2F; First, try to match &quot;YYYY-MM-DD&quot; format
	var matches = isoDateVal.match(&#x2F;^(\d\d\d\d)-(\d\d)-(\d\d)&#x2F;);
	
	&#x2F;&#x2F; If unsuccessful, try to match &quot;YYYYMMDD&quot; format
	if (matches === null)
		matches = isoDateVal.match(&#x2F;^(\d\d\d\d)(\d\d)(\d\d)&#x2F;);

	&#x2F;&#x2F; Report bad date&#x2F;time string
	if (matches === null)
		throw &quot;Error: Invalid ISO-8601 date string&quot;;

	&#x2F;&#x2F; Force base 10 parse int as some values may have leading zeros!
	&#x2F;&#x2F; (to avoid implicit octal base conversion)
	var year = parseInt(matches[1], 10);
	var month = parseInt(matches[2], 10);
	var day = parseInt(matches[3], 10);
	
	&#x2F;&#x2F; Simple value range check, leap years not checked
	if (month &lt; 1 || month &gt; 12 ||
	    day   &lt; 1 || day   &gt; 31    )
	    
		throw &quot;Error: Invalid ISO-8601 date value&quot;;

	var d = new Date(year, month - 1, day);
	
	&#x2F;&#x2F; Check if the input date was valid 
	&#x2F;&#x2F; (JS Date does automatic forward correction)
	if (d.getDate() != day || d.getMonth() +1 != month)
		throw &quot;Error: Invalid date&quot;;
	
	return d;
};


&#x2F;** 
 * @function
 * 
 * @description Parses an ISO-8601 formatted time string to a JavaScript 
 * Date object.
 *
 * @param {String} isoTimeVal An ISO-8601 formatted time string.
 *
 * &lt;p&gt;Accepted formats:
 *
 * &lt;ul&gt;
 *     &lt;li&gt;HH:MM:SS
 *     &lt;li&gt;HHMMSS
 * &lt;&#x2F;ul&gt;
 *
 * @returns {Date} The corresponding Date object, with year, month and day set
 *          to zero.
 *
 * @throws Error on a badly formatted time string.
 *&#x2F;
jsworld.parseIsoTime = function(isoTimeVal) {

	if (typeof isoTimeVal != &quot;string&quot;)
		throw &quot;Error: The parameter must be a string&quot;;

	&#x2F;&#x2F; First, try to match &quot;HH:MM:SS&quot; format
	var matches = isoTimeVal.match(&#x2F;^(\d\d):(\d\d):(\d\d)&#x2F;);
	
	&#x2F;&#x2F; If unsuccessful, try to match &quot;HHMMSS&quot; format
	if (matches === null)
		matches = isoTimeVal.match(&#x2F;^(\d\d)(\d\d)(\d\d)&#x2F;);
	
	&#x2F;&#x2F; Report bad date&#x2F;time string
	if (matches === null)
		throw &quot;Error: Invalid ISO-8601 date&#x2F;time string&quot;;

	&#x2F;&#x2F; Force base 10 parse int as some values may have leading zeros!
	&#x2F;&#x2F; (to avoid implicit octal base conversion)
	var hour = parseInt(matches[1], 10);
	var mins = parseInt(matches[2], 10);
	var secs = parseInt(matches[3], 10);
	
	&#x2F;&#x2F; Simple value range check, leap years not checked
	if (hour &lt; 0 || hour &gt; 23 ||
	    mins &lt; 0 || mins &gt; 59 ||
	    secs &lt; 0 || secs &gt; 59    )
	    
		throw &quot;Error: Invalid ISO-8601 time value&quot;;

	return new Date(0, 0, 0, hour, mins, secs);
};


&#x2F;**
 * @private
 *
 * @description Trims leading and trailing whitespace from a string.
 *
 * &lt;p&gt;Used non-regexp the method from http:&#x2F;&#x2F;blog.stevenlevithan.com&#x2F;archives&#x2F;faster-trim-javascript
 *
 * @param {String} str The string to trim.
 *
 * @returns {String} The trimmed string.
 *&#x2F;
jsworld._trim = function(str) {

	var whitespace = &#x27; \n\r\t\f\x0b\xa0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000&#x27;;
	
	for (var i = 0; i &lt; str.length; i++) {
	
		if (whitespace.indexOf(str.charAt(i)) === -1) {
			str = str.substring(i);
			break;
		}
	}
	
	for (i = str.length - 1; i &gt;= 0; i--) {
		if (whitespace.indexOf(str.charAt(i)) === -1) {
			str = str.substring(0, i + 1);
			break;
		}
	}
	
	return whitespace.indexOf(str.charAt(0)) === -1 ? str : &#x27;&#x27;;
};



&#x2F;**
 * @private
 *
 * @description Returns true if the argument represents a decimal number.
 *
 * @param {Number|String} arg The argument to test.
 *
 * @returns {Boolean} true if the argument represents a decimal number, 
 *          otherwise false.
 *&#x2F;
jsworld._isNumber = function(arg) {

	if (typeof arg == &quot;number&quot;)
		return true;
	
	if (typeof arg != &quot;string&quot;)
		return false;
	
	&#x2F;&#x2F; ensure string
	var s = arg + &quot;&quot;;
	
	return (&#x2F;^-?(\d+|\d*\.\d+)$&#x2F;).test(s);
};


&#x2F;**
 * @private
 *
 * @description Returns true if the argument represents a decimal integer.
 *
 * @param {Number|String} arg The argument to test.
 *
 * @returns {Boolean} true if the argument represents an integer, otherwise 
 *          false.
 *&#x2F;
jsworld._isInteger = function(arg) {

	if (typeof arg != &quot;number&quot; &amp;&amp; typeof arg != &quot;string&quot;)
		return false;

	&#x2F;&#x2F; convert to string
	var s = arg + &quot;&quot;;

	return (&#x2F;^-?\d+$&#x2F;).test(s);
};


&#x2F;**
 * @private
 *
 * @description Returns true if the argument represents a decimal float.
 *
 * @param {Number|String} arg The argument to test.
 *
 * @returns {Boolean} true if the argument represents a float, otherwise false.
 *&#x2F;
jsworld._isFloat = function(arg) {

	if (typeof arg != &quot;number&quot; &amp;&amp; typeof arg != &quot;string&quot;)
		return false;
	
	&#x2F;&#x2F; convert to string
	var s = arg + &quot;&quot;;
	
	return (&#x2F;^-?\.\d+?$&#x2F;).test(s);
};


&#x2F;** 
 * @private
 *
 * @description Checks if the specified formatting option is contained 
 * within the options string.
 * 
 * @param {String} option The option to search for.
 * @param {String} optionsString The options string.
 *
 * @returns {Boolean} true if the flag is found, else false
 *&#x2F;
jsworld._hasOption = function(option, optionsString) {

	if (typeof option != &quot;string&quot; || typeof optionsString != &quot;string&quot;)
		return false;

	if (optionsString.indexOf(option) != -1)
		return true;
	else
		return false;
};


&#x2F;**
 * @private
 *
 * @description String replacement function.
 *
 * @param {String} s The string to work on.
 * @param {String} target The string to search for.
 * @param {String} replacement The replacement.
 *
 * @returns {String} The new string.
 *&#x2F;
jsworld._stringReplaceAll = function(s, target, replacement) {

	var out;

	if (target.length == 1 &amp;&amp; replacement.length == 1) {
		&#x2F;&#x2F; simple char&#x2F;char case somewhat faster
		out = &quot;&quot;;
	
		for (var i = 0; i &lt; s.length; i++) {
			
			if (s.charAt(i) == target.charAt(0))
				out = out + replacement.charAt(0);
			else
				out = out + s.charAt(i);
		}
		
		return out;
	}
	else {
		&#x2F;&#x2F; longer target and replacement strings
		out = s;

		var index = out.indexOf(target);
		
		while (index != -1) {
		
			out = out.replace(target, replacement);
			
			index = out.indexOf(target);
		}

		return out;
	}
};


&#x2F;**
 * @private
 *
 * @description Tests if a string starts with the specified substring.
 *
 * @param {String} testedString The string to test.
 * @param {String} sub The string to match.
 *
 * @returns {Boolean} true if the test succeeds.
 *&#x2F;
jsworld._stringStartsWith = function (testedString, sub) {
	
	if (testedString.length &lt; sub.length)
		return false;
	
	for (var i = 0; i &lt; sub.length; i++) {
		if (testedString.charAt(i) != sub.charAt(i))
			return false;
	}
	
	return true;
};


&#x2F;** 
 * @private
 *
 * @description Gets the requested precision from an options string.
 *
 * &lt;p&gt;Example: &quot;.3&quot; returns 3 decimal places precision.
 *
 * @param {String} optionsString The options string.
 *
 * @returns {integer Number} The requested precision, -1 if not specified.
 *&#x2F;
jsworld._getPrecision = function (optionsString) {

	if (typeof optionsString != &quot;string&quot;)
		return -1;

	var m = optionsString.match(&#x2F;\.(\d)&#x2F;);
	if (m)
		return parseInt(m[1], 10);
	else
		return -1;
};


&#x2F;** 
 * @private
 *
 * @description Takes a decimal numeric amount (optionally as string) and 
 * returns its integer and fractional parts packed into an object.
 *
 * @param {Number|String} amount The amount, e.g. &quot;123.45&quot; or &quot;-56.78&quot;
 * 
 * @returns {object} Parsed amount object with properties:
 *         {String} integer  : the integer part
 *         {String} fraction : the fraction part
 *&#x2F;
jsworld._splitNumber = function (amount) {

	if (typeof amount == &quot;number&quot;)
		amount = amount + &quot;&quot;;

	var obj = {};

	&#x2F;&#x2F; remove negative sign
	if (amount.charAt(0) == &quot;-&quot;)
		amount = amount.substring(1);

	&#x2F;&#x2F; split amount into integer and decimal parts
	var amountParts = amount.split(&quot;.&quot;);
	if (!amountParts[1])
		amountParts[1] = &quot;&quot;; &#x2F;&#x2F; we need &quot;&quot; instead of null

	obj.integer = amountParts[0];
	obj.fraction = amountParts[1];

	return obj;
};


&#x2F;** 
 * @private
 *
 * @description Formats the integer part using the specified grouping
 * and thousands separator.
 * 
 * @param {String} intPart The integer part of the amount, as string.
 * @param {String} grouping The grouping definition.
 * @param {String} thousandsSep The thousands separator.
 * 
 * @returns {String} The formatted integer part.
 *&#x2F;
jsworld._formatIntegerPart = function (intPart, grouping, thousandsSep) {

	&#x2F;&#x2F; empty separator string? no grouping?
	&#x2F;&#x2F; -&gt; return immediately with no formatting!
	if (thousandsSep == &quot;&quot; || grouping == &quot;-1&quot;)
		return intPart;

	&#x2F;&#x2F; turn the semicolon-separated string of integers into an array
	var groupSizes = grouping.split(&quot;;&quot;);

	&#x2F;&#x2F; the formatted output string
	var out = &quot;&quot;;

	&#x2F;&#x2F; the intPart string position to process next,
	&#x2F;&#x2F; start at string end, e.g. &quot;10000000&lt;starts here&quot;
	var pos = intPart.length;

	&#x2F;&#x2F; process the intPart string backwards
	&#x2F;&#x2F;     &quot;1000000000&quot;
	&#x2F;&#x2F;            &lt;---\ direction
	var size;
	
	while (pos &gt; 0) {

		&#x2F;&#x2F; get next group size (if any, otherwise keep last)
		if (groupSizes.length &gt; 0)
			size = parseInt(groupSizes.shift(), 10);

		&#x2F;&#x2F; int parse error?
		if (isNaN(size))
			throw &quot;Error: Invalid grouping&quot;;

		&#x2F;&#x2F; size is -1? -&gt; no more grouping, so just copy string remainder
		if (size == -1) {
			out = intPart.substring(0, pos) + out;
			break;
		}

		pos -= size; &#x2F;&#x2F; move to next sep. char. position

		&#x2F;&#x2F; position underrun? -&gt; just copy string remainder
		if (pos &lt; 1) {
			out = intPart.substring(0, pos + size) + out;
			break;
		}

		&#x2F;&#x2F; extract group and apply sep. char.
		out = thousandsSep + intPart.substring(pos, pos + size) + out;
	}

	return out;
};
	
	
&#x2F;** 
 * @private
 *
 * @description Formats the fractional part to the specified decimal 
 * precision.
 *
 * @param {String} fracPart The fractional part of the amount
 * @param {integer Number} precision The desired decimal precision
 *
 * @returns {String} The formatted fractional part.
 *&#x2F;
jsworld._formatFractionPart = function (fracPart, precision) {

	&#x2F;&#x2F; append zeroes up to precision if necessary
	for (var i=0; fracPart.length &lt; precision; i++)
		fracPart = fracPart + &quot;0&quot;;

	return fracPart;
};


&#x2F;** 
 * @private 
 *
 * @desription Converts a number to string and pad it with leading zeroes if the
 * string is shorter than length.
 *
 * @param {integer Number} number The number value subjected to selective padding.
 * @param {integer Number} length If the number has fewer digits than this length
 *        apply padding.
 *
 * @returns {String} The formatted string.
 *&#x2F;
jsworld._zeroPad = function(number, length) {

	&#x2F;&#x2F; ensure string
	var s = number + &quot;&quot;;

	while (s.length &lt; length)
		s = &quot;0&quot; + s;
	
	return s;
};


&#x2F;** 
 * @private 
 * @description Converts a number to string and pads it with leading spaces if 
 * the string is shorter than length.
 *
 * @param {integer Number} number The number value subjected to selective padding.
 * @param {integer Number} length If the number has fewer digits than this length
 *        apply padding.
 *
 * @returns {String} The formatted string.
 *&#x2F;
jsworld._spacePad = function(number, length) {

	&#x2F;&#x2F; ensure string
	var s = number + &quot;&quot;;

	while (s.length &lt; length)
		s = &quot; &quot; + s;
	
	return s;
};



&#x2F;**
 * @class
 * Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
 * properties. Also provides a set of locale helper methods.
 *
 * &lt;p&gt;The locale properties follow the POSIX standards:
 *
 * &lt;ul&gt;
 *     &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
 *     &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
 *     &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
 * &lt;&#x2F;ul&gt;
 *
 * @public
 * @constructor
 * @description Creates a new locale object (POSIX-style) with the specified
 * properties.
 *
 * @param {object} properties An object containing the raw locale properties:
 *
 *        @param {String} properties.decimal_point
 *
 *        A string containing the symbol that shall be used as the decimal
 *        delimiter (radix character) in numeric, non-monetary formatted
 *        quantities. This property cannot be omitted and cannot be set to the
 *        empty string.
 *
 *
 *        @param {String} properties.thousands_sep
 *
 *        A string containing the symbol that shall be used as a separator for
 *        groups of digits to the left of the decimal delimiter in numeric,
 *        non-monetary formatted monetary quantities.
 *
 *
 *        @param {String} properties.grouping
 *
 *        Defines the size of each group of digits in formatted non-monetary
 *        quantities. The operand is a sequence of integers separated by
 *        semicolons. Each integer specifies the number of digits in each group,
 *        with the initial integer defining the size of the group immediately
 *        preceding the decimal delimiter, and the following integers defining
 *        the preceding groups. If the last integer is not -1, then the size of
 *        the previous group (if any) shall be repeatedly used for the
 *        remainder of the digits. If the last integer is -1, then no further
 *        grouping shall be performed.
 *
 *
 *        @param {String} properties.int_curr_symbol
 *
 *        The first three letters signify the ISO-4217 currency code,
 *        the fourth letter is the international symbol separation character
 *        (normally a space).
 *
 *
 *        @param {String} properties.currency_symbol
 *
 *        The local shorthand currency symbol, e.g. &quot;$&quot; for the en_US locale
 *
 *
 *        @param {String} properties.mon_decimal_point
 *
 *        The symbol to be used as the decimal delimiter (radix character)
 *
 *
 *        @param {String} properties.mon_thousands_sep
 *
 *        The symbol to be used as a separator for groups of digits to the
 *        left of the decimal delimiter.
 *
 *
 *        @param {String} properties.mon_grouping
 *
 *        A string that defines the size of each group of digits. The
 *        operand is a sequence of integers separated by semicolons (&quot;;&quot;).
 *        Each integer specifies the number of digits in each group, with the
 *        initial integer defining the size of the group preceding the
 *        decimal delimiter, and the following integers defining the
 *        preceding groups. If the last integer is not -1, then the size of
 *        the previous group (if any) must be repeatedly used for the
 *        remainder of the digits. If the last integer is -1, then no
 *        further grouping is to be performed.
 *
 *
 *        @param {String} properties.positive_sign
 *
 *        The string to indicate a non-negative monetary amount.
 *
 *
 *        @param {String} properties.negative_sign
 *
 *        The string to indicate a negative monetary amount.
 *
 *
 *        @param {integer Number} properties.frac_digits
 *
 *        An integer representing the number of fractional digits (those to
 *        the right of the decimal delimiter) to be written in a formatted
 *        monetary quantity using currency_symbol.
 *
 *
 *        @param {integer Number} properties.int_frac_digits
 *
 *        An integer representing the number of fractional digits (those to
 *        the right of the decimal delimiter) to be written in a formatted
 *        monetary quantity using int_curr_symbol.
 *
 *
 *        @param {integer Number} properties.p_cs_precedes
 *
 *        An integer set to 1 if the currency_symbol precedes the value for a
 *        monetary quantity with a non-negative value, and set to 0 if the
 *        symbol succeeds the value.
 *
 *
 *        @param {integer Number} properties.n_cs_precedes
 *
 *        An integer set to 1 if the currency_symbol precedes the value for a
 *        monetary quantity with a negative value, and set to 0 if the symbol
 *        succeeds the value.
 *
 *
 *        @param {integer Number} properties.p_sep_by_space
 *
 *        Set to a value indicating the separation of the currency_symbol,
 *        the sign string, and the value for a non-negative formatted monetary
 *        quantity:
 *        
 *             &lt;p&gt;0 No space separates the currency symbol and value.&lt;&#x2F;p&gt;
 *
 *             &lt;p&gt;1 If the currency symbol and sign string are adjacent, a space
 *                  separates them from the value; otherwise, a space separates
 *                  the currency symbol from the value.&lt;&#x2F;p&gt;
 *
 *             &lt;p&gt;2 If the currency symbol and sign string are adjacent, a space
 *                  separates them; otherwise, a space separates the sign string
 *                  from the value.&lt;&#x2F;p&gt;
 *
 *
 *        @param {integer Number} properties.n_sep_by_space
 *
 *        Set to a value indicating the separation of the currency_symbol,
 *        the sign string, and the value for a negative formatted monetary
 *        quantity. Rules same as for p_sep_by_space.
 *
 *
 *        @param {integer Number} properties.p_sign_posn
 *
 *        An integer set to a value indicating the positioning of the
 *        positive_sign for a monetary quantity with a non-negative value:
 *	
 *	       &lt;p&gt;0 Parentheses enclose the quantity and the currency_symbol.&lt;&#x2F;p&gt;
 *
 *	       &lt;p&gt;1 The sign string precedes the quantity and the currency_symbol.&lt;&#x2F;p&gt;
 *
 *	       &lt;p&gt;2 The sign string succeeds the quantity and the currency_symbol.&lt;&#x2F;p&gt;
 *
 *	       &lt;p&gt;3 The sign string precedes the currency_symbol.&lt;&#x2F;p&gt;
 *
 *	       &lt;p&gt;4 The sign string succeeds the currency_symbol.&lt;&#x2F;p&gt;
 *
 *
 *	  @param {integer Number} properties.n_sign_posn
 *
 *	  An integer set to a value indicating the positioning of the
 *	  negative_sign for a negative formatted monetary quantity. Rules same
 *	  as for p_sign_posn.
 *
 *
 *	  @param {integer Number} properties.int_p_cs_precedes
 *
 *	  An integer set to 1 if the int_curr_symbol precedes the value for a
 *	  monetary quantity with a non-negative value, and set to 0 if the
 *	  symbol succeeds the value.
 *
 *
 *	  @param {integer Number} properties.int_n_cs_precedes
 *
 *	  An integer set to 1 if the int_curr_symbol precedes the value for a
 *	  monetary quantity with a negative value, and set to 0 if the symbol
 *	  succeeds the value.
 *
 *
 *	  @param {integer Number} properties.int_p_sep_by_space
 *
 *	  Set to a value indicating the separation of the int_curr_symbol,
 *	  the sign string, and the value for a non-negative internationally
 *	  formatted monetary quantity. Rules same as for p_sep_by_space.
 *
 *
 *	  @param {integer Number} properties.int_n_sep_by_space
 *
 *	  Set to a value indicating the separation of the int_curr_symbol,
 *	  the sign string, and the value for a negative internationally
 *	  formatted monetary quantity. Rules same as for p_sep_by_space.
 *
 *
 *	  @param {integer Number} properties.int_p_sign_posn
 *
 *	  An integer set to a value indicating the positioning of the
 *	  positive_sign for a positive monetary quantity formatted with the
 *	  international format. Rules same as for p_sign_posn.
 *
 *
 *	  @param {integer Number} properties.int_n_sign_posn
 *
 *	  An integer set to a value indicating the positioning of the
 *	  negative_sign for a negative monetary quantity formatted with the
 *	  international format. Rules same as for p_sign_posn.
 *
 *
 *        @param {String[] | String} properties.abday
 *
 *        The abbreviated weekday names, corresponding to the %a conversion
 *        specification. The property must be either an array of 7 strings or
 *        a string consisting of 7 semicolon-separated substrings, each 
 *        surrounded by double-quotes. The first must be the abbreviated name 
 *        of the day corresponding to Sunday, the second the abbreviated name 
 *        of the day corresponding to Monday, and so on.
 *        
 *
 *        @param {String[] | String} properties.day
 *
 *        The full weekday names, corresponding to the %A conversion
 *        specification. The property must be either an array of 7 strings or
 *        a string consisting of 7 semicolon-separated substrings, each 
 *        surrounded by double-quotes. The first must be the full name of the 
 *        day corresponding to Sunday, the second the full name of the day 
 *        corresponding to Monday, and so on.
 *        
 *
 *        @param {String[] | String} properties.abmon
 *
 *        The abbreviated month names, corresponding to the %b conversion
 *        specification. The property must be either an array of 12 strings or
 *        a string consisting of 12 semicolon-separated substrings, each 
 *        surrounded by double-quotes. The first must be the abbreviated name 
 *        of the first month of the year (January), the second the abbreviated 
 *        name of the second month, and so on.
 *        
 *
 *        @param {String[] | String} properties.mon
 *
 *        The full month names, corresponding to the %B conversion
 *        specification. The property must be either an array of 12 strings or
 *        a string consisting of 12 semicolon-separated substrings, each 
 *        surrounded by double-quotes. The first must be the full name of the 
 *        first month of the year (January), the second the full name of the second 
 *        month, and so on.
 *        
 *
 *        @param {String} properties.d_fmt
 *
 *        The appropriate date representation. The string may contain any
 *        combination of characters and conversion specifications (%&lt;char&gt;).
 *        
 *
 *        @param {String} properties.t_fmt
 *
 *        The appropriate time representation. The string may contain any
 *        combination of characters and conversion specifications (%&lt;char&gt;).
 *        
 *
 *        @param {String} properties.d_t_fmt
 *
 *        The appropriate date and time representation. The string may contain
 *        any combination of characters and conversion specifications (%&lt;char&gt;).
 *
 *
 *        @param {String[] | String} properties.am_pm
 *
 *        The appropriate representation of the ante-meridiem and post-meridiem
 *        strings, corresponding to the %p conversion specification. The property 
 *        must be either an array of 2 strings or a string consisting of 2 
 *        semicolon-separated substrings, each surrounded by double-quotes. 
 *        The first string must represent the ante-meridiem designation, the 
 *        last string the post-meridiem designation.
 *
 *
 * @throws @throws Error on a undefined or invalid locale property.
 *&#x2F;
jsworld.Locale = function(properties) {
	
	
	&#x2F;**
	 * @private
	 *
	 * @description Identifies the class for internal library purposes.
	 *&#x2F;
	this._className = &quot;jsworld.Locale&quot;;
	
	
	&#x2F;** 
	 * @private 
	 *
	 * @description Parses a day or month name definition list, which
	 * could be a ready JS array, e.g. [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;...] or
	 * it could be a string formatted according to the classic POSIX
	 * definition e.g. &quot;Mon&quot;;&quot;Tue&quot;;&quot;Wed&quot;;...
	 *
	 * @param {String[] | String} namesAn array or string defining 
	 *        the week&#x2F;month names.
	 * @param {integer Number} expectedItems The number of expected list
	 *        items, e.g. 7 for weekdays, 12 for months.
	 *
	 * @returns {String[]} The parsed (and checked) items.
	 * 
	 * @throws Error on missing definition, unexpected item count or
	 *         missing double-quotes.
	 *&#x2F;
	this._parseList = function(names, expectedItems) {
		
		var array = [];
		
		if (names == null) {
			throw &quot;Names not defined&quot;;
		}
		else if (typeof names == &quot;object&quot;) {
			&#x2F;&#x2F; we got a ready array
			array = names;
		}
		else if (typeof names == &quot;string&quot;) {
			&#x2F;&#x2F; we got the names in the classic POSIX form, do parse
			array = names.split(&quot;;&quot;, expectedItems);
		
			for (var i = 0; i &lt; array.length; i++) {
				&#x2F;&#x2F; check for and strip double quotes
				if (array[i][0] == &quot;\&quot;&quot; &amp;&amp; array[i][array[i].length - 1] == &quot;\&quot;&quot;)
					array[i] = array[i].slice(1, -1);
				else
					throw &quot;Missing double quotes&quot;;
			}
		}
		else {
			throw &quot;Names must be an array or a string&quot;;
		}
		
		if (array.length != expectedItems)
			throw &quot;Expected &quot; + expectedItems + &quot; items, got &quot; + array.length;
		
		return array;
	};
	
	
	&#x2F;**
	 * @private
	 *
	 * @description Validates a date&#x2F;time format string, such as &quot;H:%M:%S&quot;. 
	 * Checks that the argument is of type &quot;string&quot; and is not empty.
	 *
	 * @param {String} formatString The format string.
	 *
	 * @returns {String} The validated string.
	 *
	 * @throws Error on null or empty string.
	 *&#x2F;
	this._validateFormatString = function(formatString) {
		
		if (typeof formatString == &quot;string&quot; &amp;&amp; formatString.length &gt; 0)
			return formatString;
		else
			throw &quot;Empty or no string&quot;;
	};
	
	
	&#x2F;&#x2F; LC_NUMERIC

	if (properties == null || typeof properties != &quot;object&quot;)
		throw &quot;Error: Invalid&#x2F;missing locale properties&quot;;
	
	
	if (typeof properties.decimal_point != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing decimal_point property&quot;;
	
	this.decimal_point = properties.decimal_point;
	
	
	if (typeof properties.thousands_sep != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing thousands_sep property&quot;;
	
	this.thousands_sep = properties.thousands_sep;
	
	
	if (typeof properties.grouping != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing grouping property&quot;;
	
	this.grouping = properties.grouping;
	
	
	&#x2F;&#x2F; LC_MONETARY
	
	if (typeof properties.int_curr_symbol != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing int_curr_symbol property&quot;;
	
	if (! &#x2F;[A-Za-z]{3}.?&#x2F;.test(properties.int_curr_symbol))
		throw &quot;Error: Invalid int_curr_symbol property&quot;;
	
	this.int_curr_symbol = properties.int_curr_symbol;
	

	if (typeof properties.currency_symbol != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing currency_symbol property&quot;;
	
	this.currency_symbol = properties.currency_symbol;
	
	
	if (typeof properties.frac_digits != &quot;number&quot; &amp;&amp; properties.frac_digits &lt; 0)
		throw &quot;Error: Invalid&#x2F;missing frac_digits property&quot;;
	
	this.frac_digits = properties.frac_digits;
	
	
	&#x2F;&#x2F; may be empty string&#x2F;null for currencies with no fractional part
	if (properties.mon_decimal_point === null || properties.mon_decimal_point == &quot;&quot;) {
	
		if (this.frac_digits &gt; 0)
			throw &quot;Error: Undefined mon_decimal_point property&quot;;
		else
			properties.mon_decimal_point = &quot;&quot;;
	}
	
	if (typeof properties.mon_decimal_point != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing mon_decimal_point property&quot;;
	
	this.mon_decimal_point = properties.mon_decimal_point;
	
	
	if (typeof properties.mon_thousands_sep != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing mon_thousands_sep property&quot;;
	
	this.mon_thousands_sep = properties.mon_thousands_sep;
	
	
	if (typeof properties.mon_grouping != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing mon_grouping property&quot;;
	
	this.mon_grouping = properties.mon_grouping;
	
	
	if (typeof properties.positive_sign != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing positive_sign property&quot;;
	
	this.positive_sign = properties.positive_sign;
	
	
	if (typeof properties.negative_sign != &quot;string&quot;)
		throw &quot;Error: Invalid&#x2F;missing negative_sign property&quot;;
	
	this.negative_sign = properties.negative_sign;
	
	
	
	if (properties.p_cs_precedes !== 0 &amp;&amp; properties.p_cs_precedes !== 1)
		throw &quot;Error: Invalid&#x2F;missing p_cs_precedes property, must be 0 or 1&quot;;
	
	this.p_cs_precedes = properties.p_cs_precedes;
	
	
	if (properties.n_cs_precedes !== 0 &amp;&amp; properties.n_cs_precedes !== 1)
		throw &quot;Error: Invalid&#x2F;missing n_cs_precedes, must be 0 or 1&quot;;
	
	this.n_cs_precedes = properties.n_cs_precedes;
	

	if (properties.p_sep_by_space !== 0 &amp;&amp;
	    properties.p_sep_by_space !== 1 &amp;&amp;
	    properties.p_sep_by_space !== 2)
		throw &quot;Error: Invalid&#x2F;missing p_sep_by_space property, must be 0, 1 or 2&quot;;
	
	this.p_sep_by_space = properties.p_sep_by_space;
	

	if (properties.n_sep_by_space !== 0 &amp;&amp;
	    properties.n_sep_by_space !== 1 &amp;&amp;
	    properties.n_sep_by_space !== 2)
		throw &quot;Error: Invalid&#x2F;missing n_sep_by_space property, must be 0, 1, or 2&quot;;
	
	this.n_sep_by_space = properties.n_sep_by_space;
	

	if (properties.p_sign_posn !== 0 &amp;&amp;
	    properties.p_sign_posn !== 1 &amp;&amp;
	    properties.p_sign_posn !== 2 &amp;&amp;
	    properties.p_sign_posn !== 3 &amp;&amp;
	    properties.p_sign_posn !== 4)
		throw &quot;Error: Invalid&#x2F;missing p_sign_posn property, must be 0, 1, 2, 3 or 4&quot;;
	
	this.p_sign_posn = properties.p_sign_posn;


	if (properties.n_sign_posn !== 0 &amp;&amp;
	    properties.n_sign_posn !== 1 &amp;&amp;
	    properties.n_sign_posn !== 2 &amp;&amp;
	    properties.n_sign_posn !== 3 &amp;&amp;
	    properties.n_sign_posn !== 4)
		throw &quot;Error: Invalid&#x2F;missing n_sign_posn property, must be 0, 1, 2, 3 or 4&quot;;
	
	this.n_sign_posn = properties.n_sign_posn;


	if (typeof properties.int_frac_digits != &quot;number&quot; &amp;&amp; properties.int_frac_digits &lt; 0)
		throw &quot;Error: Invalid&#x2F;missing int_frac_digits property&quot;;

	this.int_frac_digits = properties.int_frac_digits;
	
	
	if (properties.int_p_cs_precedes !== 0 &amp;&amp; properties.int_p_cs_precedes !== 1)
		throw &quot;Error: Invalid&#x2F;missing int_p_cs_precedes property, must be 0 or 1&quot;;
	
	this.int_p_cs_precedes = properties.int_p_cs_precedes;
	
	
	if (properties.int_n_cs_precedes !== 0 &amp;&amp; properties.int_n_cs_precedes !== 1)
		throw &quot;Error: Invalid&#x2F;missing int_n_cs_precedes property, must be 0 or 1&quot;;
	
	this.int_n_cs_precedes = properties.int_n_cs_precedes;
	

	if (properties.int_p_sep_by_space !== 0 &amp;&amp;
	    properties.int_p_sep_by_space !== 1 &amp;&amp;
	    properties.int_p_sep_by_space !== 2)
		throw &quot;Error: Invalid&#x2F;missing int_p_sep_by_spacev, must be 0, 1 or 2&quot;;
		
	this.int_p_sep_by_space = properties.int_p_sep_by_space;


	if (properties.int_n_sep_by_space !== 0 &amp;&amp;
	    properties.int_n_sep_by_space !== 1 &amp;&amp;
	    properties.int_n_sep_by_space !== 2)
		throw &quot;Error: Invalid&#x2F;missing int_n_sep_by_space property, must be 0, 1, or 2&quot;;
	
	this.int_n_sep_by_space = properties.int_n_sep_by_space;
	

	if (properties.int_p_sign_posn !== 0 &amp;&amp;
	    properties.int_p_sign_posn !== 1 &amp;&amp;
	    properties.int_p_sign_posn !== 2 &amp;&amp;
	    properties.int_p_sign_posn !== 3 &amp;&amp;
	    properties.int_p_sign_posn !== 4)
		throw &quot;Error: Invalid&#x2F;missing int_p_sign_posn property, must be 0, 1, 2, 3 or 4&quot;;
	
	this.int_p_sign_posn = properties.int_p_sign_posn;
	
	
	if (properties.int_n_sign_posn !== 0 &amp;&amp;
	    properties.int_n_sign_posn !== 1 &amp;&amp;
	    properties.int_n_sign_posn !== 2 &amp;&amp;
	    properties.int_n_sign_posn !== 3 &amp;&amp;
	    properties.int_n_sign_posn !== 4)
		throw &quot;Error: Invalid&#x2F;missing int_n_sign_posn property, must be 0, 1, 2, 3 or 4&quot;;

	this.int_n_sign_posn = properties.int_n_sign_posn;
	
	
	&#x2F;&#x2F; LC_TIME
	
	if (properties == null || typeof properties != &quot;object&quot;)
		throw &quot;Error: Invalid&#x2F;missing time locale properties&quot;;
	
	
	&#x2F;&#x2F; parse the supported POSIX LC_TIME properties
	
	&#x2F;&#x2F; abday
	try  {
		this.abday = this._parseList(properties.abday, 7);
	}
	catch (error) {
		throw &quot;Error: Invalid abday property: &quot; + error;
	}
	
	&#x2F;&#x2F; day
	try {
		this.day = this._parseList(properties.day, 7);
	}
	catch (error) {
		throw &quot;Error: Invalid day property: &quot; + error;
	}
	
	&#x2F;&#x2F; abmon
	try {
		this.abmon = this._parseList(properties.abmon, 12);
	} catch (error) {
		throw &quot;Error: Invalid abmon property: &quot; + error;
	}
	
	&#x2F;&#x2F; mon
	try {
		this.mon = this._parseList(properties.mon, 12);
	} catch (error) {
		throw &quot;Error: Invalid mon property: &quot; + error;
	}
	
	&#x2F;&#x2F; d_fmt
	try {
		this.d_fmt = this._validateFormatString(properties.d_fmt);
	} catch (error) {
		throw &quot;Error: Invalid d_fmt property: &quot; + error;
	}
	
	&#x2F;&#x2F; t_fmt
	try {
		this.t_fmt = this._validateFormatString(properties.t_fmt);
	} catch (error) {
		throw &quot;Error: Invalid t_fmt property: &quot; + error;
	}
	
	&#x2F;&#x2F; d_t_fmt
	try {
		this.d_t_fmt = this._validateFormatString(properties.d_t_fmt);
	} catch (error) {
		throw &quot;Error: Invalid d_t_fmt property: &quot; + error;
	}
	
	&#x2F;&#x2F; am_pm
	try {
		var am_pm_strings = this._parseList(properties.am_pm, 2);
		this.am = am_pm_strings[0];
		this.pm = am_pm_strings[1];
	} catch (error) {
		&#x2F;&#x2F; ignore empty&#x2F;null string errors
		this.am = &quot;&quot;;
		this.pm = &quot;&quot;;
	}
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Returns the abbreviated name of the specified weekday.
	 *
	 * @param {integer Number} [weekdayNum] An integer between 0 and 6. Zero 
	 *        corresponds to Sunday, one to Monday, etc. If omitted the
	 *        method will return an array of all abbreviated weekday 
	 *        names.
	 *
	 * @returns {String | String[]} The abbreviated name of the specified weekday
	 *          or an array of all abbreviated weekday names.
	 *
	 * @throws Error on invalid argument.
	 *&#x2F;
	this.getAbbreviatedWeekdayName = function(weekdayNum) {
	
		if (typeof weekdayNum == &quot;undefined&quot; || weekdayNum === null)
			return this.abday;
		
		if (! jsworld._isInteger(weekdayNum) || weekdayNum &lt; 0 || weekdayNum &gt; 6)
			throw &quot;Error: Invalid weekday argument, must be an integer [0..6]&quot;;
			
		return this.abday[weekdayNum];
	};
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Returns the name of the specified weekday.
	 *
	 * @param {integer Number} [weekdayNum] An integer between 0 and 6. Zero 
	 *        corresponds to Sunday, one to Monday, etc. If omitted the
	 *        method will return an array of all weekday names.
	 *
	 * @returns {String | String[]} The name of the specified weekday or an 
	 *          array of all weekday names.
	 *
	 * @throws Error on invalid argument.
	 *&#x2F;
	this.getWeekdayName = function(weekdayNum) {
		
		if (typeof weekdayNum == &quot;undefined&quot; || weekdayNum === null)
			return this.day;
		
		if (! jsworld._isInteger(weekdayNum) || weekdayNum &lt; 0 || weekdayNum &gt; 6)
			throw &quot;Error: Invalid weekday argument, must be an integer [0..6]&quot;;
			
		return this.day[weekdayNum];
	};
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Returns the abbreviated name of the specified month.
	 *
	 * @param {integer Number} [monthNum] An integer between 0 and 11. Zero 
	 *        corresponds to January, one to February, etc. If omitted the
	 *        method will return an array of all abbreviated month names.
	 *
	 * @returns {String | String[]} The abbreviated name of the specified month
	 *          or an array of all abbreviated month names.
	 *
	 * @throws Error on invalid argument.
	 *&#x2F;
	this.getAbbreviatedMonthName = function(monthNum) {
	
		if (typeof monthNum == &quot;undefined&quot; || monthNum === null)
			return this.abmon;
		
		if (! jsworld._isInteger(monthNum) || monthNum &lt; 0 || monthNum &gt; 11)
			throw &quot;Error: Invalid month argument, must be an integer [0..11]&quot;;
		
		return this.abmon[monthNum];
	};
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Returns the name of the specified month.
	 *
	 * @param {integer Number} [monthNum] An integer between 0 and 11. Zero 
	 *        corresponds to January, one to February, etc. If omitted the
	 *        method will return an array of all month names.
	 *
	 * @returns {String | String[]} The name of the specified month or an array 
	 *          of all month names.
	 *
	 * @throws Error on invalid argument.
	 *&#x2F;
	this.getMonthName = function(monthNum) {
	
		if (typeof monthNum == &quot;undefined&quot; || monthNum === null)
			return this.mon;
		
		if (! jsworld._isInteger(monthNum) || monthNum &lt; 0 || monthNum &gt; 11)
			throw &quot;Error: Invalid month argument, must be an integer [0..11]&quot;;
		
		return this.mon[monthNum];
	};
	
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the decimal delimiter (radix) character for
	 * numeric quantities.
	 *
	 * @returns {String} The radix character.
	 *&#x2F;
	this.getDecimalPoint = function() {
		
		return this.decimal_point;
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the local shorthand currency symbol.
	 *
	 * @returns {String} The currency symbol.
	 *&#x2F;
	this.getCurrencySymbol = function() {
		
		return this.currency_symbol;
	};
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Gets the internaltion currency symbol (ISO-4217 code).
	 *
	 * @returns {String} The international currency symbol.
	 *&#x2F;
	this.getIntCurrencySymbol = function() {
	
		return this.int_curr_symbol.substring(0,3);
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the position of the local (shorthand) currency 
	 * symbol relative to the amount. Assumes a non-negative amount.
	 *
	 * @returns {Boolean} True if the symbol precedes the amount, false if
	 * the symbol succeeds the amount.
	 *&#x2F;
	this.currencySymbolPrecedes = function() {
		
		if (this.p_cs_precedes == 1)
			return true;
		else
			return false;
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the position of the international (ISO-4217 code) 
	 * currency symbol relative to the amount. Assumes a non-negative 
	 * amount.
	 *
	 * @returns {Boolean} True if the symbol precedes the amount, false if
	 * the symbol succeeds the amount.
	 *&#x2F;
	this.intCurrencySymbolPrecedes = function() {
		
		if (this.int_p_cs_precedes == 1)
			return true;
		else
			return false;

	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the decimal delimiter (radix) for monetary
	 * quantities.
	 *
	 * @returns {String} The radix character.
	 *&#x2F;
	this.getMonetaryDecimalPoint = function() {
		
		return this.mon_decimal_point;
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the number of fractional digits for local
	 * (shorthand) symbol formatting.
	 *
	 * @returns {integer Number} The number of fractional digits.
	 *&#x2F;
	this.getFractionalDigits = function() {
		
		return this.frac_digits;
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the number of fractional digits for
	 * international (ISO-4217 code) formatting.
	 *
	 * @returns {integer Number} The number of fractional digits.
	 *&#x2F;
	this.getIntFractionalDigits = function() {
		
		return this.int_frac_digits;
	};
};



&#x2F;** 
 * @class 
 * Class for localised formatting of numbers.
 *
 * &lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
 * POSIX LC_NUMERIC&lt;&#x2F;a&gt;.
 *
 *
 * @public
 * @constructor 
 * @description Creates a new numeric formatter for the specified locale.
 *
 * @param {jsworld.Locale} locale A locale object specifying the required 
 *        POSIX LC_NUMERIC formatting properties.
 *
 * @throws Error on constructor failure.
 *&#x2F;
jsworld.NumericFormatter = function(locale) {

	if (typeof locale != &quot;object&quot; || locale._className != &quot;jsworld.Locale&quot;)
		throw &quot;Constructor error: You must provide a valid jsworld.Locale instance&quot;;
	
	this.lc = locale;
	
	
	&#x2F;** 
	 * @public
	 * 
	 * @description Formats a decimal numeric value according to the preset
	 * locale.
	 *
	 * @param {Number|String} number The number to format.
	 * @param {String} [options] Options to modify the formatted output:
	 *        &lt;ul&gt;
	 *            &lt;li&gt;&quot;^&quot;  suppress grouping
	 *            &lt;li&gt;&quot;+&quot;  force positive sign for positive amounts
	 *            &lt;li&gt;&quot;~&quot;  suppress positive&#x2F;negative sign
	 *            &lt;li&gt;&quot;.n&quot; specify decimal precision &#x27;n&#x27;
	 *        &lt;&#x2F;ul&gt;
	 *
	 * @returns {String} The formatted number.
	 *
	 * @throws &quot;Error: Invalid input&quot; on bad input.
	 *&#x2F;
	this.format = function(number, options) {
		
		if (typeof number == &quot;string&quot;)
			number = jsworld._trim(number);
		
		if (! jsworld._isNumber(number))
			throw &quot;Error: The input is not a number&quot;;
		
		var floatAmount = parseFloat(number, 10);
		
		&#x2F;&#x2F; get the required precision
		var reqPrecision = jsworld._getPrecision(options);
		
		&#x2F;&#x2F; round to required precision
		if (reqPrecision != -1)
			floatAmount = Math.round(floatAmount * Math.pow(10, reqPrecision)) &#x2F; Math.pow(10, reqPrecision);
		
		
		&#x2F;&#x2F; convert the float number to string and parse into
		&#x2F;&#x2F; object with properties integer and fraction
		var parsedAmount = jsworld._splitNumber(String(floatAmount));
		
		&#x2F;&#x2F; format integer part with grouping chars
		var formattedIntegerPart;
		
		if (floatAmount === 0)
			formattedIntegerPart = &quot;0&quot;;
		else
			formattedIntegerPart = jsworld._hasOption(&quot;^&quot;, options) ?
				parsedAmount.integer :
				jsworld._formatIntegerPart(parsedAmount.integer, 
				                           this.lc.grouping, 
							   this.lc.thousands_sep);
		
		&#x2F;&#x2F; format the fractional part
		var formattedFractionPart =
			reqPrecision != -1 ?
			jsworld._formatFractionPart(parsedAmount.fraction, reqPrecision) :
			parsedAmount.fraction;
		
		
		&#x2F;&#x2F; join the integer and fraction parts using the decimal_point property
		var formattedAmount =
			formattedFractionPart.length ?
			formattedIntegerPart + this.lc.decimal_point + formattedFractionPart :
			formattedIntegerPart;
		
		&#x2F;&#x2F; prepend sign?
		if (jsworld._hasOption(&quot;~&quot;, options) || floatAmount === 0) {
			&#x2F;&#x2F; suppress both &#x27;+&#x27; and &#x27;-&#x27; signs, i.e. return abs value
			return formattedAmount; 
		}
		else {
			if (jsworld._hasOption(&quot;+&quot;, options) || floatAmount &lt; 0) {
				if (floatAmount &gt; 0)
					&#x2F;&#x2F; force &#x27;+&#x27; sign for positive amounts
					return &quot;+&quot; + formattedAmount;
				else if (floatAmount &lt; 0)
					&#x2F;&#x2F; prepend &#x27;-&#x27; sign
					return &quot;-&quot; + formattedAmount;
				else
					&#x2F;&#x2F; zero case
					return formattedAmount;
			}
			else {
				&#x2F;&#x2F; positive amount with no &#x27;+&#x27; sign
				return formattedAmount;
			}
		}
	};
};


&#x2F;** 
 * @class 
 * Class for localised formatting of dates and times.
 *
 * &lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
 * POSIX LC_TIME&lt;&#x2F;a&gt;.
 *
 * @public
 * @constructor
 * @description Creates a new date&#x2F;time formatter for the specified locale.
 *
 * @param {jsworld.Locale} locale A locale object specifying the required 
 *        POSIX LC_TIME formatting properties.
 *
 * @throws Error on constructor failure.
 *&#x2F;
jsworld.DateTimeFormatter = function(locale) {
	
		
	if (typeof locale != &quot;object&quot; || locale._className != &quot;jsworld.Locale&quot;)
		throw &quot;Constructor error: You must provide a valid jsworld.Locale instance.&quot;;
	
	this.lc = locale;

	
	&#x2F;** 
	 * @public 
	 *
	 * @description Formats a date according to the preset locale.
	 *
	 * @param {Date|String} date A valid Date object instance or a string
	 *        containing a valid ISO-8601 formatted date, e.g. &quot;2010-31-03&quot; 
	 *        or &quot;2010-03-31 23:59:59&quot;.
	 *
	 * @returns {String} The formatted date
	 *
	 * @throws Error on invalid date argument
	 *&#x2F;
	this.formatDate = function(date) {
		
		var d = null;
		
		if (typeof date == &quot;string&quot;) {
			&#x2F;&#x2F; assume ISO-8601 date string
			try {
				d = jsworld.parseIsoDate(date);
			} catch (error) {
				&#x2F;&#x2F; try full ISO-8601 date&#x2F;time string
				d = jsworld.parseIsoDateTime(date);
			}
		}
		else if (date !== null &amp;&amp; typeof date == &quot;object&quot;) {
			&#x2F;&#x2F; assume ready Date object
			d = date;
		}
		else {
			throw &quot;Error: Invalid date argument, must be a Date object or an ISO-8601 date&#x2F;time string&quot;;
		}
		
		return this._applyFormatting(d, this.lc.d_fmt);
	};
	
	
	&#x2F;** 
	 * @public 
	 *
	 * @description Formats a time according to the preset locale.
	 *
	 * @param {Date|String} date A valid Date object instance or a string
	 *        containing a valid ISO-8601 formatted time, e.g. &quot;23:59:59&quot;
	 *        or &quot;2010-03-31 23:59:59&quot;.
	 *
	 * @returns {String} The formatted time.
	 *
	 * @throws Error on invalid date argument.
	 *&#x2F;
	this.formatTime = function(date) {
		
		var d = null;
		
		if (typeof date == &quot;string&quot;) {
			&#x2F;&#x2F; assume ISO-8601 time string
			try {
				d = jsworld.parseIsoTime(date);
			} catch (error) {
				&#x2F;&#x2F; try full ISO-8601 date&#x2F;time string
				d = jsworld.parseIsoDateTime(date);
			}
		}
		else if (date !== null &amp;&amp; typeof date == &quot;object&quot;) {
			&#x2F;&#x2F; assume ready Date object
			d = date;
		}
		else {
			throw &quot;Error: Invalid date argument, must be a Date object or an ISO-8601 date&#x2F;time string&quot;;
		}
		
		return this._applyFormatting(d, this.lc.t_fmt);
	};
	
	
	&#x2F;** 
	 * @public 
	 *
	 * @description Formats a date&#x2F;time value according to the preset 
	 * locale.
	 *
	 * @param {Date|String} date A valid Date object instance or a string
	 *        containing a valid ISO-8601 formatted date&#x2F;time, e.g.
	 *        &quot;2010-03-31 23:59:59&quot;.
	 *
	 * @returns {String} The formatted time.
	 *
	 * @throws Error on invalid argument.
	 *&#x2F;
	this.formatDateTime = function(date) {
		
		var d = null;
		
		if (typeof date == &quot;string&quot;) {
			&#x2F;&#x2F; assume ISO-8601 format
			d = jsworld.parseIsoDateTime(date);
		}
		else if (date !== null &amp;&amp; typeof date == &quot;object&quot;) {
			&#x2F;&#x2F; assume ready Date object
			d = date;
		}
		else {
			throw &quot;Error: Invalid date argument, must be a Date object or an ISO-8601 date&#x2F;time string&quot;;
		}
		
		return this._applyFormatting(d, this.lc.d_t_fmt);
	};
	
	
	&#x2F;** 
	 * @private 
	 *
	 * @description Apples formatting to the Date object according to the
	 * format string.
	 *
	 * @param {Date} d A valid Date instance.
	 * @param {String} s The formatting string with &#x27;%&#x27; placeholders.
	 *
	 * @returns {String} The formatted string.
	 *&#x2F;
	this._applyFormatting = function(d, s) {
		
		s = s.replace(&#x2F;%%&#x2F;g, &#x27;%&#x27;);
		s = s.replace(&#x2F;%a&#x2F;g, this.lc.abday[d.getDay()]);
		s = s.replace(&#x2F;%A&#x2F;g, this.lc.day[d.getDay()]);
		s = s.replace(&#x2F;%b&#x2F;g, this.lc.abmon[d.getMonth()]);
		s = s.replace(&#x2F;%B&#x2F;g, this.lc.mon[d.getMonth()]);
		s = s.replace(&#x2F;%d&#x2F;g, jsworld._zeroPad(d.getDate(), 2));
		s = s.replace(&#x2F;%e&#x2F;g, jsworld._spacePad(d.getDate(), 2));
		s = s.replace(&#x2F;%F&#x2F;g, d.getFullYear() +
				         &quot;-&quot; +
					 jsworld._zeroPad(d.getMonth()+1, 2) +
					 &quot;-&quot; +
					 jsworld._zeroPad(d.getDate(), 2));
		s = s.replace(&#x2F;%h&#x2F;g, this.lc.abmon[d.getMonth()]); &#x2F;&#x2F; same as %b
		s = s.replace(&#x2F;%H&#x2F;g, jsworld._zeroPad(d.getHours(), 2));
		s = s.replace(&#x2F;%I&#x2F;g, jsworld._zeroPad(this._hours12(d.getHours()), 2));
		s = s.replace(&#x2F;%k&#x2F;g, d.getHours());
		s = s.replace(&#x2F;%l&#x2F;g, this._hours12(d.getHours()));
		s = s.replace(&#x2F;%m&#x2F;g, jsworld._zeroPad(d.getMonth()+1, 2));
		s = s.replace(&#x2F;%n&#x2F;g, &quot;\n&quot;);
		s = s.replace(&#x2F;%M&#x2F;g, jsworld._zeroPad(d.getMinutes(), 2));
		s = s.replace(&#x2F;%p&#x2F;g, this._getAmPm(d.getHours()));
		s = s.replace(&#x2F;%P&#x2F;g, this._getAmPm(d.getHours()).toLocaleLowerCase()); &#x2F;&#x2F; safe?
		s = s.replace(&#x2F;%R&#x2F;g, jsworld._zeroPad(d.getHours(), 2) +
					&quot;:&quot; +
					jsworld._zeroPad(d.getMinutes(), 2));
		s = s.replace(&#x2F;%S&#x2F;g, jsworld._zeroPad(d.getSeconds(), 2));
		s = s.replace(&#x2F;%T&#x2F;g, jsworld._zeroPad(d.getHours(), 2) +
					&quot;:&quot; +
					jsworld._zeroPad(d.getMinutes(), 2) +
					&quot;:&quot; +
					jsworld._zeroPad(d.getSeconds(), 2));
		s = s.replace(&#x2F;%w&#x2F;g, this.lc.day[d.getDay()]);
		s = s.replace(&#x2F;%y&#x2F;g, new String(d.getFullYear()).substring(2));
		s = s.replace(&#x2F;%Y&#x2F;g, d.getFullYear());
		
		s = s.replace(&#x2F;%Z&#x2F;g, &quot;&quot;); &#x2F;&#x2F; to do: ignored until a reliable TMZ method found
		
		s = s.replace(&#x2F;%[a-zA-Z]&#x2F;g, &quot;&quot;); &#x2F;&#x2F; ignore all other % sequences
		
		return s;
	};
	
	
	&#x2F;** 
	 * @private 
	 *
	 * @description Does 24 to 12 hour conversion.
	 *
	 * @param {integer Number} hour24 Hour [0..23].
	 * 
	 * @returns {integer Number} Corresponding hour [1..12].
	 *&#x2F;
	this._hours12 = function(hour24) {
		
		if (hour24 === 0)
			return 12; &#x2F;&#x2F; 00h is 12AM
			
		else if (hour24 &gt; 12)
			return hour24 - 12; &#x2F;&#x2F; 1PM to 11PM
		
		else
			return hour24; &#x2F;&#x2F; 1AM to 12PM
	};
	
	
	&#x2F;** 
	 * @private 
	 * 
	 * @description Gets the appropriate localised AM or PM string depending
	 * on the day hour. Special cases: midnight is 12AM, noon is 12PM.
	 *
	 * @param {integer Number} hour24 Hour [0..23].
	 * 
	 * @returns {String} The corresponding localised AM or PM string.
	 *&#x2F;
	this._getAmPm = function(hour24) {
		
		if (hour24 &lt; 12)
			return this.lc.am;
		else
			return this.lc.pm;
	};
};



&#x2F;** 
 * @class Class for localised formatting of currency amounts.
 *
 * &lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
 * POSIX LC_MONETARY&lt;&#x2F;a&gt;.
 *
 * @public
 * @constructor
 * @description Creates a new monetary formatter for the specified locale.
 *
 * @param {jsworld.Locale} locale A locale object specifying the required 
 *        POSIX LC_MONETARY formatting properties.
 * @param {String} [currencyCode] Set the currency explicitly by
 *        passing its international ISO-4217 code, e.g. &quot;USD&quot;, &quot;EUR&quot;, &quot;GBP&quot;.
 *        Use this optional parameter to override the default local currency
 * @param {String} [altIntSymbol] Non-local currencies are formatted
 *        with their international ISO-4217 code to prevent ambiguity.
 *        Use this optional argument to force a different symbol, such as the
 *        currency&#x27;s shorthand sign. This is mostly useful when the shorthand
 *        sign is both internationally recognised and identifies the currency
 *        uniquely (e.g. the Euro sign).
 *
 * @throws Error on constructor failure.
 *&#x2F;
jsworld.MonetaryFormatter = function(locale, currencyCode, altIntSymbol) {
	
	if (typeof locale != &quot;object&quot; || locale._className != &quot;jsworld.Locale&quot;)
		throw &quot;Constructor error: You must provide a valid jsworld.Locale instance&quot;;
	
	this.lc = locale;
	
	&#x2F;** 
	 * @private
	 * @description Lookup table to determine the fraction digits for a
	 * specific currency; most currencies subdivide at 1&#x2F;100 (2 fractional
	 * digits), so we store only those that deviate from the default.
	 *
	 * &lt;p&gt;The data is from Unicode&#x27;s CLDR version 1.7.0. The two currencies
	 * with non-decimal subunits (MGA and MRO) are marked as having no
	 * fractional digits as well as all currencies that have no subunits
	 * in circulation.
	 * 
	 * &lt;p&gt;It is &quot;hard-wired&quot; for referential convenience and is only looked
	 * up when an overriding currencyCode parameter is supplied.
	 *&#x2F;
	this.currencyFractionDigits = {
		&quot;AFN&quot; : 0, &quot;ALL&quot; : 0, &quot;AMD&quot; : 0, &quot;BHD&quot; : 3, &quot;BIF&quot; : 0,
		&quot;BYR&quot; : 0, &quot;CLF&quot; : 0, &quot;CLP&quot; : 0, &quot;COP&quot; : 0, &quot;CRC&quot; : 0, 
		&quot;DJF&quot; : 0, &quot;GNF&quot; : 0, &quot;GYD&quot; : 0, &quot;HUF&quot; : 0, &quot;IDR&quot; : 0, 
		&quot;IQD&quot; : 0, &quot;IRR&quot; : 0, &quot;ISK&quot; : 0, &quot;JOD&quot; : 3, &quot;JPY&quot; : 0, 
		&quot;KMF&quot; : 0, &quot;KRW&quot; : 0, &quot;KWD&quot; : 3, &quot;LAK&quot; : 0, &quot;LBP&quot; : 0,
		&quot;LYD&quot; : 3, &quot;MGA&quot; : 0, &quot;MMK&quot; : 0, &quot;MNT&quot; : 0, &quot;MRO&quot; : 0,
		&quot;MUR&quot; : 0, &quot;OMR&quot; : 3, &quot;PKR&quot; : 0, &quot;PYG&quot; : 0, &quot;RSD&quot; : 0, 
		&quot;RWF&quot; : 0, &quot;SLL&quot; : 0, &quot;SOS&quot; : 0, &quot;STD&quot; : 0, &quot;SYP&quot; : 0, 
		&quot;TND&quot; : 3, &quot;TWD&quot; : 0, &quot;TZS&quot; : 0, &quot;UGX&quot; : 0, &quot;UZS&quot; : 0, 
		&quot;VND&quot; : 0, &quot;VUV&quot; : 0, &quot;XAF&quot; : 0, &quot;XOF&quot; : 0, &quot;XPF&quot; : 0, 
		&quot;YER&quot; : 0, &quot;ZMK&quot; : 0
	};
	
	
	&#x2F;&#x2F; optional currencyCode argument?
	if (typeof currencyCode == &quot;string&quot;) {
		&#x2F;&#x2F; user wanted to override the local currency
		this.currencyCode = currencyCode.toUpperCase();
		
		&#x2F;&#x2F; must override the frac digits too, for some
		&#x2F;&#x2F; currencies have 0, 2 or 3!
		var numDigits = this.currencyFractionDigits[this.currencyCode];
		if (typeof numDigits != &quot;number&quot;)
			numDigits = 2; &#x2F;&#x2F; default for most currencies
		this.lc.frac_digits = numDigits;
		this.lc.int_frac_digits = numDigits;
	}
	else {
		&#x2F;&#x2F; use local currency
		this.currencyCode = this.lc.int_curr_symbol.substring(0,3).toUpperCase();
	}
	
	&#x2F;&#x2F; extract intl. currency separator
	this.intSep = this.lc.int_curr_symbol.charAt(3);
	
	&#x2F;&#x2F; flag local or intl. sign formatting?
	if (this.currencyCode == this.lc.int_curr_symbol.substring(0,3)) {
		&#x2F;&#x2F; currency matches the local one? -&gt;
		&#x2F;&#x2F; formatting with local symbol and parameters
		this.internationalFormatting = false;
		this.curSym = this.lc.currency_symbol;
	}
	else {
		&#x2F;&#x2F; currency doesn&#x27;t match the local -&gt;
		
		&#x2F;&#x2F; do we have an overriding currency symbol?
		if (typeof altIntSymbol == &quot;string&quot;) {
			&#x2F;&#x2F; -&gt; force formatting with local parameters, using alt symbol
			this.curSym = altIntSymbol;
			this.internationalFormatting = false;
		}
		else {
			&#x2F;&#x2F; -&gt; force formatting with intl. sign and parameters
			this.internationalFormatting = true;
		}
	}
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the currency symbol used in formatting.
	 *
	 * @returns {String} The currency symbol.
	 *&#x2F;
	this.getCurrencySymbol = function() {
		
		return this.curSym;
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the position of the currency symbol relative to
	 * the amount. Assumes a non-negative amount and local formatting.
	 *
	 * @param {String} intFlag Optional flag to force international
	 * formatting by passing the string &quot;i&quot;.
	 *
	 * @returns {Boolean} True if the symbol precedes the amount, false if
	 * the symbol succeeds the amount.
	 *&#x2F;
	this.currencySymbolPrecedes = function(intFlag) {
		
		if (typeof intFlag == &quot;string&quot; &amp;&amp; intFlag == &quot;i&quot;) {
			&#x2F;&#x2F; international formatting was forced
			if (this.lc.int_p_cs_precedes == 1)
				return true;
			else
				return false;
			
		}
		else {
			&#x2F;&#x2F; check whether local formatting is on or off
			if (this.internationalFormatting) {
				if (this.lc.int_p_cs_precedes == 1)
					return true;
				else
					return false;
			}
			else {
				if (this.lc.p_cs_precedes == 1)
					return true;
				else
					return false;
			}
		}
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the decimal delimiter (radix) used in formatting.
	 *
	 * @returns {String} The radix character.
	 *&#x2F;
	this.getDecimalPoint = function() {
		
		return this.lc.mon_decimal_point;
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Gets the number of fractional digits. Assumes local
	 * formatting.
	 *
	 * @param {String} intFlag Optional flag to force international
	 *        formatting by passing the string &quot;i&quot;.
	 *
	 * @returns {integer Number} The number of fractional digits.
	 *&#x2F;
	this.getFractionalDigits = function(intFlag) {
		
		if (typeof intFlag == &quot;string&quot; &amp;&amp; intFlag == &quot;i&quot;) {
			&#x2F;&#x2F; international formatting was forced
			return this.lc.int_frac_digits;
		}
		else {
			&#x2F;&#x2F; check whether local formatting is on or off
			if (this.internationalFormatting)
				return this.lc.int_frac_digits;
			else
				return this.lc.frac_digits;
		}
	};
	
	
	&#x2F;** 
	 * @public
	 *
	 * @description Formats a monetary amount according to the preset 
	 * locale.
	 *
	 * &lt;pre&gt;
	 * For local currencies the native shorthand symbol will be used for
	 * formatting.
	 * Example:
	 *        locale is en_US
	 *        currency is USD
	 *        -&gt; the &quot;$&quot; symbol will be used, e.g. $123.45
	 *        
	 * For non-local currencies the international ISO-4217 code will be
	 * used for formatting.
	 * Example:
	 *       locale is en_US (which has USD as currency)
	 *       currency is EUR
	 *       -&gt; the ISO three-letter code will be used, e.g. EUR 123.45
	 *
	 * If the currency is non-local, but an alternative currency symbol was
	 * provided, this will be used instead.
	 * Example
	 *       locale is en_US (which has USD as currency)
	 *       currency is EUR
	 *       an alternative symbol is provided - &quot;€&quot;
	 *       -&gt; the alternative symbol will be used, e.g. €123.45
	 * &lt;&#x2F;pre&gt;
	 * 
	 * @param {Number|String} amount The amount to format as currency.
	 * @param {String} [options] Options to modify the formatted output:
	 *       &lt;ul&gt;
	 *           &lt;li&gt;&quot;^&quot;  suppress grouping
	 *           &lt;li&gt;&quot;!&quot;  suppress the currency symbol
	 *           &lt;li&gt;&quot;~&quot;  suppress the currency symbol and the sign (positive or negative)
	 *           &lt;li&gt;&quot;i&quot;  force international sign (ISO-4217 code) formatting
	 *           &lt;li&gt;&quot;.n&quot; specify decimal precision
	 *       
	 * @returns The formatted currency amount as string.
	 *
	 * @throws &quot;Error: Invalid amount&quot; on bad amount.
	 *&#x2F;
	this.format = function(amount, options) {
		
		&#x2F;&#x2F; if the amount is passed as string, check that it parses to a float
		var floatAmount;
		
		if (typeof amount == &quot;string&quot;) {
			amount = jsworld._trim(amount);
			floatAmount = parseFloat(amount);
			
			if (typeof floatAmount != &quot;number&quot; || isNaN(floatAmount))
				throw &quot;Error: Amount string not a number&quot;;
		}
		else if (typeof amount == &quot;number&quot;) {
			floatAmount = amount;
		}
		else {
			throw &quot;Error: Amount not a number&quot;;
		}
		
		&#x2F;&#x2F; get the required precision, &quot;.n&quot; option arg overrides default locale config
		var reqPrecision = jsworld._getPrecision(options);
		
		if (reqPrecision == -1) {
			if (this.internationalFormatting || jsworld._hasOption(&quot;i&quot;, options))
				reqPrecision = this.lc.int_frac_digits;
			else
				reqPrecision = this.lc.frac_digits;
		}
		
		&#x2F;&#x2F; round
		floatAmount = Math.round(floatAmount * Math.pow(10, reqPrecision)) &#x2F; Math.pow(10, reqPrecision);
		
		
		&#x2F;&#x2F; convert the float amount to string and parse into
		&#x2F;&#x2F; object with properties integer and fraction
		var parsedAmount = jsworld._splitNumber(String(floatAmount));
		
		&#x2F;&#x2F; format integer part with grouping chars
		var formattedIntegerPart;
		
		if (floatAmount === 0)
			formattedIntegerPart = &quot;0&quot;;
		else
			formattedIntegerPart = jsworld._hasOption(&quot;^&quot;, options) ?
				parsedAmount.integer :
				jsworld._formatIntegerPart(parsedAmount.integer, 
				                           this.lc.mon_grouping, 
							   this.lc.mon_thousands_sep);
		
		
		&#x2F;&#x2F; format the fractional part
		var formattedFractionPart;
		
		if (reqPrecision == -1) {
			&#x2F;&#x2F; pad fraction with trailing zeros accoring to default locale [int_]frac_digits
			if (this.internationalFormatting || jsworld._hasOption(&quot;i&quot;, options))
				formattedFractionPart =
					jsworld._formatFractionPart(parsedAmount.fraction, this.lc.int_frac_digits);
			else
				formattedFractionPart =
					jsworld._formatFractionPart(parsedAmount.fraction, this.lc.frac_digits);
		}
		else {
			&#x2F;&#x2F; pad fraction with trailing zeros according to optional format parameter
			formattedFractionPart =
				jsworld._formatFractionPart(parsedAmount.fraction, reqPrecision);
		}
		
		
		&#x2F;&#x2F; join integer and decimal parts using the mon_decimal_point property
		var quantity;
		
		if (this.lc.frac_digits &gt; 0 || formattedFractionPart.length)
			quantity = formattedIntegerPart + this.lc.mon_decimal_point + formattedFractionPart;
		else
			quantity = formattedIntegerPart;
		
		
		&#x2F;&#x2F; do final formatting with sign and symbol
		if (jsworld._hasOption(&quot;~&quot;, options)) {
			return quantity;
		}
		else {
			var suppressSymbol = jsworld._hasOption(&quot;!&quot;, options) ? true : false;
			
			var sign = floatAmount &lt; 0 ? &quot;-&quot; : &quot;+&quot;;
			
			if (this.internationalFormatting || jsworld._hasOption(&quot;i&quot;, options)) {
				
				&#x2F;&#x2F; format with ISO-4217 code (suppressed or not)
				if (suppressSymbol)
					return this._formatAsInternationalCurrencyWithNoSym(sign, quantity);
				else
					return this._formatAsInternationalCurrency(sign, quantity);
			}
			else {
				&#x2F;&#x2F; format with local currency code (suppressed or not)
				if (suppressSymbol)
					return this._formatAsLocalCurrencyWithNoSym(sign, quantity);
				else
					return this._formatAsLocalCurrency(sign, quantity);
			}
		}
	};
	
	
	&#x2F;** 
	 * @private
	 *
	 * @description Assembles the final string with sign, separator and symbol as local
	 * currency.
	 *
	 * @param {String} sign The amount sign: &quot;+&quot; or &quot;-&quot;.
	 * @param {String} q The formatted quantity (unsigned).
	 *
	 * @returns {String} The final formatted string.
	 *&#x2F;
	this._formatAsLocalCurrency = function (sign, q) {
		
		&#x2F;&#x2F; assemble final formatted amount by going over all possible value combinations of:
		&#x2F;&#x2F; sign {+,-} , sign position {0,1,2,3,4} , separator {0,1,2} , symbol position {0,1}
		if (sign == &quot;+&quot;) {
			
			&#x2F;&#x2F; parentheses
			if      (this.lc.p_sign_posn === 0 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return &quot;(&quot; + q + this.curSym + &quot;)&quot;;
			}
			else if (this.lc.p_sign_posn === 0 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return &quot;(&quot; + this.curSym + q + &quot;)&quot;;
			}
			else if (this.lc.p_sign_posn === 0 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return &quot;(&quot; + q + &quot; &quot; + this.curSym + &quot;)&quot;;
			}
			else if (this.lc.p_sign_posn === 0 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return &quot;(&quot; + this.curSym + &quot; &quot; + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return this.lc.positive_sign + q + this.curSym;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + this.curSym + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return this.lc.positive_sign + q + &quot; &quot; + this.curSym;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + this.curSym + &quot; &quot; + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return this.lc.positive_sign + &quot; &quot; + q + this.curSym;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + &quot; &quot; + this.curSym + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.curSym + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.curSym + q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return  q + &quot; &quot; + this.curSym + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.curSym + &quot; &quot; + q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.curSym + &quot; &quot; + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.curSym + q + &quot; &quot; + this.lc.positive_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign + this.curSym;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + this.curSym + q;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.positive_sign + this.curSym;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + this.curSym + &quot; &quot; + q;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign + &quot; &quot; + this.curSym;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + &quot; &quot; + this.curSym + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.curSym + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.curSym + this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return  q + &quot; &quot; + this.curSym + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.curSym + this.lc.positive_sign + &quot; &quot; + q;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.curSym + &quot; &quot; + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.curSym + &quot; &quot; + this.lc.positive_sign + q;
			}
			
		}
		else if (sign == &quot;-&quot;) {
			
			&#x2F;&#x2F; parentheses enclose q + sym
			if      (this.lc.n_sign_posn === 0 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return &quot;(&quot; + q + this.curSym + &quot;)&quot;;
			}
			else if (this.lc.n_sign_posn === 0 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return &quot;(&quot; + this.curSym + q + &quot;)&quot;;
			}
			else if (this.lc.n_sign_posn === 0 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return &quot;(&quot; + q + &quot; &quot; + this.curSym + &quot;)&quot;;
			}
			else if (this.lc.n_sign_posn === 0 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return &quot;(&quot; + this.curSym + &quot; &quot; + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return this.lc.negative_sign + q + this.curSym;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + this.curSym + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return this.lc.negative_sign + q + &quot; &quot; + this.curSym;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + this.curSym + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return this.lc.negative_sign + &quot; &quot; + q + this.curSym;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + this.curSym + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.curSym + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.curSym + q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return  q + &quot; &quot; + this.curSym + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.curSym + &quot; &quot; + q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.curSym + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.curSym + q + &quot; &quot; + this.lc.negative_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.lc.negative_sign + this.curSym;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + this.curSym + q;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.negative_sign + this.curSym;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + this.curSym + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.lc.negative_sign + &quot; &quot; + this.curSym;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + this.curSym + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.curSym + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.curSym + this.lc.negative_sign + q;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return  q + &quot; &quot; + this.curSym + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.curSym + this.lc.negative_sign + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.curSym + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.curSym + &quot; &quot; + this.lc.negative_sign + q;
			}
		}
		
		&#x2F;&#x2F; throw error if we fall through
		throw &quot;Error: Invalid POSIX LC MONETARY definition&quot;;
	};
	
	
	&#x2F;** 
	 * @private
	 *
	 * @description Assembles the final string with sign, separator and ISO-4217
	 * currency code.
	 *
	 * @param {String} sign The amount sign: &quot;+&quot; or &quot;-&quot;.
	 * @param {String} q The formatted quantity (unsigned).
	 *
	 * @returns {String} The final formatted string.
	 *&#x2F;
	this._formatAsInternationalCurrency = function (sign, q) {
		
		&#x2F;&#x2F; assemble the final formatted amount by going over all possible value combinations of:
		&#x2F;&#x2F; sign {+,-} , sign position {0,1,2,3,4} , separator {0,1,2} , symbol position {0,1}
		
		if (sign == &quot;+&quot;) {
			
			&#x2F;&#x2F; parentheses
			if      (this.lc.int_p_sign_posn === 0 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return &quot;(&quot; + q + this.currencyCode + &quot;)&quot;;
			}
			else if (this.lc.int_p_sign_posn === 0 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return &quot;(&quot; + this.currencyCode + q + &quot;)&quot;;
			}
			else if (this.lc.int_p_sign_posn === 0 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return &quot;(&quot; + q + this.intSep + this.currencyCode + &quot;)&quot;;
			}
			else if (this.lc.int_p_sign_posn === 0 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return &quot;(&quot; + this.currencyCode + this.intSep + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return this.lc.positive_sign + q + this.currencyCode;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.currencyCode + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return this.lc.positive_sign + q + this.intSep + this.currencyCode;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.currencyCode + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return this.lc.positive_sign + this.intSep + q + this.currencyCode;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + this.currencyCode + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.currencyCode + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.currencyCode + q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return  q + this.intSep + this.currencyCode + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.currencyCode + this.intSep + q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.currencyCode + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.currencyCode + q + this.intSep + this.lc.positive_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.lc.positive_sign + this.currencyCode;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.currencyCode + q;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.intSep + this.lc.positive_sign + this.currencyCode;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.currencyCode + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.lc.positive_sign + this.intSep + this.currencyCode;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + this.currencyCode + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.currencyCode + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.currencyCode + this.lc.positive_sign + q;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return  q + this.intSep + this.currencyCode + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.currencyCode + this.lc.positive_sign + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.currencyCode + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.currencyCode + this.intSep + this.lc.positive_sign + q;
			}
			
		}
		else if (sign == &quot;-&quot;) {
			
			&#x2F;&#x2F; parentheses enclose q + sym
			if      (this.lc.int_n_sign_posn === 0 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return &quot;(&quot; + q + this.currencyCode + &quot;)&quot;;
			}
			else if (this.lc.int_n_sign_posn === 0 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return &quot;(&quot; + this.currencyCode + q + &quot;)&quot;;
			}
			else if (this.lc.int_n_sign_posn === 0 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return &quot;(&quot; + q + this.intSep + this.currencyCode + &quot;)&quot;;
			}
			else if (this.lc.int_n_sign_posn === 0 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return &quot;(&quot; + this.currencyCode + this.intSep + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return this.lc.negative_sign + q + this.currencyCode;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.currencyCode + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return this.lc.negative_sign + q + this.intSep + this.currencyCode;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.currencyCode + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return this.lc.negative_sign + this.intSep + q + this.currencyCode;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + this.currencyCode + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.currencyCode + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.currencyCode + q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return  q + this.intSep + this.currencyCode + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.currencyCode + this.intSep + q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.currencyCode + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.currencyCode + q + this.intSep + this.lc.negative_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.lc.negative_sign + this.currencyCode;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.currencyCode + q;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.intSep + this.lc.negative_sign + this.currencyCode;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.currencyCode + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.lc.negative_sign + this.intSep + this.currencyCode;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + this.currencyCode + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.currencyCode + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.currencyCode + this.lc.negative_sign + q;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return  q + this.intSep + this.currencyCode + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.currencyCode + this.lc.negative_sign + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.currencyCode + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.currencyCode + this.intSep + this.lc.negative_sign + q;
			}
		}
		
		&#x2F;&#x2F; throw error if we fall through
		throw &quot;Error: Invalid POSIX LC MONETARY definition&quot;;
	};
	
	
	&#x2F;** 
	 * @private
	 *
	 * @description Assembles the final string with sign and separator, but suppress the
	 * local currency symbol.
	 *
	 * @param {String} sign The amount sign: &quot;+&quot; or &quot;-&quot;.
	 * @param {String} q The formatted quantity (unsigned).
	 *
	 * @returns {String} The final formatted string
	 *&#x2F;
	this._formatAsLocalCurrencyWithNoSym = function (sign, q) {
		
		&#x2F;&#x2F; assemble the final formatted amount by going over all possible value combinations of:
		&#x2F;&#x2F; sign {+,-} , sign position {0,1,2,3,4} , separator {0,1,2} , symbol position {0,1}
		
		if (sign == &quot;+&quot;) {
			
			&#x2F;&#x2F; parentheses
			if      (this.lc.p_sign_posn === 0) {
				return &quot;(&quot; + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return this.lc.positive_sign + &quot; &quot; + q;
			}
			else if (this.lc.p_sign_posn === 1 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + &quot; &quot; + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return  q + &quot; &quot; + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 2 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return q + &quot; &quot; + this.lc.positive_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + &quot; &quot; + q;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 3 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + &quot; &quot; + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 0 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return  q + &quot; &quot; + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 1 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + &quot; &quot; + q;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.positive_sign;
			}
			else if (this.lc.p_sign_posn === 4 &amp;&amp; this.lc.p_sep_by_space === 2 &amp;&amp; this.lc.p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			
		}
		else if (sign == &quot;-&quot;) {
			
			&#x2F;&#x2F; parentheses enclose q + sym
			if      (this.lc.n_sign_posn === 0) {
				return &quot;(&quot; + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return this.lc.negative_sign + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 1 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return  q + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 2 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return q + &quot; &quot; + this.lc.negative_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 3 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 0 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return  q + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 1 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + &quot; &quot; + q;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 0) {
				return q + &quot; &quot; + this.lc.negative_sign;
			}
			else if (this.lc.n_sign_posn === 4 &amp;&amp; this.lc.n_sep_by_space === 2 &amp;&amp; this.lc.n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
		}
		
		&#x2F;&#x2F; throw error if we fall through
		throw &quot;Error: Invalid POSIX LC MONETARY definition&quot;;
	};
	
	
	&#x2F;** 
	 * @private
	 *
	 * @description Assembles the final string with sign and separator, but suppress
	 * the ISO-4217 currency code.
	 *
	 * @param {String} sign The amount sign: &quot;+&quot; or &quot;-&quot;.
	 * @param {String} q The formatted quantity (unsigned).
	 *
	 * @returns {String} The final formatted string.
	 *&#x2F;
	this._formatAsInternationalCurrencyWithNoSym = function (sign, q) {
		
		&#x2F;&#x2F; assemble the final formatted amount by going over all possible value combinations of:
		&#x2F;&#x2F; sign {+,-} , sign position {0,1,2,3,4} , separator {0,1,2} , symbol position {0,1}
		
		if (sign == &quot;+&quot;) {
			
			&#x2F;&#x2F; parentheses
			if      (this.lc.int_p_sign_posn === 0) {
				return &quot;(&quot; + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return this.lc.positive_sign + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 1 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return  q + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 2 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return q + this.intSep + this.lc.positive_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 3 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 0 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return  q + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 1 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + this.intSep + q;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 0) {
				return q + this.intSep + this.lc.positive_sign;
			}
			else if (this.lc.int_p_sign_posn === 4 &amp;&amp; this.lc.int_p_sep_by_space === 2 &amp;&amp; this.lc.int_p_cs_precedes === 1) {
				return this.lc.positive_sign + q;
			}
			
		}
		else if (sign == &quot;-&quot;) {
			
			&#x2F;&#x2F; parentheses enclose q + sym
			if      (this.lc.int_n_sign_posn === 0) {
				return &quot;(&quot; + q + &quot;)&quot;;
			}
			
			&#x2F;&#x2F; sign before q + sym
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return this.lc.negative_sign + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 1 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + q;
			}
			
			&#x2F;&#x2F; sign after q + sym
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return  q + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 2 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return q + this.intSep + this.lc.negative_sign;
			}
			
			&#x2F;&#x2F; sign before sym
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 3 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + q;
			}
			
			&#x2F;&#x2F; sign after symbol
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 0 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return  q + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 1 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + this.intSep + q;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 0) {
				return q + this.intSep + this.lc.negative_sign;
			}
			else if (this.lc.int_n_sign_posn === 4 &amp;&amp; this.lc.int_n_sep_by_space === 2 &amp;&amp; this.lc.int_n_cs_precedes === 1) {
				return this.lc.negative_sign + q;
			}
		}
		
		&#x2F;&#x2F; throw error if we fall through
		throw &quot;Error: Invalid POSIX LC_MONETARY definition&quot;;
	};
};


&#x2F;** 
 * @class 
 * Class for parsing localised number strings.
 *
 * @public
 * @constructor 
 * @description Creates a new numeric parser for the specified locale.
 *
 * @param {jsworld.Locale} locale A locale object specifying the required 
 *        POSIX LC_NUMERIC formatting properties.
 *
 * @throws Error on constructor failure.
 *&#x2F;
jsworld.NumericParser = function(locale) {

	if (typeof locale != &quot;object&quot; || locale._className != &quot;jsworld.Locale&quot;)
		throw &quot;Constructor error: You must provide a valid jsworld.Locale instance&quot;;

	this.lc = locale;
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Parses a numeric string formatted according to the 
	 * preset locale. Leading and trailing whitespace is ignored; the number
	 * may also be formatted without thousands separators.
	 *
	 * @param {String} formattedNumber The formatted number.
	 *
	 * @returns {Number} The parsed number.
	 *
	 * @throws Error on a parse exception.
	 *&#x2F;
	this.parse = function(formattedNumber) {
	
		if (typeof formattedNumber != &quot;string&quot;)
			throw &quot;Parse error: Argument must be a string&quot;;
	
		&#x2F;&#x2F; trim whitespace
		var s = jsworld._trim(formattedNumber);
	
		&#x2F;&#x2F; remove any thousand separator symbols
		s = jsworld._stringReplaceAll(formattedNumber, this.lc.thousands_sep, &quot;&quot;);
		
		&#x2F;&#x2F; replace any local decimal point symbols with the symbol used
		&#x2F;&#x2F; in JavaScript &quot;.&quot;
		s = jsworld._stringReplaceAll(s, this.lc.decimal_point, &quot;.&quot;);
		
		&#x2F;&#x2F; test if the string represents a number
		if (jsworld._isNumber(s))
			return parseFloat(s, 10);		
		else
			throw &quot;Parse error: Invalid number string&quot;;
	};
};


&#x2F;** 
 * @class 
 * Class for parsing localised date and time strings.
 *
 * @public
 * @constructor 
 * @description Creates a new date&#x2F;time parser for the specified locale.
 *
 * @param {jsworld.Locale} locale A locale object specifying the required 
 *        POSIX LC_TIME formatting properties.
 *
 * @throws Error on constructor failure.
 *&#x2F;
jsworld.DateTimeParser = function(locale) {

	if (typeof locale != &quot;object&quot; || locale._className != &quot;jsworld.Locale&quot;)
		throw &quot;Constructor error: You must provide a valid jsworld.Locale instance.&quot;;

	this.lc = locale;

	
	&#x2F;**
	 * @public
	 *
	 * @description Parses a time string formatted according to the 
	 * POSIX LC_TIME t_fmt property of the preset locale.
	 *
	 * @param {String} formattedTime The formatted time.
	 *
	 * @returns {String} The parsed time in ISO-8601 format (HH:MM:SS), e.g.
	 *          &quot;23:59:59&quot;.
	 *
	 * @throws Error on a parse exception.
	 *&#x2F;
	this.parseTime = function(formattedTime) {
	
		if (typeof formattedTime != &quot;string&quot;)
			throw &quot;Parse error: Argument must be a string&quot;;
	
		var dt = this._extractTokens(this.lc.t_fmt, formattedTime);
		
		var timeDefined = false;
		
		if (dt.hour !== null &amp;&amp; dt.minute !== null &amp;&amp; dt.second !== null) {
			timeDefined = true;
		}
		else if (dt.hourAmPm !== null &amp;&amp; dt.am !== null &amp;&amp; dt.minute !== null &amp;&amp; dt.second !== null) {
			if (dt.am) {
				&#x2F;&#x2F; AM [12(midnight), 1 .. 11]
				if (dt.hourAmPm == 12)
					dt.hour = 0;
				else
					dt.hour = parseInt(dt.hourAmPm, 10);
			}
			else {
				&#x2F;&#x2F; PM [12(noon), 1 .. 11]
				if (dt.hourAmPm == 12)
					dt.hour = 12;
				else
					dt.hour = parseInt(dt.hourAmPm, 10) + 12;
			}
			timeDefined = true;
		}
		
		if (timeDefined)
			return jsworld._zeroPad(dt.hour, 2) + 
			       &quot;:&quot; + 
			       jsworld._zeroPad(dt.minute, 2) + 
			       &quot;:&quot; + 
			       jsworld._zeroPad(dt.second, 2);
		else
			throw &quot;Parse error: Invalid&#x2F;ambiguous time string&quot;;
	};
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Parses a date string formatted according to the 
	 * POSIX LC_TIME d_fmt property of the preset locale.
	 *
	 * @param {String} formattedDate The formatted date, must be valid.
	 *
	 * @returns {String} The parsed date in ISO-8601 format (YYYY-MM-DD), 
	 *          e.g. &quot;2010-03-31&quot;.
	 *
	 * @throws Error on a parse exception.
	 *&#x2F;
	this.parseDate = function(formattedDate) {
	
		if (typeof formattedDate != &quot;string&quot;)
			throw &quot;Parse error: Argument must be a string&quot;;
	
		var dt = this._extractTokens(this.lc.d_fmt, formattedDate);
		
		var dateDefined = false;
		
		if (dt.year !== null &amp;&amp; dt.month !== null &amp;&amp; dt.day !== null) {
			dateDefined = true;
		}
		
		if (dateDefined)
			return jsworld._zeroPad(dt.year, 4) + 
			       &quot;-&quot; + 
			       jsworld._zeroPad(dt.month, 2) + 
			       &quot;-&quot; + 
			       jsworld._zeroPad(dt.day, 2);
		else
			throw &quot;Parse error: Invalid date string&quot;;
	};
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Parses a date&#x2F;time string formatted according to the 
	 * POSIX LC_TIME d_t_fmt property of the preset locale.
	 *
	 * @param {String} formattedDateTime The formatted date&#x2F;time, must be
	 *        valid.
	 *
	 * @returns {String} The parsed date&#x2F;time in ISO-8601 format 
	 *          (YYYY-MM-DD HH:MM:SS), e.g. &quot;2010-03-31 23:59:59&quot;.
	 *
	 * @throws Error on a parse exception.
	 *&#x2F;
	this.parseDateTime = function(formattedDateTime) {
	
		if (typeof formattedDateTime != &quot;string&quot;)
			throw &quot;Parse error: Argument must be a string&quot;;
		
		var dt = this._extractTokens(this.lc.d_t_fmt, formattedDateTime);
		
		var timeDefined = false;
		var dateDefined = false;
	
		if (dt.hour !== null &amp;&amp; dt.minute !== null &amp;&amp; dt.second !== null) {
			timeDefined = true;
		}
		else if (dt.hourAmPm !== null &amp;&amp; dt.am !== null &amp;&amp; dt.minute !== null &amp;&amp; dt.second !== null) {
			if (dt.am) {
				&#x2F;&#x2F; AM [12(midnight), 1 .. 11]
				if (dt.hourAmPm == 12)
					dt.hour = 0;
				else
					dt.hour = parseInt(dt.hourAmPm, 10);
			}
			else {
				&#x2F;&#x2F; PM [12(noon), 1 .. 11]
				if (dt.hourAmPm == 12)
					dt.hour = 12;
				else
					dt.hour = parseInt(dt.hourAmPm, 10) + 12;
			}
			timeDefined = true;
		}
		
		if (dt.year !== null &amp;&amp; dt.month !== null &amp;&amp; dt.day !== null) {
			dateDefined = true;
		}
		
		if (dateDefined &amp;&amp; timeDefined)
			return jsworld._zeroPad(dt.year, 4) + 
			       &quot;-&quot; + 
			       jsworld._zeroPad(dt.month, 2) + 
			       &quot;-&quot; + 
			       jsworld._zeroPad(dt.day, 2) + 
			       &quot; &quot; +
			       jsworld._zeroPad(dt.hour, 2) + 
			       &quot;:&quot; + 
			       jsworld._zeroPad(dt.minute, 2) + 
			       &quot;:&quot; + 
			       jsworld._zeroPad(dt.second, 2);
		else
			throw &quot;Parse error: Invalid&#x2F;ambiguous date&#x2F;time string&quot;;
	};
	
	
	&#x2F;**
	 * @private
	 *
	 * @description Parses a string according to the specified format
	 * specification.
	 *
	 * @param {String} fmtSpec The format specification, e.g. &quot;%I:%M:%S %p&quot;.
	 * @param {String} s The string to parse.
	 *
	 * @returns {object} An object with set properties year, month, day,
	 *          hour, minute and second if the corresponding values are
	 *          found in the parsed string.
	 *
	 * @throws Error on a parse exception.
	 *&#x2F;
	this._extractTokens = function(fmtSpec, s) {
	
		&#x2F;&#x2F; the return object containing the parsed date&#x2F;time properties
		var dt = {
			&#x2F;&#x2F; for date and date&#x2F;time strings
			&quot;year&quot;     : null,
			&quot;month&quot;    : null,
			&quot;day&quot;      : null,
			
			&#x2F;&#x2F; for time and date&#x2F;time strings
			&quot;hour&quot;     : null,
			&quot;hourAmPm&quot; : null,
			&quot;am&quot;       : null,
			&quot;minute&quot;   : null,
			&quot;second&quot;   : null,
			
			&#x2F;&#x2F; used internally only
			&quot;weekday&quot;  : null
		};

	
		&#x2F;&#x2F; extract and process each token in the date&#x2F;time spec
		while (fmtSpec.length &gt; 0) {
		
			&#x2F;&#x2F; Do we have a valid &quot;%\w&quot; placeholder in stream?
			if (fmtSpec.charAt(0) == &quot;%&quot; &amp;&amp; fmtSpec.charAt(1) != &quot;&quot;) {
				
				&#x2F;&#x2F; get placeholder
				var placeholder = fmtSpec.substring(0,2);
				
				if (placeholder == &quot;%%&quot;) {
					&#x2F;&#x2F; escaped &#x27;%&#x27;&#x27;
					s = s.substring(1);
				}
				else if (placeholder == &quot;%a&quot;) {
					&#x2F;&#x2F; abbreviated weekday name
					for (var i = 0; i &lt; this.lc.abday.length; i++) {
					
						if (jsworld._stringStartsWith(s, this.lc.abday[i])) {
							dt.weekday = i;
							s = s.substring(this.lc.abday[i].length);
							break;
						}
					}
					
					if (dt.weekday === null)
						throw &quot;Parse error: Unrecognised abbreviated weekday name (%a)&quot;;
				}
				else if (placeholder == &quot;%A&quot;) {
					&#x2F;&#x2F; weekday name
					for (var i = 0; i &lt; this.lc.day.length; i++) {
					
						if (jsworld._stringStartsWith(s, this.lc.day[i])) {
							dt.weekday = i;
							s = s.substring(this.lc.day[i].length);
							break;
						}
					}
					
					if (dt.weekday === null)
						throw &quot;Parse error: Unrecognised weekday name (%A)&quot;;
				}
				else if (placeholder == &quot;%b&quot; || placeholder == &quot;%h&quot;) {
					&#x2F;&#x2F; abbreviated month name
					for (var i = 0; i &lt; this.lc.abmon.length; i++) {
			
						if (jsworld._stringStartsWith(s, this.lc.abmon[i])) {
							dt.month = i + 1;
							s = s.substring(this.lc.abmon[i].length);
							break;
						}
					}

					if (dt.month === null)
						throw &quot;Parse error: Unrecognised abbreviated month name (%b)&quot;;
				}
				else if (placeholder == &quot;%B&quot;) {
					&#x2F;&#x2F; month name
					for (var i = 0; i &lt; this.lc.mon.length; i++) {
			
						if (jsworld._stringStartsWith(s, this.lc.mon[i])) {
							dt.month = i + 1;
							s = s.substring(this.lc.mon[i].length);
							break;
						}
					}

					if (dt.month === null)
						throw &quot;Parse error: Unrecognised month name (%B)&quot;;
				}
				else if (placeholder == &quot;%d&quot;) {
					&#x2F;&#x2F; day of the month [01..31]
					if (&#x2F;^0[1-9]|[1-2][0-9]|3[0-1]&#x2F;.test(s)) {
						dt.day = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised day of the month (%d)&quot;;
				}
				else if (placeholder == &quot;%e&quot;) {
					&#x2F;&#x2F; day of the month [1..31]
					
					&#x2F;&#x2F; Note: if %e is leading in fmt string -&gt; space padded!
					
					var day = s.match(&#x2F;^\s?(\d{1,2})&#x2F;);
					dt.day = parseInt(day, 10);
					
					if (isNaN(dt.day) || dt.day &lt; 1 || dt.day &gt; 31)
						throw &quot;Parse error: Unrecognised day of the month (%e)&quot;;
					
					s = s.substring(day.length);
				}
				else if (placeholder == &quot;%F&quot;) {
					&#x2F;&#x2F; equivalent to %Y-%m-%d (ISO-8601 date format)
					
					&#x2F;&#x2F; year [nnnn]
					if (&#x2F;^\d\d\d\d&#x2F;.test(s)) {
						dt.year = parseInt(s.substring(0,4), 10);
						s = s.substring(4);
					}
					else {
						throw &quot;Parse error: Unrecognised date (%F)&quot;;
					}
					
					&#x2F;&#x2F; -
					if (jsworld._stringStartsWith(s, &quot;-&quot;))
						s = s.substring(1);
					else
						throw &quot;Parse error: Unrecognised date (%F)&quot;;
					
					&#x2F;&#x2F; month [01..12]
					if (&#x2F;^0[1-9]|1[0-2]&#x2F;.test(s)) {
						dt.month = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised date (%F)&quot;;

					&#x2F;&#x2F; -
					if (jsworld._stringStartsWith(s, &quot;-&quot;))
						s = s.substring(1);
					else
						throw &quot;Parse error: Unrecognised date (%F)&quot;;
					
					&#x2F;&#x2F; day of the month [01..31]
					if (&#x2F;^0[1-9]|[1-2][0-9]|3[0-1]&#x2F;.test(s)) {
						dt.day = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised date (%F)&quot;;
				}
				else if (placeholder == &quot;%H&quot;) {
					&#x2F;&#x2F; hour [00..23]
					if (&#x2F;^[0-1][0-9]|2[0-3]&#x2F;.test(s)) {
						dt.hour = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised hour (%H)&quot;;
				}
				else if (placeholder == &quot;%I&quot;) {
					&#x2F;&#x2F; hour [01..12]
					if (&#x2F;^0[1-9]|1[0-2]&#x2F;.test(s)) {
						dt.hourAmPm = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised hour (%I)&quot;;
				}
				else if (placeholder == &quot;%k&quot;) {
					&#x2F;&#x2F; hour [0..23]
					var h = s.match(&#x2F;^(\d{1,2})&#x2F;);
					dt.hour = parseInt(h, 10);
					
					if (isNaN(dt.hour) || dt.hour &lt; 0 || dt.hour &gt; 23)
						throw &quot;Parse error: Unrecognised hour (%k)&quot;;
					
					s = s.substring(h.length);
				}
				else if (placeholder == &quot;%l&quot;) {
					&#x2F;&#x2F; hour AM&#x2F;PM [1..12]
					var h = s.match(&#x2F;^(\d{1,2})&#x2F;);
					dt.hourAmPm = parseInt(h, 10);
					
					if (isNaN(dt.hourAmPm) || dt.hourAmPm &lt; 1 || dt.hourAmPm &gt; 12)
						throw &quot;Parse error: Unrecognised hour (%l)&quot;;
					
					s = s.substring(h.length);
				}
				else if (placeholder == &quot;%m&quot;) {
					&#x2F;&#x2F; month [01..12]
					if (&#x2F;^0[1-9]|1[0-2]&#x2F;.test(s)) {
						dt.month = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised month (%m)&quot;;
				}
				else if (placeholder == &quot;%M&quot;) {
					&#x2F;&#x2F; minute [00..59]
					if (&#x2F;^[0-5][0-9]&#x2F;.test(s)) {
						dt.minute = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised minute (%M)&quot;;
				}
				else if (placeholder == &quot;%n&quot;) {
					&#x2F;&#x2F; new line
					
					if (s.charAt(0) == &quot;\n&quot;)
						s = s.substring(1);
					else
						throw &quot;Parse error: Unrecognised new line (%n)&quot;;
				}
				else if (placeholder == &quot;%p&quot;) {
					&#x2F;&#x2F; locale&#x27;s equivalent of AM&#x2F;PM
					if (jsworld._stringStartsWith(s, this.lc.am)) {
						dt.am = true;
						s = s.substring(this.lc.am.length);
					}
					else if (jsworld._stringStartsWith(s, this.lc.pm)) {
						dt.am = false;
						s = s.substring(this.lc.pm.length);
					}
					else
						throw &quot;Parse error: Unrecognised AM&#x2F;PM value (%p)&quot;;
				}
				else if (placeholder == &quot;%P&quot;) {
					&#x2F;&#x2F; same as %p but forced lower case
					if (jsworld._stringStartsWith(s, this.lc.am.toLowerCase())) {
						dt.am = true;
						s = s.substring(this.lc.am.length);
					}
					else if (jsworld._stringStartsWith(s, this.lc.pm.toLowerCase())) {
						dt.am = false;
						s = s.substring(this.lc.pm.length);
					}
					else
						throw &quot;Parse error: Unrecognised AM&#x2F;PM value (%P)&quot;;
				}
				else if (placeholder == &quot;%R&quot;) {
					&#x2F;&#x2F; same as %H:%M
					
					&#x2F;&#x2F; hour [00..23]
					if (&#x2F;^[0-1][0-9]|2[0-3]&#x2F;.test(s)) {
						dt.hour = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised time (%R)&quot;;
					
					&#x2F;&#x2F; :
					if (jsworld._stringStartsWith(s, &quot;:&quot;))
						s = s.substring(1);
					else
						throw &quot;Parse error: Unrecognised time (%R)&quot;;

					&#x2F;&#x2F; minute [00..59]
					if (&#x2F;^[0-5][0-9]&#x2F;.test(s)) {
						dt.minute = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised time (%R)&quot;;

				}
				else if (placeholder == &quot;%S&quot;) {
					&#x2F;&#x2F; second [00..59]
					if (&#x2F;^[0-5][0-9]&#x2F;.test(s)) {
						dt.second = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised second (%S)&quot;;
				}
				else if (placeholder == &quot;%T&quot;) {
					&#x2F;&#x2F; same as %H:%M:%S
					
					&#x2F;&#x2F; hour [00..23]
					if (&#x2F;^[0-1][0-9]|2[0-3]&#x2F;.test(s)) {
						dt.hour = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised time (%T)&quot;;
					
					&#x2F;&#x2F; :
					if (jsworld._stringStartsWith(s, &quot;:&quot;))
						s = s.substring(1);
					else
						throw &quot;Parse error: Unrecognised time (%T)&quot;;

					&#x2F;&#x2F; minute [00..59]
					if (&#x2F;^[0-5][0-9]&#x2F;.test(s)) {
						dt.minute = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else	
						throw &quot;Parse error: Unrecognised time (%T)&quot;;
					
					&#x2F;&#x2F; :
					if (jsworld._stringStartsWith(s, &quot;:&quot;))
						s = s.substring(1);
					else
						throw &quot;Parse error: Unrecognised time (%T)&quot;;
					
					&#x2F;&#x2F; second [00..59]
					if (&#x2F;^[0-5][0-9]&#x2F;.test(s)) {
						dt.second = parseInt(s.substring(0,2), 10);
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised time (%T)&quot;;
				}
				else if (placeholder == &quot;%w&quot;) {
					&#x2F;&#x2F; weekday [0..6]
					if (&#x2F;^\d&#x2F;.test(s)) {
						dt.weekday = parseInt(s.substring(0,1), 10);
						s = s.substring(1);
					}
					else 
						throw &quot;Parse error: Unrecognised weekday number (%w)&quot;;
				}
				else if (placeholder == &quot;%y&quot;) {
					&#x2F;&#x2F; year [00..99]
					if (&#x2F;^\d\d&#x2F;.test(s)) {
						var year2digits = parseInt(s.substring(0,2), 10);
						
						&#x2F;&#x2F; this conversion to year[nnnn] is arbitrary!!!
						if (year2digits &gt; 50)
							dt.year = 1900 + year2digits;
						else
							dt.year = 2000 + year2digits;
						
						s = s.substring(2);
					}
					else
						throw &quot;Parse error: Unrecognised year (%y)&quot;;
				}
				else if (placeholder == &quot;%Y&quot;) {
					&#x2F;&#x2F; year [nnnn]
					if (&#x2F;^\d\d\d\d&#x2F;.test(s)) {
						dt.year = parseInt(s.substring(0,4), 10);
						s = s.substring(4);
					}
					else
						throw &quot;Parse error: Unrecognised year (%Y)&quot;;
				}
				
				else if (placeholder == &quot;%Z&quot;) {
					&#x2F;&#x2F; time-zone place holder is not supported
					
					if (fmtSpec.length === 0)
						break; &#x2F;&#x2F; ignore rest of fmt spec
				}

				&#x2F;&#x2F; remove the spec placeholder that was just parsed
				fmtSpec = fmtSpec.substring(2);
			}
			else {
				&#x2F;&#x2F; If we don&#x27;t have a placeholder, the chars
				&#x2F;&#x2F; at pos. 0 of format spec and parsed string must match
				
				&#x2F;&#x2F; Note: Space chars treated 1:1 !
				
				if (fmtSpec.charAt(0) != s.charAt(0))
					throw &quot;Parse error: Unexpected symbol \&quot;&quot; + s.charAt(0) + &quot;\&quot; in date&#x2F;time string&quot;;
			
				fmtSpec = fmtSpec.substring(1);
				s = s.substring(1);
			}
		}
		
		&#x2F;&#x2F; parsing finished, return composite date&#x2F;time object
		return dt;
	};
};


&#x2F;** 
 * @class 
 * Class for parsing localised currency amount strings.
 *
 * @public
 * @constructor 
 * @description Creates a new monetary parser for the specified locale.
 *
 * @param {jsworld.Locale} locale A locale object specifying the required 
 *        POSIX LC_MONETARY formatting properties.
 *
 * @throws Error on constructor failure.
 *&#x2F;
jsworld.MonetaryParser = function(locale) {

	if (typeof locale != &quot;object&quot; || locale._className != &quot;jsworld.Locale&quot;)
		throw &quot;Constructor error: You must provide a valid jsworld.Locale instance&quot;;


	this.lc = locale;
	
	
	&#x2F;**
	 * @public
	 *
	 * @description Parses a currency amount string formatted according to 
	 * the preset locale. Leading and trailing whitespace is ignored; the 
	 * amount may also be formatted without thousands separators. Both
	 * the local (shorthand) symbol and the ISO 4217 code are accepted to 
	 * designate the currency in the formatted amount.
	 *
	 * @param {String} formattedCurrency The formatted currency amount.
	 *
	 * @returns {Number} The parsed amount.
	 *
	 * @throws Error on a parse exception.
	 *&#x2F;
	this.parse = function(formattedCurrency) {
	
		if (typeof formattedCurrency != &quot;string&quot;)
			throw &quot;Parse error: Argument must be a string&quot;;
	
		&#x2F;&#x2F; Detect the format type and remove the currency symbol
		var symbolType = this._detectCurrencySymbolType(formattedCurrency);
	
		var formatType, s;
	
		if (symbolType == &quot;local&quot;) {
			formatType = &quot;local&quot;;
			s = formattedCurrency.replace(this.lc.getCurrencySymbol(), &quot;&quot;);
		}
		else if (symbolType == &quot;int&quot;) {
			formatType = &quot;int&quot;;
			s = formattedCurrency.replace(this.lc.getIntCurrencySymbol(), &quot;&quot;);
		}
		else if (symbolType == &quot;none&quot;) {
			formatType = &quot;local&quot;; &#x2F;&#x2F; assume local
			s = formattedCurrency;
		}
		else
			throw &quot;Parse error: Internal assert failure&quot;;
		
		&#x2F;&#x2F; Remove any thousands separators
		s = jsworld._stringReplaceAll(s, this.lc.mon_thousands_sep, &quot;&quot;);
		
		&#x2F;&#x2F; Replace any local radix char with JavaScript&#x27;s &quot;.&quot;
		s = s.replace(this.lc.mon_decimal_point, &quot;.&quot;);
		
		&#x2F;&#x2F; Remove all whitespaces
		s = s.replace(&#x2F;\s*&#x2F;g, &quot;&quot;);
		
		&#x2F;&#x2F; Remove any local non-negative sign
		s = this._removeLocalNonNegativeSign(s, formatType);
		
		&#x2F;&#x2F; Replace any local minus sign with JavaScript&#x27;s &quot;-&quot; and put
		&#x2F;&#x2F; it in front of the amount if necessary
		&#x2F;&#x2F; (special parentheses rule checked too)
		s = this._normaliseNegativeSign(s, formatType);
		
		&#x2F;&#x2F; Finally, we should be left with a bare parsable decimal number
		if (jsworld._isNumber(s))
			return parseFloat(s, 10);
		else
			throw &quot;Parse error: Invalid currency amount string&quot;;
	};
	
	
	&#x2F;**
	 * @private
	 *
	 * @description Tries to detect the symbol type used in the specified
	 *              formatted currency string: local(shorthand), 
	 *              international (ISO-4217 code) or none.
	 *
	 * @param {String} formattedCurrency The the formatted currency string.
	 *
	 * @return {String} With possible values &quot;local&quot;, &quot;int&quot; or &quot;none&quot;.
	 *&#x2F;
	this._detectCurrencySymbolType = function(formattedCurrency) {
	
		&#x2F;&#x2F; Check for whichever sign (int&#x2F;local) is longer first
		&#x2F;&#x2F; to cover cases such as MOP&#x2F;MOP$ and ZAR&#x2F;R
		
		if (this.lc.getCurrencySymbol().length &gt; this.lc.getIntCurrencySymbol().length) {
		
			if (formattedCurrency.indexOf(this.lc.getCurrencySymbol()) != -1)
				return &quot;local&quot;;
			else if (formattedCurrency.indexOf(this.lc.getIntCurrencySymbol()) != -1)
				return &quot;int&quot;;
			else
				return &quot;none&quot;;
		}
		else {
			if (formattedCurrency.indexOf(this.lc.getIntCurrencySymbol()) != -1)
				return &quot;int&quot;;
			else if (formattedCurrency.indexOf(this.lc.getCurrencySymbol()) != -1)
				return &quot;local&quot;;
			else
				return &quot;none&quot;;
		}
	};
	
	
	&#x2F;**
	 * @private
	 *
	 * @description Removes a local non-negative sign in a formatted 
	 * currency string if it is found. This is done according to the
	 * locale properties p_sign_posn and int_p_sign_posn.
	 *
	 * @param {String} s The input string.
	 * @param {String} formatType With possible values &quot;local&quot; or &quot;int&quot;.
	 *
	 * @returns {String} The processed string.
	 *&#x2F;
	this._removeLocalNonNegativeSign = function(s, formatType) {
	
		s = s.replace(this.lc.positive_sign, &quot;&quot;);
	
		&#x2F;&#x2F; check for enclosing parentheses rule
		if (((formatType == &quot;local&quot; &amp;&amp; this.lc.p_sign_posn     === 0) ||
		     (formatType == &quot;int&quot;   &amp;&amp; this.lc.int_p_sign_posn === 0)    ) &amp;&amp;
		      &#x2F;\(\d+\.?\d*\)&#x2F;.test(s)) {
			s = s.replace(&quot;(&quot;, &quot;&quot;);
			s = s.replace(&quot;)&quot;, &quot;&quot;);
		}
		
		return s;
	};
	
	
	&#x2F;**
	 * @private
	 *
	 * @description Replaces a local negative sign with the standard
	 * JavaScript minus (&quot;-&quot;) sign placed in the correct position 
	 * (preceding the amount). This is done according to the locale
	 * properties for negative sign symbol and relative position.
	 *
	 * @param {String} s The input string.
	 * @param {String} formatType With possible values &quot;local&quot; or &quot;int&quot;.
	 *
	 * @returns {String} The processed string.
	 *&#x2F;
	this._normaliseNegativeSign = function(s, formatType) {
	
		&#x2F;&#x2F; replace local negative symbol with JavaScript&#x27;s &quot;-&quot;
		s = s.replace(this.lc.negative_sign, &quot;-&quot;);
	
		&#x2F;&#x2F; check for enclosing parentheses rule and replace them
		&#x2F;&#x2F; with negative sign before the amount
		if ((formatType == &quot;local&quot; &amp;&amp; this.lc.n_sign_posn     === 0) ||
		    (formatType == &quot;int&quot;   &amp;&amp; this.lc.int_n_sign_posn === 0)    ) {
		    
			if (&#x2F;^\(\d+\.?\d*\)$&#x2F;.test(s)) {
		     
				s = s.replace(&quot;(&quot;, &quot;&quot;);
				s = s.replace(&quot;)&quot;, &quot;&quot;);
				return &quot;-&quot; + s;
			}
		}
		
		&#x2F;&#x2F; check for rule negative sign succeeding the amount
		if (formatType == &quot;local&quot; &amp;&amp; this.lc.n_sign_posn     == 2 ||
		    formatType == &quot;int&quot;   &amp;&amp; this.lc.int_n_sign_posn == 2   ) {
		
			if (&#x2F;^\d+\.?\d*-$&#x2F;.test(s)) {
				s = s.replace(&quot;-&quot;, &quot;&quot;);
				return &quot;-&quot; + s;
			}
		}
	
		&#x2F;&#x2F; check for rule cur. sym. succeeds and sign adjacent
		if (formatType == &quot;local&quot; &amp;&amp; this.lc.n_cs_precedes     === 0 &amp;&amp; this.lc.n_sign_posn     == 3 ||
		    formatType == &quot;local&quot; &amp;&amp; this.lc.n_cs_precedes     === 0 &amp;&amp; this.lc.n_sign_posn     == 4 ||
		    formatType == &quot;int&quot;   &amp;&amp; this.lc.int_n_cs_precedes === 0 &amp;&amp; this.lc.int_n_sign_posn == 3 ||
		    formatType == &quot;int&quot;   &amp;&amp; this.lc.int_n_cs_precedes === 0 &amp;&amp; this.lc.int_n_sign_posn == 4    ) {
		    
		    	if (&#x2F;^\d+\.?\d*-$&#x2F;.test(s)) {
				s = s.replace(&quot;-&quot;, &quot;&quot;);
				return &quot;-&quot; + s;
			}
		}
		
		return s;
	};
};

&#x2F;&#x2F; end-of-file

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
