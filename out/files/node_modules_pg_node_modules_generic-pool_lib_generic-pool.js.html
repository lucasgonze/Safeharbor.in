<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;pg&#x2F;node_modules&#x2F;generic-pool&#x2F;lib&#x2F;generic-pool.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Enables filtering in class lists..html">Enables filtering in class lists.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of currency amounts.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;
POSIX LC_MONETARY&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of dates and times.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;
POSIX LC_TIME&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;..html">Namespace container for the JsWorld library objects..Class for localised formatting of numbers.

&lt;p&gt;See: &lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;
POSIX LC_NUMERIC&lt;&#x2F;a&gt;.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings..html">Namespace container for the JsWorld library objects..Class for parsing localised currency amount strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised date and time strings..html">Namespace container for the JsWorld library objects..Class for parsing localised date and time strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Class for parsing localised number strings..html">Namespace container for the JsWorld library objects..Class for parsing localised number strings.</a></li>
            
                <li><a href="..&#x2F;classes/Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;.html">Namespace container for the JsWorld library objects..Represents a POSIX-style locale with its numeric, monetary and date&#x2F;time 
properties. Also provides a set of locale helper methods.

&lt;p&gt;The locale properties follow the POSIX standards:

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_04&quot;&gt;POSIX LC_NUMERIC&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_03&quot;&gt;POSIX LC_MONETARY&lt;&#x2F;a&gt;
    &lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.opengroup.org&#x2F;onlinepubs&#x2F;000095399&#x2F;basedefs&#x2F;xbd_chap07.html#tag_07_03_05&quot;&gt;POSIX LC_TIME&lt;&#x2F;a&gt;
&lt;&#x2F;ul&gt;</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;pg&#x2F;node_modules&#x2F;generic-pool&#x2F;lib&#x2F;generic-pool.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var PriorityQueue = function(size) {
  var me = {}, slots, i, total = null;

  &#x2F;&#x2F; initialize arrays to hold queue elements
  size = Math.max(+size | 0, 1);
  slots = [];
  for (i = 0; i &lt; size; i += 1) {
    slots.push([]);
  }

  &#x2F;&#x2F;  Public methods
  me.size = function () {
    var i;
    if (total === null) {
      total = 0;
      for (i = 0; i &lt; size; i += 1) {
        total += slots[i].length;
      }
    }
    return total;
  };

  me.enqueue = function (obj, priority) {
    var priorityOrig;

    &#x2F;&#x2F; Convert to integer with a default value of 0.
    priority = priority &amp;&amp; + priority | 0 || 0;

    &#x2F;&#x2F; Clear cache for total.
    total = null;
    if (priority) {
      priorityOrig = priority;
      if (priority &lt; 0 || priority &gt;= size) {
        priority = (size - 1);
        &#x2F;&#x2F; put obj at the end of the line
        console.error(&quot;invalid priority: &quot; + priorityOrig + &quot; must be between 0 and &quot; + priority);
      }
    }

    slots[priority].push(obj);
  };

  me.dequeue = function (callback) {
    var obj = null, i, sl = slots.length;

    &#x2F;&#x2F; Clear cache for total.
    total = null;
    for (i = 0; i &lt; sl; i += 1) {
      if (slots[i].length) {
        obj = slots[i].shift();
        break;
      }
    }
    return obj;
  };

  return me;
};

&#x2F;**
 * Generate an Object pool with a specified &#x60;factory&#x60;.
 *
 * @param {Object} factory
 *   Factory to be used for generating and destorying the items.
 * @param {String} factory.name
 *   Name of the factory. Serves only logging purposes.
 * @param {Function} factory.create
 *   Should create the item to be acquired,
 *   and call it&#x27;s first callback argument with the generated item as it&#x27;s argument.
 * @param {Function} factory.destroy
 *   Should gently close any resources that the item is using.
 *   Called before the items is destroyed.
 * @param {Number} factory.max
 *   Maximum numnber of items that can exist at the same time.
 *   Any further acquire requests will be pushed to the waiting list.
 * @param {Number} factory.idleTimeoutMillis
 *   Delay in milliseconds after the idle items in the pool will be destroyed.
 *   And idle item is that is not acquired yet. Waiting items doesn&#x27;t count here.
 * @param {Number} factory.reapIntervalMillis
 *   Cleanup is scheduled in every &#x60;factory.reapIntervalMillis&#x60; milliseconds.
 * @param {Boolean|Function} factory.log
 *   Whether the pool should log activity. If function is specified,
 *   that will be used instead. The function expects the arguments msg, loglevel
 * @param {Number} factory.priorityRange
 *   The range from 1 to be treated as a valid priority
 *
 * @returns {Object} An Object pool that works with the supplied &#x60;factory&#x60;.
 *&#x2F;
exports.Pool = function (factory) {
  var me = {},

      idleTimeoutMillis = factory.idleTimeoutMillis || 30000,
      reapInterval = factory.reapIntervalMillis || 1000,

      availableObjects = [],
      waitingClients = new PriorityQueue(factory.priorityRange || 1),
      count = 0,
      removeIdleScheduled = false,
      draining = false,

      &#x2F;&#x2F; Prepare a logger function.
      log = factory.log ?
        (function (str, level) {
           typeof factory.log === &#x27;function&#x27; ?
               factory.log(str, level) :
               console.log(level.toUpperCase() + &quot; pool &quot; + factory.name + &quot; - &quot; + str);
         }
        ) :
        function () {};


  factory.max = Math.max(factory.max, 1);

  &#x2F;**
   * Request the client to be destroyed. The factory&#x27;s destroy handler
   * will also be called.
   *
   * @param {Object} obj
   *   The acquired item to be destoyed.
   *&#x2F;
  me.destroy = function(obj) {
    count -= 1;
    factory.destroy(obj);
  };

  &#x2F;**
   * Checks and removes the available (idle) clients that have timed out.
   *&#x2F;
  function removeIdle() {
    var toKeep = [],
        now = new Date().getTime(),
        i,
        al,
        timeout;

    removeIdleScheduled = false;

    &#x2F;&#x2F; Go through the available (idle) items,
    &#x2F;&#x2F; check if they have timed out
    for (i = 0, al = availableObjects.length; i &lt; al; i += 1) {
      timeout = availableObjects[i].timeout;
      if (now &lt; timeout) {
        &#x2F;&#x2F; Client hasn&#x27;t timed out, so keep it.
        toKeep.push(availableObjects[i]);
      } else {
        &#x2F;&#x2F; The client timed out, call its destroyer.
        log(&quot;removeIdle() destroying obj - now:&quot; + now + &quot; timeout:&quot; + timeout, &#x27;verbose&#x27;);
        me.destroy(availableObjects[i].obj);
      }
    }

    &#x2F;&#x2F; Replace the available items with the ones to keep.
    availableObjects = toKeep;
    al = availableObjects.length;

    if (al &gt; 0) {
      log(&quot;availableObjects.length=&quot; + al, &#x27;verbose&#x27;);
      scheduleRemoveIdle();
    } else {
      log(&quot;removeIdle() all objects removed&quot;, &#x27;verbose&#x27;);
    }
  }


  &#x2F;**
   * Schedule removal of idle items in the pool.
   *
   * More schedules cannot run concurrently.
   *&#x2F;
  function scheduleRemoveIdle() {
    if (!removeIdleScheduled) {
      removeIdleScheduled = true;
      setTimeout(removeIdle, reapInterval);
    }
  }

  &#x2F;**
   * Handle callbacks with either the [obj] or [err, obj] arguments in an
   * adaptive manner. Uses the &#x60;cb.length&#x60; property to determine the number
   * of arguments expected by &#x60;cb&#x60;.
   *&#x2F;
  function adjustCallback(cb, err, obj) {
    if (!cb) return;
    if (cb.length &lt;= 1) {
      cb(obj);
    } else {
      cb(err, obj);
    }
  }

  &#x2F;**
   * Try to get a new client to work, and clean up pool unused (idle) items.
   *
   *  - If there are available clients waiting, shift the first one out (LIFO),
   *    and call its callback.
   *  - If there are no waiting clients, try to create one if it won&#x27;t exceed
   *    the maximum number of clients.
   *  - If creating a new client would exceed the maximum, add the client to
   *    the wait list.
   *&#x2F;
  function dispense() {
    var obj = null,
        objWithTimeout = null,
        err = null,
        waitingCount = waitingClients.size();
    log(&quot;dispense() clients=&quot; + waitingCount + &quot; available=&quot; + availableObjects.length, &#x27;info&#x27;);
    if (waitingCount &gt; 0) {
      if (availableObjects.length &gt; 0) {
        log(&quot;dispense() - reusing obj&quot;, &#x27;verbose&#x27;);
        objWithTimeout = availableObjects.shift();
        adjustCallback(waitingClients.dequeue(), err, objWithTimeout.obj);
      }
      else if (count &lt; factory.max) {
        count += 1;
        log(&quot;dispense() - creating obj - count=&quot; + count, &#x27;verbose&#x27;);
        factory.create(function () {
          var cb = waitingClients.dequeue();
          if (arguments.length &gt; 1) {
            err = arguments[0];
            obj = arguments[1];
          } else {
            err = (arguments[0] instanceof Error) ? arguments[0] : null;
            obj = (arguments[0] instanceof Error) ? null : arguments[0];
          }
          if (err) {
            count -= 1;
            adjustCallback(cb, err, obj);
          } else {
            if (cb) {
              adjustCallback(cb, err, obj);
            } else {
              me.release(obj);
            }
          }
        });
      }
    }
  }

  &#x2F;**
   * Request a new client. The callback will be called,
   * when a new client will be availabe, passing the client to it.
   *
   * @param {Function} callback
   *   Callback function to be called after the acquire is successful.
   *   The function will receive the acquired item as the first parameter.
   *
   * @param {Number} priority
   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority
   *   of the caller if there are no available resources.  Lower numbers mean higher
   *   priority.
   *
   * @returns {Object} &#x60;true&#x60; if the pool is not fully utilized, &#x60;false&#x60; otherwise.
   *&#x2F;
  me.acquire = function (callback, priority) {
    if (draining) {
      throw new Error(&quot;pool is draining and cannot accept work&quot;);
    }
    waitingClients.enqueue(callback, priority);
    dispense();
    return (count &lt; factory.max);
  };

  me.borrow = function (callback, priority) {
    log(&quot;borrow() is deprecated. use acquire() instead&quot;, &#x27;warn&#x27;);
    me.acquire(callback, priority);
  };

  &#x2F;**
   * Return the client to the pool, in case it is no longer required.
   *
   * @param {Object} obj
   *   The acquired object to be put back to the pool.
   *&#x2F;
  me.release = function (obj) {
	&#x2F;&#x2F; check to see if this object has already been released (i.e., is back in the pool of availableObjects)
    if (availableObjects.some(function(objWithTimeout) { return (objWithTimeout.obj === obj); })) {
      log(&quot;release called twice for the same resource: &quot; + (new Error().stack), &#x27;error&#x27;);
      return;
    }
    &#x2F;&#x2F;log(&quot;return to pool&quot;);
    var objWithTimeout = { obj: obj, timeout: (new Date().getTime() + idleTimeoutMillis) };
    availableObjects.push(objWithTimeout);
    log(&quot;timeout: &quot; + objWithTimeout.timeout, &#x27;verbose&#x27;);
    dispense();
    scheduleRemoveIdle();
  };

  me.returnToPool = function (obj) {
    log(&quot;returnToPool() is deprecated. use release() instead&quot;, &#x27;warn&#x27;);
    me.release(obj);
  };

  &#x2F;**
   * Disallow any new requests and let the request backlog dissapate.
   *
   * @param {Function} callback
   *   Optional. Callback invoked when all work is done and all clients have been
   *   released.
   *&#x2F;
  me.drain = function(callback) {
    log(&quot;draining&quot;, &#x27;info&#x27;);

    &#x2F;&#x2F; disable the ability to put more work on the queue.
    draining = true;

    var check = function() {
      if (waitingClients.size() &gt; 0) {
        &#x2F;&#x2F; wait until all client requests have been satisfied.
        setTimeout(check, 100);
      } else if (availableObjects.length != count) {
        &#x2F;&#x2F; wait until all objects have been released.
        setTimeout(check, 100);
      } else {
        if (callback) {
          callback();
        }
      }
    };
    check();
  };

  &#x2F;**
   * Forcibly destroys all clients regardless of timeout.  Intended to be
   * invoked as part of a drain.  Does not prevent the creation of new
   * clients as a result of subsequent calls to acquire.
   *
   * @param {Function} callback
   *   Optional. Callback invoked after all existing clients are destroyed.
   *&#x2F;
  me.destroyAllNow = function(callback) {
    log(&quot;force destroying all objects&quot;, &#x27;info&#x27;);
    var willDie = availableObjects;
    availableObjects = [];
    var obj = willDie.shift();
    while (obj !== null &amp;&amp; obj !== undefined) {
      me.destroy(obj.obj);
      obj = willDie.shift();
    }
    if (callback) {
      callback();
    }
  };

  me.getPoolSize = function() {
    return count;
  };

  me.getName = function() {
    return factory.name;
  };

  me.availableObjectsCount = function() {
    return availableObjects.length;
  };

  me.waitingClientsCount = function() {
    return waitingClients.size();
  };

  return me;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
